#![allow(clippy::too_many_arguments, clippy::unreadable_literal)]

use std::default;
use std::ffi::CStr;
use std::fmt;
use std::mem;
use std::num;
use std::ops;
use std::os::raw::{c_char, c_int, c_ulong, c_void};
use std::ptr;

/// Wrapper around Vulkan API version number
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Version(u32);
impl Version {
    /// Forms a version number from major, minor and patch numbers
    ///
    /// ```
    /// # use spark::vk;
    /// let v = vk::Version::from_raw_parts(1, 2, 0);
    /// assert_eq!(v.to_raw(), (1 << 22) | (2 << 12));
    /// ```
    pub const fn from_raw_parts(major: u32, minor: u32, patch: u32) -> Self {
        Self((major << 22) | ((minor & 0x3ff) << 12) | (patch & 0xfff))
    }

    pub const fn from_raw(version: u32) -> Self {
        Self(version)
    }
    pub fn to_raw(self) -> u32 {
        self.0
    }

    pub fn get_major(self) -> u32 {
        self.0 >> 22
    }
    pub fn get_minor(self) -> u32 {
        (self.0 >> 12) & 0x3ff
    }
    pub fn get_patch(self) -> u32 {
        self.0 & 0xfff
    }
}
impl default::Default for Version {
    fn default() -> Self {
        Self::from_raw_parts(1, 0, 0)
    }
}
impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}.{}", self.get_major(), self.get_minor(), self.get_patch())
    }
}

// TODO: replace with ! type when stable
#[doc(hidden)]
pub enum Never {}

// X11
pub type Display = Never;
pub type VisualID = c_ulong;
pub type Window = c_ulong;
pub type RROutput = c_ulong;

// MIR
pub type MirConnection = Never;
pub type MirSurface = Never;

// wayland
#[allow(non_camel_case_types)]
pub type wl_display = Never;
#[allow(non_camel_case_types)]
pub type wl_surface = Never;

// windows
pub type HINSTANCE = *mut c_void;
pub type HWND = *mut c_void;
pub type HANDLE = *mut c_void;
pub type HMONITOR = *mut c_void;
#[allow(non_camel_case_types)]
pub type SECURITY_ATTRIBUTES = Never;
pub type DWORD = c_ulong;
pub type LPCWSTR = *const u16;

#[allow(non_camel_case_types)]
pub type xcb_connection_t = Never;
#[allow(non_camel_case_types)]
pub type xcb_window_t = u32;
#[allow(non_camel_case_types)]
pub type xcb_visualid_t = Never;

pub type IDirectFB = Never;
pub type IDirectFBSurface = Never;

// Android
pub type ANativeWindow = Never;
pub type AHardwareBuffer = Never;

// Metal
pub type CAMetalLayer = Never;

// Zircon
#[allow(non_camel_case_types)]
pub type zx_handle_t = u32;

fn display_bitmask(bits: u64, bit_names: &[(u64, &str)], f: &mut fmt::Formatter) -> fmt::Result {
    let mut has_output = false;
    let mut remain = bits;
    for (bit, name) in bit_names.iter().copied() {
        if (remain & bit) == bit {
            if has_output {
                f.write_str(" | ")?;
            }
            write!(f, "{}", name)?;
            has_output = true;
            remain &= !bit;
        }
    }
    if remain != 0 {
        if has_output {
            f.write_str(" | ")?;
        }
        write!(f, "{:#x}", remain)?;
        has_output = true;
    }
    if !has_output {
        f.write_str("0")?;
    }
    Ok(())
}
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE: usize = 256;
pub const UUID_SIZE: usize = 16;
pub const LUID_SIZE: usize = 8;
pub const LUID_SIZE_KHR: usize = LUID_SIZE;
pub const MAX_EXTENSION_NAME_SIZE: usize = 256;
pub const MAX_DESCRIPTION_SIZE: usize = 256;
pub const MAX_MEMORY_TYPES: usize = 32;
pub const MAX_MEMORY_HEAPS: usize = 16;
pub const LOD_CLAMP_NONE: f32 = 1000_f32;
pub const REMAINING_MIP_LEVELS: u32 = 0xffffffff;
pub const REMAINING_ARRAY_LAYERS: u32 = 0xffffffff;
pub const WHOLE_SIZE: u64 = 0xffffffffffffffff;
pub const ATTACHMENT_UNUSED: u32 = 0xffffffff;
pub const TRUE: Bool32 = 1;
pub const FALSE: Bool32 = 0;
pub const QUEUE_FAMILY_IGNORED: u32 = 0xffffffff;
pub const QUEUE_FAMILY_EXTERNAL: u32 = 0xfffffffe;
pub const QUEUE_FAMILY_EXTERNAL_KHR: u32 = QUEUE_FAMILY_EXTERNAL;
pub const QUEUE_FAMILY_FOREIGN_EXT: u32 = 0xfffffffd;
pub const SUBPASS_EXTERNAL: u32 = 0xffffffff;
pub const MAX_DEVICE_GROUP_SIZE: usize = 32;
pub const MAX_DEVICE_GROUP_SIZE_KHR: usize = MAX_DEVICE_GROUP_SIZE;
pub const MAX_DRIVER_NAME_SIZE: usize = 256;
pub const MAX_DRIVER_NAME_SIZE_KHR: usize = MAX_DRIVER_NAME_SIZE;
pub const MAX_DRIVER_INFO_SIZE: usize = 256;
pub const MAX_DRIVER_INFO_SIZE_KHR: usize = MAX_DRIVER_INFO_SIZE;
pub const SHADER_UNUSED_KHR: u32 = 0xffffffff;
pub const SHADER_UNUSED_NV: u32 = SHADER_UNUSED_KHR;
pub const MAX_GLOBAL_PRIORITY_SIZE_EXT: usize = 16;
pub type SampleMask = u32;
pub type Bool32 = u32;
pub type Flags = u32;
pub type Flags64 = u64;
pub type DeviceSize = u64;
pub type DeviceAddress = u64;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FramebufferCreateFlags(u32);
impl FramebufferCreateFlags {
    pub const IMAGELESS: Self = Self(0x1);
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
}
impl default::Default for FramebufferCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl FramebufferCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for FramebufferCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for FramebufferCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for FramebufferCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for FramebufferCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for FramebufferCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for FramebufferCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for FramebufferCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "IMAGELESS")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPoolCreateFlags(u32);
impl QueryPoolCreateFlags {}
impl default::Default for QueryPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl QueryPoolCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for QueryPoolCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for QueryPoolCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for QueryPoolCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for QueryPoolCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for QueryPoolCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for QueryPoolCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for QueryPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct RenderPassCreateFlags(u32);
impl RenderPassCreateFlags {
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const TRANSFORM_QCOM: Self = Self(0x2);
}
impl default::Default for RenderPassCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl RenderPassCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x2)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x2
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for RenderPassCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for RenderPassCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for RenderPassCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for RenderPassCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for RenderPassCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for RenderPassCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for RenderPassCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x2, "TRANSFORM_QCOM")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SamplerCreateFlags(u32);
impl SamplerCreateFlags {
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_EXT: Self = Self(0x1);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(0x2);
}
impl default::Default for SamplerCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SamplerCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SamplerCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SamplerCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SamplerCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SamplerCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SamplerCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SamplerCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SamplerCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "SUBSAMPLED_EXT"), (0x2, "SUBSAMPLED_COARSE_RECONSTRUCTION_EXT")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineLayoutCreateFlags(u32);
impl PipelineLayoutCreateFlags {}
impl default::Default for PipelineLayoutCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineLayoutCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineLayoutCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineLayoutCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineLayoutCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineLayoutCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineLayoutCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineLayoutCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineLayoutCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCacheCreateFlags(u32);
impl PipelineCacheCreateFlags {
    /// Added by extension VK_EXT_pipeline_creation_cache_control.
    pub const EXTERNALLY_SYNCHRONIZED_EXT: Self = Self(0x1);
}
impl default::Default for PipelineCacheCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCacheCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCacheCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCacheCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCacheCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCacheCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCacheCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCacheCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCacheCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXTERNALLY_SYNCHRONIZED_EXT")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineDepthStencilStateCreateFlags(u32);
impl PipelineDepthStencilStateCreateFlags {
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(0x1);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(0x2);
}
impl default::Default for PipelineDepthStencilStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineDepthStencilStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineDepthStencilStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineDepthStencilStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineDepthStencilStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineDepthStencilStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM"),
                (0x2, "RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineDynamicStateCreateFlags(u32);
impl PipelineDynamicStateCreateFlags {}
impl default::Default for PipelineDynamicStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineDynamicStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineDynamicStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineDynamicStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineDynamicStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineDynamicStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineDynamicStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineDynamicStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineDynamicStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineColorBlendStateCreateFlags(u32);
impl PipelineColorBlendStateCreateFlags {
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM: Self = Self(0x1);
}
impl default::Default for PipelineColorBlendStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineColorBlendStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineColorBlendStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineColorBlendStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineColorBlendStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineColorBlendStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineMultisampleStateCreateFlags(u32);
impl PipelineMultisampleStateCreateFlags {}
impl default::Default for PipelineMultisampleStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineMultisampleStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineMultisampleStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineMultisampleStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineMultisampleStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineMultisampleStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineMultisampleStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineMultisampleStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineMultisampleStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationStateCreateFlags(u32);
impl PipelineRasterizationStateCreateFlags {}
impl default::Default for PipelineRasterizationStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineRasterizationStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineRasterizationStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineRasterizationStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineRasterizationStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineRasterizationStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineRasterizationStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineRasterizationStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineRasterizationStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineViewportStateCreateFlags(u32);
impl PipelineViewportStateCreateFlags {}
impl default::Default for PipelineViewportStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineViewportStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineViewportStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineViewportStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineViewportStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineViewportStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineViewportStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineViewportStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineViewportStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineTessellationStateCreateFlags(u32);
impl PipelineTessellationStateCreateFlags {}
impl default::Default for PipelineTessellationStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineTessellationStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineTessellationStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineTessellationStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineTessellationStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineTessellationStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineTessellationStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineTessellationStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineTessellationStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineInputAssemblyStateCreateFlags(u32);
impl PipelineInputAssemblyStateCreateFlags {}
impl default::Default for PipelineInputAssemblyStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineInputAssemblyStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineInputAssemblyStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineInputAssemblyStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineInputAssemblyStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineInputAssemblyStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineInputAssemblyStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineInputAssemblyStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineInputAssemblyStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineVertexInputStateCreateFlags(u32);
impl PipelineVertexInputStateCreateFlags {}
impl default::Default for PipelineVertexInputStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineVertexInputStateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineVertexInputStateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineVertexInputStateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineVertexInputStateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineVertexInputStateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineVertexInputStateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineVertexInputStateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineVertexInputStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineShaderStageCreateFlags(u32);
impl PipelineShaderStageCreateFlags {
    /// Added by extension VK_EXT_subgroup_size_control.
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self(0x1);
    /// Added by extension VK_EXT_subgroup_size_control.
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self(0x2);
}
impl default::Default for PipelineShaderStageCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineShaderStageCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineShaderStageCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineShaderStageCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineShaderStageCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineShaderStageCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineShaderStageCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineShaderStageCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineShaderStageCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ALLOW_VARYING_SUBGROUP_SIZE_EXT"),
                (0x2, "REQUIRE_FULL_SUBGROUPS_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorSetLayoutCreateFlags(u32);
impl DescriptorSetLayoutCreateFlags {
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(0x2);
    /// Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR
    /// Added by extension VK_KHR_push_descriptor.
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(0x1);
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const HOST_ONLY_POOL_VALVE: Self = Self(0x4);
}
impl default::Default for DescriptorSetLayoutCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DescriptorSetLayoutCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DescriptorSetLayoutCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DescriptorSetLayoutCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DescriptorSetLayoutCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DescriptorSetLayoutCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x2, "UPDATE_AFTER_BIND_POOL"),
                (0x1, "PUSH_DESCRIPTOR_KHR"),
                (0x4, "HOST_ONLY_POOL_VALVE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferViewCreateFlags(u32);
impl BufferViewCreateFlags {}
impl default::Default for BufferViewCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl BufferViewCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for BufferViewCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for BufferViewCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for BufferViewCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for BufferViewCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for BufferViewCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for BufferViewCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for BufferViewCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct InstanceCreateFlags(u32);
impl InstanceCreateFlags {}
impl default::Default for InstanceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl InstanceCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for InstanceCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for InstanceCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for InstanceCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for InstanceCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for InstanceCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for InstanceCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for InstanceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceCreateFlags(u32);
impl DeviceCreateFlags {}
impl default::Default for DeviceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DeviceCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DeviceCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DeviceCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DeviceCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DeviceCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DeviceCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DeviceCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DeviceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceQueueCreateFlags(u32);
impl DeviceQueueCreateFlags {
    /// Queue is a protected-capable device queue
    pub const PROTECTED: Self = Self(0x1);
}
impl default::Default for DeviceQueueCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DeviceQueueCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DeviceQueueCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DeviceQueueCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DeviceQueueCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DeviceQueueCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DeviceQueueCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DeviceQueueCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DeviceQueueCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PROTECTED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueueFlags(u32);
impl QueueFlags {
    /// Queue supports graphics operations
    pub const GRAPHICS: Self = Self(0x1);
    /// Queue supports compute operations
    pub const COMPUTE: Self = Self(0x2);
    /// Queue supports transfer operations
    pub const TRANSFER: Self = Self(0x4);
    /// Queue supports sparse resource memory management operations
    pub const SPARSE_BINDING: Self = Self(0x8);
    /// Queues may support protected operations
    pub const PROTECTED: Self = Self(0x10);
}
impl default::Default for QueueFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl QueueFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for QueueFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for QueueFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for QueueFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for QueueFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for QueueFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for QueueFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for QueueFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "GRAPHICS"),
                (0x2, "COMPUTE"),
                (0x4, "TRANSFER"),
                (0x8, "SPARSE_BINDING"),
                (0x10, "PROTECTED"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryPropertyFlags(u32);
impl MemoryPropertyFlags {
    /// If otherwise stated, then allocate memory on device
    pub const DEVICE_LOCAL: Self = Self(0x1);
    /// Memory is mappable by host
    pub const HOST_VISIBLE: Self = Self(0x2);
    /// Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
    pub const HOST_COHERENT: Self = Self(0x4);
    /// Memory will be cached by the host
    pub const HOST_CACHED: Self = Self(0x8);
    /// Memory may be allocated by the driver when it is required
    pub const LAZILY_ALLOCATED: Self = Self(0x10);
    /// Memory is protected
    pub const PROTECTED: Self = Self(0x20);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const DEVICE_COHERENT_AMD: Self = Self(0x40);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const DEVICE_UNCACHED_AMD: Self = Self(0x80);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const RDMA_CAPABLE_NV: Self = Self(0x100);
}
impl default::Default for MemoryPropertyFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl MemoryPropertyFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MemoryPropertyFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MemoryPropertyFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MemoryPropertyFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MemoryPropertyFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MemoryPropertyFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MemoryPropertyFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MemoryPropertyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DEVICE_LOCAL"),
                (0x2, "HOST_VISIBLE"),
                (0x4, "HOST_COHERENT"),
                (0x8, "HOST_CACHED"),
                (0x10, "LAZILY_ALLOCATED"),
                (0x20, "PROTECTED"),
                (0x40, "DEVICE_COHERENT_AMD"),
                (0x80, "DEVICE_UNCACHED_AMD"),
                (0x100, "RDMA_CAPABLE_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryHeapFlags(u32);
impl MemoryHeapFlags {
    /// If set, heap represents device memory
    pub const DEVICE_LOCAL: Self = Self(0x1);
    /// If set, heap allocations allocate multiple instances by default
    pub const MULTI_INSTANCE: Self = Self(0x2);
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
}
impl default::Default for MemoryHeapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl MemoryHeapFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MemoryHeapFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MemoryHeapFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MemoryHeapFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MemoryHeapFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MemoryHeapFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MemoryHeapFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MemoryHeapFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "DEVICE_LOCAL"), (0x2, "MULTI_INSTANCE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccessFlags(u32);
impl AccessFlags {
    /// Controls coherency of indirect command reads
    pub const INDIRECT_COMMAND_READ: Self = Self(0x1);
    /// Controls coherency of index reads
    pub const INDEX_READ: Self = Self(0x2);
    /// Controls coherency of vertex attribute reads
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(0x4);
    /// Controls coherency of uniform buffer reads
    pub const UNIFORM_READ: Self = Self(0x8);
    /// Controls coherency of input attachment reads
    pub const INPUT_ATTACHMENT_READ: Self = Self(0x10);
    /// Controls coherency of shader reads
    pub const SHADER_READ: Self = Self(0x20);
    /// Controls coherency of shader writes
    pub const SHADER_WRITE: Self = Self(0x40);
    /// Controls coherency of color attachment reads
    pub const COLOR_ATTACHMENT_READ: Self = Self(0x80);
    /// Controls coherency of color attachment writes
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(0x100);
    /// Controls coherency of depth/stencil attachment reads
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(0x200);
    /// Controls coherency of depth/stencil attachment writes
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(0x400);
    /// Controls coherency of transfer reads
    pub const TRANSFER_READ: Self = Self(0x800);
    /// Controls coherency of transfer writes
    pub const TRANSFER_WRITE: Self = Self(0x1000);
    /// Controls coherency of host reads
    pub const HOST_READ: Self = Self(0x2000);
    /// Controls coherency of host writes
    pub const HOST_WRITE: Self = Self(0x4000);
    /// Controls coherency of memory reads
    pub const MEMORY_READ: Self = Self(0x8000);
    /// Controls coherency of memory writes
    pub const MEMORY_WRITE: Self = Self(0x10000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(0x2000000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(0x4000000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(0x8000000);
    /// read access flag for reading conditional rendering predicate
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(0x100000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(0x80000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(0x200000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(0x400000);
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(0x800000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(0x20000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(0x40000);
    /// Added by extension VK_KHR_synchronization2.
    pub const NONE_KHR: Self = Self(0x0);
}
impl default::Default for AccessFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl AccessFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xfffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xfffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AccessFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AccessFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AccessFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AccessFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AccessFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AccessFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AccessFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INDIRECT_COMMAND_READ"),
                (0x2, "INDEX_READ"),
                (0x4, "VERTEX_ATTRIBUTE_READ"),
                (0x8, "UNIFORM_READ"),
                (0x10, "INPUT_ATTACHMENT_READ"),
                (0x20, "SHADER_READ"),
                (0x40, "SHADER_WRITE"),
                (0x80, "COLOR_ATTACHMENT_READ"),
                (0x100, "COLOR_ATTACHMENT_WRITE"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT_READ"),
                (0x400, "DEPTH_STENCIL_ATTACHMENT_WRITE"),
                (0x800, "TRANSFER_READ"),
                (0x1000, "TRANSFER_WRITE"),
                (0x2000, "HOST_READ"),
                (0x4000, "HOST_WRITE"),
                (0x8000, "MEMORY_READ"),
                (0x10000, "MEMORY_WRITE"),
                (0x2000000, "TRANSFORM_FEEDBACK_WRITE_EXT"),
                (0x4000000, "TRANSFORM_FEEDBACK_COUNTER_READ_EXT"),
                (0x8000000, "TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT"),
                (0x100000, "CONDITIONAL_RENDERING_READ_EXT"),
                (0x80000, "COLOR_ATTACHMENT_READ_NONCOHERENT_EXT"),
                (0x200000, "ACCELERATION_STRUCTURE_READ_KHR"),
                (0x400000, "ACCELERATION_STRUCTURE_WRITE_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_READ_EXT"),
                (0x800000, "FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR"),
                (0x20000, "COMMAND_PREPROCESS_READ_NV"),
                (0x40000, "COMMAND_PREPROCESS_WRITE_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferUsageFlags(u32);
impl BufferUsageFlags {
    /// Can be used as a source of transfer operations
    pub const TRANSFER_SRC: Self = Self(0x1);
    /// Can be used as a destination of transfer operations
    pub const TRANSFER_DST: Self = Self(0x2);
    /// Can be used as TBO
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x4);
    /// Can be used as IBO
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x8);
    /// Can be used as UBO
    pub const UNIFORM_BUFFER: Self = Self(0x10);
    /// Can be used as SSBO
    pub const STORAGE_BUFFER: Self = Self(0x20);
    /// Can be used as source of fixed-function index fetch (index buffer)
    pub const INDEX_BUFFER: Self = Self(0x40);
    /// Can be used as source of fixed-function vertex fetch (VBO)
    pub const VERTEX_BUFFER: Self = Self(0x80);
    /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
    pub const INDIRECT_BUFFER: Self = Self(0x100);
    pub const SHADER_DEVICE_ADDRESS: Self = Self(0x20000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(0x800);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(0x1000);
    /// Specifies the buffer can be used as predicate in conditional rendering
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x200);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(0x80000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(0x100000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(0x400);
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
}
impl default::Default for BufferUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl BufferUsageFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1a1fff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1a1fff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for BufferUsageFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for BufferUsageFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for BufferUsageFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for BufferUsageFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for BufferUsageFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for BufferUsageFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for BufferUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRANSFER_SRC"),
                (0x2, "TRANSFER_DST"),
                (0x4, "UNIFORM_TEXEL_BUFFER"),
                (0x8, "STORAGE_TEXEL_BUFFER"),
                (0x10, "UNIFORM_BUFFER"),
                (0x20, "STORAGE_BUFFER"),
                (0x40, "INDEX_BUFFER"),
                (0x80, "VERTEX_BUFFER"),
                (0x100, "INDIRECT_BUFFER"),
                (0x20000, "SHADER_DEVICE_ADDRESS"),
                (0x800, "TRANSFORM_FEEDBACK_BUFFER_EXT"),
                (0x1000, "TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT"),
                (0x200, "CONDITIONAL_RENDERING_EXT"),
                (0x80000, "ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR"),
                (0x100000, "ACCELERATION_STRUCTURE_STORAGE_KHR"),
                (0x400, "SHADER_BINDING_TABLE_KHR"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferCreateFlags(u32);
impl BufferCreateFlags {
    /// Buffer should support sparse backing
    pub const SPARSE_BINDING: Self = Self(0x1);
    /// Buffer should support sparse backing with partial residency
    pub const SPARSE_RESIDENCY: Self = Self(0x2);
    /// Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
    pub const SPARSE_ALIASED: Self = Self(0x4);
    /// Buffer requires protected memory
    pub const PROTECTED: Self = Self(0x8);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x10);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
}
impl default::Default for BufferCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl BufferCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for BufferCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for BufferCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for BufferCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for BufferCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for BufferCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for BufferCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for BufferCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPARSE_BINDING"),
                (0x2, "SPARSE_RESIDENCY"),
                (0x4, "SPARSE_ALIASED"),
                (0x8, "PROTECTED"),
                (0x10, "DEVICE_ADDRESS_CAPTURE_REPLAY"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderStageFlags(u32);
impl ShaderStageFlags {
    pub const VERTEX: Self = Self(0x1);
    pub const TESSELLATION_CONTROL: Self = Self(0x2);
    pub const TESSELLATION_EVALUATION: Self = Self(0x4);
    pub const GEOMETRY: Self = Self(0x8);
    pub const FRAGMENT: Self = Self(0x10);
    pub const COMPUTE: Self = Self(0x20);
    pub const ALL_GRAPHICS: Self = Self(0x1f);
    pub const ALL: Self = Self(0x7fffffff);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAYGEN_KHR: Self = Self(0x100);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const ANY_HIT_KHR: Self = Self(0x200);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const CLOSEST_HIT_KHR: Self = Self(0x400);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const MISS_KHR: Self = Self(0x800);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const INTERSECTION_KHR: Self = Self(0x1000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const CALLABLE_KHR: Self = Self(0x2000);
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    pub const MISS_NV: Self = Self::MISS_KHR;
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    /// Added by extension VK_NV_mesh_shader.
    pub const TASK_NV: Self = Self(0x40);
    /// Added by extension VK_NV_mesh_shader.
    pub const MESH_NV: Self = Self(0x80);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(0x4000);
}
impl default::Default for ShaderStageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ShaderStageFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7fffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7fffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ShaderStageFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ShaderStageFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ShaderStageFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ShaderStageFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ShaderStageFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ShaderStageFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ShaderStageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VERTEX"),
                (0x2, "TESSELLATION_CONTROL"),
                (0x4, "TESSELLATION_EVALUATION"),
                (0x8, "GEOMETRY"),
                (0x10, "FRAGMENT"),
                (0x20, "COMPUTE"),
                (0x1f, "ALL_GRAPHICS"),
                (0x7fffffff, "ALL"),
                (0x100, "RAYGEN_KHR"),
                (0x200, "ANY_HIT_KHR"),
                (0x400, "CLOSEST_HIT_KHR"),
                (0x800, "MISS_KHR"),
                (0x1000, "INTERSECTION_KHR"),
                (0x2000, "CALLABLE_KHR"),
                (0x40, "TASK_NV"),
                (0x80, "MESH_NV"),
                (0x4000, "SUBPASS_SHADING_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageUsageFlags(u32);
impl ImageUsageFlags {
    /// Can be used as a source of transfer operations
    pub const TRANSFER_SRC: Self = Self(0x1);
    /// Can be used as a destination of transfer operations
    pub const TRANSFER_DST: Self = Self(0x2);
    /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    pub const SAMPLED: Self = Self(0x4);
    /// Can be used as storage image (STORAGE_IMAGE descriptor type)
    pub const STORAGE: Self = Self(0x8);
    /// Can be used as framebuffer color attachment
    pub const COLOR_ATTACHMENT: Self = Self(0x10);
    /// Can be used as framebuffer depth/stencil attachment
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x20);
    /// Image data not needed outside of rendering
    pub const TRANSIENT_ATTACHMENT: Self = Self(0x40);
    /// Can be used as framebuffer input attachment
    pub const INPUT_ATTACHMENT: Self = Self(0x80);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x200);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x100);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_HUAWEI: Self = Self(0x40000);
}
impl default::Default for ImageUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageUsageFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x403ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x403ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageUsageFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageUsageFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageUsageFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageUsageFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageUsageFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageUsageFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRANSFER_SRC"),
                (0x2, "TRANSFER_DST"),
                (0x4, "SAMPLED"),
                (0x8, "STORAGE"),
                (0x10, "COLOR_ATTACHMENT"),
                (0x20, "DEPTH_STENCIL_ATTACHMENT"),
                (0x40, "TRANSIENT_ATTACHMENT"),
                (0x80, "INPUT_ATTACHMENT"),
                (0x200, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x100, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x40000, "INVOCATION_MASK_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageCreateFlags(u32);
impl ImageCreateFlags {
    /// Image should support sparse backing
    pub const SPARSE_BINDING: Self = Self(0x1);
    /// Image should support sparse backing with partial residency
    pub const SPARSE_RESIDENCY: Self = Self(0x2);
    /// Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
    pub const SPARSE_ALIASED: Self = Self(0x4);
    /// Allows image views to have different format than the base image
    pub const MUTABLE_FORMAT: Self = Self(0x8);
    /// Allows creating image views with cube type from the created image
    pub const CUBE_COMPATIBLE: Self = Self(0x10);
    pub const ALIAS: Self = Self(0x400);
    /// Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(0x40);
    /// The 3D image can be viewed as a 2D or 2D array image
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(0x20);
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(0x80);
    pub const EXTENDED_USAGE: Self = Self(0x100);
    /// Image requires protected memory
    pub const PROTECTED: Self = Self(0x800);
    pub const DISJOINT: Self = Self(0x200);
    /// Added by extension VK_NV_corner_sampled_image.
    pub const CORNER_SAMPLED_NV: Self = Self(0x2000);
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(0x1000);
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    pub const ALIAS_KHR: Self = Self::ALIAS;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_EXT: Self = Self(0x4000);
}
impl default::Default for ImageCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7fff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7fff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPARSE_BINDING"),
                (0x2, "SPARSE_RESIDENCY"),
                (0x4, "SPARSE_ALIASED"),
                (0x8, "MUTABLE_FORMAT"),
                (0x10, "CUBE_COMPATIBLE"),
                (0x400, "ALIAS"),
                (0x40, "SPLIT_INSTANCE_BIND_REGIONS"),
                (0x20, "N2D_ARRAY_COMPATIBLE"),
                (0x80, "BLOCK_TEXEL_VIEW_COMPATIBLE"),
                (0x100, "EXTENDED_USAGE"),
                (0x800, "PROTECTED"),
                (0x200, "DISJOINT"),
                (0x2000, "CORNER_SAMPLED_NV"),
                (0x1000, "SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT"),
                (0x4000, "SUBSAMPLED_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageViewCreateFlags(u32);
impl ImageViewCreateFlags {
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(0x1);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(0x2);
}
impl default::Default for ImageViewCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageViewCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageViewCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageViewCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageViewCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageViewCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageViewCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageViewCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageViewCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "FRAGMENT_DENSITY_MAP_DYNAMIC_EXT"),
                (0x2, "FRAGMENT_DENSITY_MAP_DEFERRED_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCreateFlags(u32);
impl PipelineCreateFlags {
    pub const DISABLE_OPTIMIZATION: Self = Self(0x1);
    pub const ALLOW_DERIVATIVES: Self = Self(0x2);
    pub const DERIVATIVE: Self = Self(0x4);
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(0x8);
    pub const DISPATCH_BASE: Self = Self(0x10);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x200000);
    pub const RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(0x400000);
    pub const RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE;
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(0x4000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(0x8000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(0x10000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(0x20000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(0x1000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(0x2000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(0x80000);
    /// Added by extension VK_NV_ray_tracing.
    pub const DEFER_COMPILE_NV: Self = Self(0x20);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const CAPTURE_STATISTICS_KHR: Self = Self(0x40);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(0x80);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_BINDABLE_NV: Self = Self(0x40000);
    /// Added by extension VK_KHR_pipeline_library.
    pub const LIBRARY_KHR: Self = Self(0x800);
    /// Added by extension VK_EXT_pipeline_creation_cache_control.
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self(0x100);
    /// Added by extension VK_EXT_pipeline_creation_cache_control.
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self(0x200);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(0x100000);
}
impl default::Default for PipelineCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7ffbff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7ffbff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DISABLE_OPTIMIZATION"),
                (0x2, "ALLOW_DERIVATIVES"),
                (0x4, "DERIVATIVE"),
                (0x8, "VIEW_INDEX_FROM_DEVICE_INDEX"),
                (0x10, "DISPATCH_BASE"),
                (0x200000, "RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x400000, "RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT"),
                (0x4000, "RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR"),
                (0x8000, "RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR"),
                (0x10000, "RAY_TRACING_NO_NULL_MISS_SHADERS_KHR"),
                (0x20000, "RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR"),
                (0x1000, "RAY_TRACING_SKIP_TRIANGLES_KHR"),
                (0x2000, "RAY_TRACING_SKIP_AABBS_KHR"),
                (0x80000, "RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR"),
                (0x20, "DEFER_COMPILE_NV"),
                (0x40, "CAPTURE_STATISTICS_KHR"),
                (0x80, "CAPTURE_INTERNAL_REPRESENTATIONS_KHR"),
                (0x40000, "INDIRECT_BINDABLE_NV"),
                (0x800, "LIBRARY_KHR"),
                (0x100, "FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT"),
                (0x200, "EARLY_RETURN_ON_FAILURE_EXT"),
                (0x100000, "RAY_TRACING_ALLOW_MOTION_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ColorComponentFlags(u32);
impl ColorComponentFlags {
    pub const R: Self = Self(0x1);
    pub const G: Self = Self(0x2);
    pub const B: Self = Self(0x4);
    pub const A: Self = Self(0x8);
}
impl default::Default for ColorComponentFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ColorComponentFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ColorComponentFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ColorComponentFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ColorComponentFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ColorComponentFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ColorComponentFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ColorComponentFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ColorComponentFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "R"), (0x2, "G"), (0x4, "B"), (0x8, "A")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FenceCreateFlags(u32);
impl FenceCreateFlags {
    pub const SIGNALED: Self = Self(0x1);
}
impl default::Default for FenceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl FenceCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for FenceCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for FenceCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for FenceCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for FenceCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for FenceCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for FenceCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for FenceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "SIGNALED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SemaphoreCreateFlags(u32);
impl SemaphoreCreateFlags {}
impl default::Default for SemaphoreCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SemaphoreCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SemaphoreCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SemaphoreCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SemaphoreCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SemaphoreCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SemaphoreCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SemaphoreCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SemaphoreCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FormatFeatureFlags(u32);
impl FormatFeatureFlags {
    /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    pub const SAMPLED_IMAGE: Self = Self(0x1);
    /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
    pub const STORAGE_IMAGE: Self = Self(0x2);
    /// Format supports atomic operations in case it is used for storage images
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(0x4);
    /// Format can be used for uniform texel buffers (TBOs)
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x8);
    /// Format can be used for storage texel buffers (IBOs)
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x10);
    /// Format supports atomic operations in case it is used for storage texel buffers
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(0x20);
    /// Format can be used for vertex buffers (VBOs)
    pub const VERTEX_BUFFER: Self = Self(0x40);
    /// Format can be used for color attachment images
    pub const COLOR_ATTACHMENT: Self = Self(0x80);
    /// Format supports blending in case it is used for color attachment images
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(0x100);
    /// Format can be used for depth/stencil attachment images
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x200);
    /// Format can be used as the source image of blits with vkCmdBlitImage
    pub const BLIT_SRC: Self = Self(0x400);
    /// Format can be used as the destination image of blits with vkCmdBlitImage
    pub const BLIT_DST: Self = Self(0x800);
    /// Format can be filtered with VK_FILTER_LINEAR when being sampled
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(0x1000);
    /// Format can be used as the source image of image transfer commands
    pub const TRANSFER_SRC: Self = Self(0x4000);
    /// Format can be used as the destination image of image transfer commands
    pub const TRANSFER_DST: Self = Self(0x8000);
    /// Format can have midpoint rather than cosited chroma samples
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(0x20000);
    /// Format can be used with linear filtering whilst color conversion is enabled
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(0x40000);
    /// Format can have different chroma, min and mag filters
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(0x80000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(0x100000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(0x200000);
    /// Format supports disjoint planes
    pub const DISJOINT: Self = Self(0x400000);
    /// Format can have cosited rather than midpoint chroma samples
    pub const COSITED_CHROMA_SAMPLES: Self = Self(0x800000);
    /// Format can be used with min/max reduction filtering
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(0x10000);
    /// Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
    /// Added by extension VK_IMG_filter_cubic.
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(0x2000);
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(0x20000000);
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x40000000);
}
impl default::Default for FormatFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl FormatFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x61ffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x61ffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for FormatFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for FormatFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for FormatFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for FormatFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for FormatFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for FormatFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for FormatFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SAMPLED_IMAGE"),
                (0x2, "STORAGE_IMAGE"),
                (0x4, "STORAGE_IMAGE_ATOMIC"),
                (0x8, "UNIFORM_TEXEL_BUFFER"),
                (0x10, "STORAGE_TEXEL_BUFFER"),
                (0x20, "STORAGE_TEXEL_BUFFER_ATOMIC"),
                (0x40, "VERTEX_BUFFER"),
                (0x80, "COLOR_ATTACHMENT"),
                (0x100, "COLOR_ATTACHMENT_BLEND"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT"),
                (0x400, "BLIT_SRC"),
                (0x800, "BLIT_DST"),
                (0x1000, "SAMPLED_IMAGE_FILTER_LINEAR"),
                (0x4000, "TRANSFER_SRC"),
                (0x8000, "TRANSFER_DST"),
                (0x20000, "MIDPOINT_CHROMA_SAMPLES"),
                (0x40000, "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER"),
                (0x80000, "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER"),
                (
                    0x100000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT",
                ),
                (
                    0x200000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE",
                ),
                (0x400000, "DISJOINT"),
                (0x800000, "COSITED_CHROMA_SAMPLES"),
                (0x10000, "SAMPLED_IMAGE_FILTER_MINMAX"),
                (0x2000, "SAMPLED_IMAGE_FILTER_CUBIC_IMG"),
                (0x20000000, "ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x40000000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryControlFlags(u32);
impl QueryControlFlags {
    /// Require precise results to be collected by the query
    pub const PRECISE: Self = Self(0x1);
}
impl default::Default for QueryControlFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl QueryControlFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for QueryControlFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for QueryControlFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for QueryControlFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for QueryControlFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for QueryControlFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for QueryControlFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for QueryControlFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PRECISE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryResultFlags(u32);
impl QueryResultFlags {
    /// Results of the queries are written to the destination buffer as 64-bit values
    pub const N64: Self = Self(0x1);
    /// Results of the queries are waited on before proceeding with the result copy
    pub const WAIT: Self = Self(0x2);
    /// Besides the results of the query, the availability of the results is also written
    pub const WITH_AVAILABILITY: Self = Self(0x4);
    /// Copy the partial results of the query even if the final results are not available
    pub const PARTIAL: Self = Self(0x8);
}
impl default::Default for QueryResultFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl QueryResultFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for QueryResultFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for QueryResultFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for QueryResultFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for QueryResultFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for QueryResultFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for QueryResultFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for QueryResultFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "N64"),
                (0x2, "WAIT"),
                (0x4, "WITH_AVAILABILITY"),
                (0x8, "PARTIAL"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderModuleCreateFlags(u32);
impl ShaderModuleCreateFlags {}
impl default::Default for ShaderModuleCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ShaderModuleCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ShaderModuleCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ShaderModuleCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ShaderModuleCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ShaderModuleCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ShaderModuleCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ShaderModuleCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ShaderModuleCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct EventCreateFlags(u32);
impl EventCreateFlags {
    /// Added by extension VK_KHR_synchronization2.
    pub const DEVICE_ONLY_KHR: Self = Self(0x1);
}
impl default::Default for EventCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl EventCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for EventCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for EventCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for EventCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for EventCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for EventCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for EventCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for EventCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "DEVICE_ONLY_KHR")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandPoolCreateFlags(u32);
impl CommandPoolCreateFlags {
    /// Command buffers have a short lifetime
    pub const TRANSIENT: Self = Self(0x1);
    /// Command buffers may release their memory individually
    pub const RESET_COMMAND_BUFFER: Self = Self(0x2);
    /// Command buffers allocated from pool are protected command buffers
    pub const PROTECTED: Self = Self(0x4);
}
impl default::Default for CommandPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CommandPoolCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CommandPoolCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CommandPoolCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CommandPoolCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CommandPoolCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CommandPoolCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CommandPoolCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CommandPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "TRANSIENT"), (0x2, "RESET_COMMAND_BUFFER"), (0x4, "PROTECTED")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandPoolResetFlags(u32);
impl CommandPoolResetFlags {
    /// Release resources owned by the pool
    pub const RELEASE_RESOURCES: Self = Self(0x1);
}
impl default::Default for CommandPoolResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CommandPoolResetFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CommandPoolResetFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CommandPoolResetFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CommandPoolResetFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CommandPoolResetFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CommandPoolResetFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CommandPoolResetFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CommandPoolResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RELEASE_RESOURCES")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandBufferResetFlags(u32);
impl CommandBufferResetFlags {
    /// Release resources owned by the buffer
    pub const RELEASE_RESOURCES: Self = Self(0x1);
}
impl default::Default for CommandBufferResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CommandBufferResetFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CommandBufferResetFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CommandBufferResetFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CommandBufferResetFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CommandBufferResetFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CommandBufferResetFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CommandBufferResetFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CommandBufferResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RELEASE_RESOURCES")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandBufferUsageFlags(u32);
impl CommandBufferUsageFlags {
    pub const ONE_TIME_SUBMIT: Self = Self(0x1);
    pub const RENDER_PASS_CONTINUE: Self = Self(0x2);
    /// Command buffer may be submitted/executed more than once simultaneously
    pub const SIMULTANEOUS_USE: Self = Self(0x4);
}
impl default::Default for CommandBufferUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CommandBufferUsageFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CommandBufferUsageFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CommandBufferUsageFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CommandBufferUsageFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CommandBufferUsageFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CommandBufferUsageFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CommandBufferUsageFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CommandBufferUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ONE_TIME_SUBMIT"),
                (0x2, "RENDER_PASS_CONTINUE"),
                (0x4, "SIMULTANEOUS_USE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPipelineStatisticFlags(u32);
impl QueryPipelineStatisticFlags {
    /// Optional
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(0x1);
    /// Optional
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(0x2);
    /// Optional
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(0x4);
    /// Optional
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(0x8);
    /// Optional
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(0x10);
    /// Optional
    pub const CLIPPING_INVOCATIONS: Self = Self(0x20);
    /// Optional
    pub const CLIPPING_PRIMITIVES: Self = Self(0x40);
    /// Optional
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(0x80);
    /// Optional
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(0x100);
    /// Optional
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(0x200);
    /// Optional
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(0x400);
}
impl default::Default for QueryPipelineStatisticFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl QueryPipelineStatisticFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for QueryPipelineStatisticFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for QueryPipelineStatisticFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for QueryPipelineStatisticFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for QueryPipelineStatisticFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for QueryPipelineStatisticFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for QueryPipelineStatisticFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for QueryPipelineStatisticFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INPUT_ASSEMBLY_VERTICES"),
                (0x2, "INPUT_ASSEMBLY_PRIMITIVES"),
                (0x4, "VERTEX_SHADER_INVOCATIONS"),
                (0x8, "GEOMETRY_SHADER_INVOCATIONS"),
                (0x10, "GEOMETRY_SHADER_PRIMITIVES"),
                (0x20, "CLIPPING_INVOCATIONS"),
                (0x40, "CLIPPING_PRIMITIVES"),
                (0x80, "FRAGMENT_SHADER_INVOCATIONS"),
                (0x100, "TESSELLATION_CONTROL_SHADER_PATCHES"),
                (0x200, "TESSELLATION_EVALUATION_SHADER_INVOCATIONS"),
                (0x400, "COMPUTE_SHADER_INVOCATIONS"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryMapFlags(u32);
impl MemoryMapFlags {}
impl default::Default for MemoryMapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl MemoryMapFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MemoryMapFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MemoryMapFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MemoryMapFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MemoryMapFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MemoryMapFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MemoryMapFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MemoryMapFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageAspectFlags(u32);
impl ImageAspectFlags {
    pub const COLOR: Self = Self(0x1);
    pub const DEPTH: Self = Self(0x2);
    pub const STENCIL: Self = Self(0x4);
    pub const METADATA: Self = Self(0x8);
    pub const PLANE_0: Self = Self(0x10);
    pub const PLANE_1: Self = Self(0x20);
    pub const PLANE_2: Self = Self(0x40);
    pub const PLANE_0_KHR: Self = Self::PLANE_0;
    pub const PLANE_1_KHR: Self = Self::PLANE_1;
    pub const PLANE_2_KHR: Self = Self::PLANE_2;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_0_EXT: Self = Self(0x80);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_1_EXT: Self = Self(0x100);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_2_EXT: Self = Self(0x200);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_3_EXT: Self = Self(0x400);
}
impl default::Default for ImageAspectFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageAspectFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageAspectFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageAspectFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageAspectFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageAspectFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageAspectFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageAspectFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageAspectFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "COLOR"),
                (0x2, "DEPTH"),
                (0x4, "STENCIL"),
                (0x8, "METADATA"),
                (0x10, "PLANE_0"),
                (0x20, "PLANE_1"),
                (0x40, "PLANE_2"),
                (0x80, "MEMORY_PLANE_0_EXT"),
                (0x100, "MEMORY_PLANE_1_EXT"),
                (0x200, "MEMORY_PLANE_2_EXT"),
                (0x400, "MEMORY_PLANE_3_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SparseMemoryBindFlags(u32);
impl SparseMemoryBindFlags {
    /// Operation binds resource metadata to memory
    pub const METADATA: Self = Self(0x1);
}
impl default::Default for SparseMemoryBindFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SparseMemoryBindFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SparseMemoryBindFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SparseMemoryBindFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SparseMemoryBindFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SparseMemoryBindFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SparseMemoryBindFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SparseMemoryBindFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SparseMemoryBindFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "METADATA")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SparseImageFormatFlags(u32);
impl SparseImageFormatFlags {
    /// Image uses a single mip tail region for all array layers
    pub const SINGLE_MIPTAIL: Self = Self(0x1);
    /// Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
    pub const ALIGNED_MIP_SIZE: Self = Self(0x2);
    /// Image uses a non-standard sparse image block dimensions
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(0x4);
}
impl default::Default for SparseImageFormatFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SparseImageFormatFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SparseImageFormatFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SparseImageFormatFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SparseImageFormatFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SparseImageFormatFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SparseImageFormatFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SparseImageFormatFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SparseImageFormatFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SINGLE_MIPTAIL"),
                (0x2, "ALIGNED_MIP_SIZE"),
                (0x4, "NONSTANDARD_BLOCK_SIZE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SubpassDescriptionFlags(u32);
impl SubpassDescriptionFlags {
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(0x1);
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(0x2);
    /// Added by extension VK_QCOM_render_pass_shader_resolve.
    pub const FRAGMENT_REGION_QCOM: Self = Self(0x4);
    /// Added by extension VK_QCOM_render_pass_shader_resolve.
    pub const SHADER_RESOLVE_QCOM: Self = Self(0x8);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(0x10);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(0x20);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(0x40);
}
impl default::Default for SubpassDescriptionFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SubpassDescriptionFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SubpassDescriptionFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SubpassDescriptionFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SubpassDescriptionFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SubpassDescriptionFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SubpassDescriptionFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SubpassDescriptionFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SubpassDescriptionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "PER_VIEW_ATTRIBUTES_NVX"),
                (0x2, "PER_VIEW_POSITION_X_ONLY_NVX"),
                (0x4, "FRAGMENT_REGION_QCOM"),
                (0x8, "SHADER_RESOLVE_QCOM"),
                (0x10, "RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM"),
                (0x20, "RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM"),
                (0x40, "RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineStageFlags(u32);
impl PipelineStageFlags {
    /// Before subsequent commands are processed
    pub const TOP_OF_PIPE: Self = Self(0x1);
    /// Draw/DispatchIndirect command fetch
    pub const DRAW_INDIRECT: Self = Self(0x2);
    /// Vertex/index fetch
    pub const VERTEX_INPUT: Self = Self(0x4);
    /// Vertex shading
    pub const VERTEX_SHADER: Self = Self(0x8);
    /// Tessellation control shading
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(0x10);
    /// Tessellation evaluation shading
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(0x20);
    /// Geometry shading
    pub const GEOMETRY_SHADER: Self = Self(0x40);
    /// Fragment shading
    pub const FRAGMENT_SHADER: Self = Self(0x80);
    /// Early fragment (depth and stencil) tests
    pub const EARLY_FRAGMENT_TESTS: Self = Self(0x100);
    /// Late fragment (depth and stencil) tests
    pub const LATE_FRAGMENT_TESTS: Self = Self(0x200);
    /// Color attachment writes
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(0x400);
    /// Compute shading
    pub const COMPUTE_SHADER: Self = Self(0x800);
    /// Transfer/copy operations
    pub const TRANSFER: Self = Self(0x1000);
    /// After previous commands have completed
    pub const BOTTOM_OF_PIPE: Self = Self(0x2000);
    /// Indicates host (CPU) is a source/sink of the dependency
    pub const HOST: Self = Self(0x4000);
    /// All stages of the graphics pipeline
    pub const ALL_GRAPHICS: Self = Self(0x8000);
    /// All stages supported on the queue
    pub const ALL_COMMANDS: Self = Self(0x10000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(0x1000000);
    /// A pipeline stage for conditional rendering predicate fetch
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x40000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(0x2000000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_KHR: Self = Self(0x200000);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    /// Added by extension VK_NV_mesh_shader.
    pub const TASK_SHADER_NV: Self = Self(0x80000);
    /// Added by extension VK_NV_mesh_shader.
    pub const MESH_SHADER_NV: Self = Self(0x100000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(0x800000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x400000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_NV: Self = Self(0x20000);
    /// Added by extension VK_KHR_synchronization2.
    pub const NONE_KHR: Self = Self(0x0);
}
impl default::Default for PipelineStageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineStageFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3ffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3ffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineStageFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineStageFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineStageFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineStageFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineStageFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineStageFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineStageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TOP_OF_PIPE"),
                (0x2, "DRAW_INDIRECT"),
                (0x4, "VERTEX_INPUT"),
                (0x8, "VERTEX_SHADER"),
                (0x10, "TESSELLATION_CONTROL_SHADER"),
                (0x20, "TESSELLATION_EVALUATION_SHADER"),
                (0x40, "GEOMETRY_SHADER"),
                (0x80, "FRAGMENT_SHADER"),
                (0x100, "EARLY_FRAGMENT_TESTS"),
                (0x200, "LATE_FRAGMENT_TESTS"),
                (0x400, "COLOR_ATTACHMENT_OUTPUT"),
                (0x800, "COMPUTE_SHADER"),
                (0x1000, "TRANSFER"),
                (0x2000, "BOTTOM_OF_PIPE"),
                (0x4000, "HOST"),
                (0x8000, "ALL_GRAPHICS"),
                (0x10000, "ALL_COMMANDS"),
                (0x1000000, "TRANSFORM_FEEDBACK_EXT"),
                (0x40000, "CONDITIONAL_RENDERING_EXT"),
                (0x2000000, "ACCELERATION_STRUCTURE_BUILD_KHR"),
                (0x200000, "RAY_TRACING_SHADER_KHR"),
                (0x80000, "TASK_SHADER_NV"),
                (0x100000, "MESH_SHADER_NV"),
                (0x800000, "FRAGMENT_DENSITY_PROCESS_EXT"),
                (0x400000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x20000, "COMMAND_PREPROCESS_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SampleCountFlags(u32);
impl SampleCountFlags {
    /// Sample count 1 supported
    pub const N1: Self = Self(0x1);
    /// Sample count 2 supported
    pub const N2: Self = Self(0x2);
    /// Sample count 4 supported
    pub const N4: Self = Self(0x4);
    /// Sample count 8 supported
    pub const N8: Self = Self(0x8);
    /// Sample count 16 supported
    pub const N16: Self = Self(0x10);
    /// Sample count 32 supported
    pub const N32: Self = Self(0x20);
    /// Sample count 64 supported
    pub const N64: Self = Self(0x40);
}
impl default::Default for SampleCountFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SampleCountFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SampleCountFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SampleCountFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SampleCountFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SampleCountFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SampleCountFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SampleCountFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SampleCountFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "N1"),
                (0x2, "N2"),
                (0x4, "N4"),
                (0x8, "N8"),
                (0x10, "N16"),
                (0x20, "N32"),
                (0x40, "N64"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AttachmentDescriptionFlags(u32);
impl AttachmentDescriptionFlags {
    /// The attachment may alias physical memory of another attachment in the same render pass
    pub const MAY_ALIAS: Self = Self(0x1);
}
impl default::Default for AttachmentDescriptionFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl AttachmentDescriptionFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AttachmentDescriptionFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AttachmentDescriptionFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AttachmentDescriptionFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AttachmentDescriptionFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AttachmentDescriptionFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AttachmentDescriptionFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AttachmentDescriptionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "MAY_ALIAS")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StencilFaceFlags(u32);
impl StencilFaceFlags {
    /// Front face
    pub const FRONT: Self = Self(0x1);
    /// Back face
    pub const BACK: Self = Self(0x2);
    /// Front and back faces
    pub const FRONT_AND_BACK: Self = Self(0x3);
}
impl default::Default for StencilFaceFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl StencilFaceFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for StencilFaceFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for StencilFaceFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for StencilFaceFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for StencilFaceFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for StencilFaceFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for StencilFaceFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for StencilFaceFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "FRONT"), (0x2, "BACK"), (0x3, "FRONT_AND_BACK")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CullModeFlags(u32);
impl CullModeFlags {
    pub const NONE: Self = Self(0x0);
    pub const FRONT: Self = Self(0x1);
    pub const BACK: Self = Self(0x2);
    pub const FRONT_AND_BACK: Self = Self(0x3);
}
impl default::Default for CullModeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CullModeFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CullModeFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CullModeFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CullModeFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CullModeFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CullModeFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CullModeFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CullModeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "FRONT"), (0x2, "BACK"), (0x3, "FRONT_AND_BACK")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorPoolCreateFlags(u32);
impl DescriptorPoolCreateFlags {
    /// Descriptor sets may be freed individually
    pub const FREE_DESCRIPTOR_SET: Self = Self(0x1);
    pub const UPDATE_AFTER_BIND: Self = Self(0x2);
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const HOST_ONLY_VALVE: Self = Self(0x4);
}
impl default::Default for DescriptorPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DescriptorPoolCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DescriptorPoolCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DescriptorPoolCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DescriptorPoolCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DescriptorPoolCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DescriptorPoolCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DescriptorPoolCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DescriptorPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "FREE_DESCRIPTOR_SET"),
                (0x2, "UPDATE_AFTER_BIND"),
                (0x4, "HOST_ONLY_VALVE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorPoolResetFlags(u32);
impl DescriptorPoolResetFlags {}
impl default::Default for DescriptorPoolResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DescriptorPoolResetFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DescriptorPoolResetFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DescriptorPoolResetFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DescriptorPoolResetFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DescriptorPoolResetFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DescriptorPoolResetFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DescriptorPoolResetFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DescriptorPoolResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DependencyFlags(u32);
impl DependencyFlags {
    /// Dependency is per pixel region
    pub const BY_REGION: Self = Self(0x1);
    /// Dependency is across devices
    pub const DEVICE_GROUP: Self = Self(0x4);
    pub const VIEW_LOCAL: Self = Self(0x2);
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
}
impl default::Default for DependencyFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DependencyFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DependencyFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DependencyFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DependencyFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DependencyFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DependencyFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DependencyFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DependencyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "BY_REGION"), (0x4, "DEVICE_GROUP"), (0x2, "VIEW_LOCAL")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SubgroupFeatureFlags(u32);
impl SubgroupFeatureFlags {
    /// Basic subgroup operations
    pub const BASIC: Self = Self(0x1);
    /// Vote subgroup operations
    pub const VOTE: Self = Self(0x2);
    /// Arithmetic subgroup operations
    pub const ARITHMETIC: Self = Self(0x4);
    /// Ballot subgroup operations
    pub const BALLOT: Self = Self(0x8);
    /// Shuffle subgroup operations
    pub const SHUFFLE: Self = Self(0x10);
    /// Shuffle relative subgroup operations
    pub const SHUFFLE_RELATIVE: Self = Self(0x20);
    /// Clustered subgroup operations
    pub const CLUSTERED: Self = Self(0x40);
    /// Quad subgroup operations
    pub const QUAD: Self = Self(0x80);
    /// Added by extension VK_NV_shader_subgroup_partitioned.
    pub const PARTITIONED_NV: Self = Self(0x100);
}
impl default::Default for SubgroupFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SubgroupFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SubgroupFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SubgroupFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SubgroupFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SubgroupFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SubgroupFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SubgroupFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SubgroupFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "BASIC"),
                (0x2, "VOTE"),
                (0x4, "ARITHMETIC"),
                (0x8, "BALLOT"),
                (0x10, "SHUFFLE"),
                (0x20, "SHUFFLE_RELATIVE"),
                (0x40, "CLUSTERED"),
                (0x80, "QUAD"),
                (0x100, "PARTITIONED_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct IndirectCommandsLayoutUsageFlagsNV(u32);
impl IndirectCommandsLayoutUsageFlagsNV {
    pub const EXPLICIT_PREPROCESS: Self = Self(0x1);
    pub const INDEXED_SEQUENCES: Self = Self(0x2);
    pub const UNORDERED_SEQUENCES: Self = Self(0x4);
}
impl default::Default for IndirectCommandsLayoutUsageFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl IndirectCommandsLayoutUsageFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for IndirectCommandsLayoutUsageFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for IndirectCommandsLayoutUsageFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for IndirectCommandsLayoutUsageFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for IndirectCommandsLayoutUsageFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for IndirectCommandsLayoutUsageFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for IndirectCommandsLayoutUsageFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for IndirectCommandsLayoutUsageFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "EXPLICIT_PREPROCESS"),
                (0x2, "INDEXED_SEQUENCES"),
                (0x4, "UNORDERED_SEQUENCES"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct IndirectStateFlagsNV(u32);
impl IndirectStateFlagsNV {
    pub const FRONTFACE: Self = Self(0x1);
}
impl default::Default for IndirectStateFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl IndirectStateFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for IndirectStateFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for IndirectStateFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for IndirectStateFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for IndirectStateFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for IndirectStateFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for IndirectStateFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for IndirectStateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "FRONTFACE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct GeometryFlagsKHR(u32);
impl GeometryFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const NO_DUPLICATE_ANY_HIT_INVOCATION: Self = Self(0x2);
    pub const OPAQUE_NV: Self = Self::OPAQUE;
    pub const NO_DUPLICATE_ANY_HIT_INVOCATION_NV: Self = Self::NO_DUPLICATE_ANY_HIT_INVOCATION;
}
impl default::Default for GeometryFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl GeometryFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for GeometryFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for GeometryFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for GeometryFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for GeometryFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for GeometryFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for GeometryFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for GeometryFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "OPAQUE"), (0x2, "NO_DUPLICATE_ANY_HIT_INVOCATION")],
            f,
        )
    }
}
pub type GeometryFlagsNV = GeometryFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct GeometryInstanceFlagsKHR(u32);
impl GeometryInstanceFlagsKHR {
    pub const TRIANGLE_FACING_CULL_DISABLE: Self = Self(0x1);
    pub const TRIANGLE_FLIP_FACING: Self = Self(0x2);
    pub const FORCE_OPAQUE: Self = Self(0x4);
    pub const FORCE_NO_OPAQUE: Self = Self(0x8);
    pub const TRIANGLE_FRONT_COUNTERCLOCKWISE: Self = Self::TRIANGLE_FLIP_FACING;
    pub const TRIANGLE_CULL_DISABLE_NV: Self = Self::TRIANGLE_FACING_CULL_DISABLE;
    pub const TRIANGLE_FRONT_COUNTERCLOCKWISE_NV: Self = Self::TRIANGLE_FRONT_COUNTERCLOCKWISE;
    pub const FORCE_OPAQUE_NV: Self = Self::FORCE_OPAQUE;
    pub const FORCE_NO_OPAQUE_NV: Self = Self::FORCE_NO_OPAQUE;
}
impl default::Default for GeometryInstanceFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl GeometryInstanceFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for GeometryInstanceFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for GeometryInstanceFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for GeometryInstanceFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for GeometryInstanceFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for GeometryInstanceFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for GeometryInstanceFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for GeometryInstanceFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRIANGLE_FACING_CULL_DISABLE"),
                (0x2, "TRIANGLE_FLIP_FACING"),
                (0x4, "FORCE_OPAQUE"),
                (0x8, "FORCE_NO_OPAQUE"),
            ],
            f,
        )
    }
}
pub type GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BuildAccelerationStructureFlagsKHR(u32);
impl BuildAccelerationStructureFlagsKHR {
    pub const ALLOW_UPDATE: Self = Self(0x1);
    pub const ALLOW_COMPACTION: Self = Self(0x2);
    pub const PREFER_FAST_TRACE: Self = Self(0x4);
    pub const PREFER_FAST_BUILD: Self = Self(0x8);
    pub const LOW_MEMORY: Self = Self(0x10);
    pub const ALLOW_UPDATE_NV: Self = Self::ALLOW_UPDATE;
    pub const ALLOW_COMPACTION_NV: Self = Self::ALLOW_COMPACTION;
    pub const PREFER_FAST_TRACE_NV: Self = Self::PREFER_FAST_TRACE;
    pub const PREFER_FAST_BUILD_NV: Self = Self::PREFER_FAST_BUILD;
    pub const LOW_MEMORY_NV: Self = Self::LOW_MEMORY;
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const MOTION_NV: Self = Self(0x20);
}
impl default::Default for BuildAccelerationStructureFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl BuildAccelerationStructureFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for BuildAccelerationStructureFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for BuildAccelerationStructureFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for BuildAccelerationStructureFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for BuildAccelerationStructureFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for BuildAccelerationStructureFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for BuildAccelerationStructureFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for BuildAccelerationStructureFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ALLOW_UPDATE"),
                (0x2, "ALLOW_COMPACTION"),
                (0x4, "PREFER_FAST_TRACE"),
                (0x8, "PREFER_FAST_BUILD"),
                (0x10, "LOW_MEMORY"),
                (0x20, "MOTION_NV"),
            ],
            f,
        )
    }
}
pub type BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PrivateDataSlotCreateFlagsEXT(u32);
impl PrivateDataSlotCreateFlagsEXT {}
impl default::Default for PrivateDataSlotCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PrivateDataSlotCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PrivateDataSlotCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PrivateDataSlotCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PrivateDataSlotCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PrivateDataSlotCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PrivateDataSlotCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PrivateDataSlotCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PrivateDataSlotCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureCreateFlagsKHR(u32);
impl AccelerationStructureCreateFlagsKHR {
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x1);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const MOTION_NV: Self = Self(0x4);
}
impl default::Default for AccelerationStructureCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl AccelerationStructureCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x5)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x5
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AccelerationStructureCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AccelerationStructureCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AccelerationStructureCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AccelerationStructureCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AccelerationStructureCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AccelerationStructureCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AccelerationStructureCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEVICE_ADDRESS_CAPTURE_REPLAY"), (0x4, "MOTION_NV")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateCreateFlags(u32);
impl DescriptorUpdateTemplateCreateFlags {}
impl default::Default for DescriptorUpdateTemplateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DescriptorUpdateTemplateCreateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DescriptorUpdateTemplateCreateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DescriptorUpdateTemplateCreateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DescriptorUpdateTemplateCreateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DescriptorUpdateTemplateCreateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DescriptorUpdateTemplateCreateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DescriptorUpdateTemplateCreateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DescriptorUpdateTemplateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
pub type DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCreationFeedbackFlagsEXT(u32);
impl PipelineCreationFeedbackFlagsEXT {
    pub const VALID: Self = Self(0x1);
    pub const APPLICATION_PIPELINE_CACHE_HIT: Self = Self(0x2);
    pub const BASE_PIPELINE_ACCELERATION: Self = Self(0x4);
}
impl default::Default for PipelineCreationFeedbackFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCreationFeedbackFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCreationFeedbackFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCreationFeedbackFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCreationFeedbackFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCreationFeedbackFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCreationFeedbackFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCreationFeedbackFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCreationFeedbackFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VALID"),
                (0x2, "APPLICATION_PIPELINE_CACHE_HIT"),
                (0x4, "BASE_PIPELINE_ACCELERATION"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PerformanceCounterDescriptionFlagsKHR(u32);
impl PerformanceCounterDescriptionFlagsKHR {
    pub const PERFORMANCE_IMPACTING: Self = Self(0x1);
    pub const CONCURRENTLY_IMPACTED: Self = Self(0x2);
}
impl default::Default for PerformanceCounterDescriptionFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl PerformanceCounterDescriptionFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PerformanceCounterDescriptionFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PerformanceCounterDescriptionFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PerformanceCounterDescriptionFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PerformanceCounterDescriptionFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PerformanceCounterDescriptionFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PerformanceCounterDescriptionFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PerformanceCounterDescriptionFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "PERFORMANCE_IMPACTING"), (0x2, "CONCURRENTLY_IMPACTED")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AcquireProfilingLockFlagsKHR(u32);
impl AcquireProfilingLockFlagsKHR {}
impl default::Default for AcquireProfilingLockFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl AcquireProfilingLockFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AcquireProfilingLockFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AcquireProfilingLockFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AcquireProfilingLockFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AcquireProfilingLockFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AcquireProfilingLockFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AcquireProfilingLockFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AcquireProfilingLockFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SemaphoreWaitFlags(u32);
impl SemaphoreWaitFlags {
    pub const ANY: Self = Self(0x1);
    pub const ANY_KHR: Self = Self::ANY;
}
impl default::Default for SemaphoreWaitFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SemaphoreWaitFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SemaphoreWaitFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SemaphoreWaitFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SemaphoreWaitFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SemaphoreWaitFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SemaphoreWaitFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SemaphoreWaitFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SemaphoreWaitFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "ANY")], f)
    }
}
pub type SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCompilerControlFlagsAMD(u32);
impl PipelineCompilerControlFlagsAMD {}
impl default::Default for PipelineCompilerControlFlagsAMD {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCompilerControlFlagsAMD {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCompilerControlFlagsAMD {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCompilerControlFlagsAMD {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCompilerControlFlagsAMD {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCompilerControlFlagsAMD {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCompilerControlFlagsAMD {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCompilerControlFlagsAMD {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCompilerControlFlagsAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderCorePropertiesFlagsAMD(u32);
impl ShaderCorePropertiesFlagsAMD {}
impl default::Default for ShaderCorePropertiesFlagsAMD {
    fn default() -> Self {
        Self(0)
    }
}
impl ShaderCorePropertiesFlagsAMD {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ShaderCorePropertiesFlagsAMD {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ShaderCorePropertiesFlagsAMD {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ShaderCorePropertiesFlagsAMD {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ShaderCorePropertiesFlagsAMD {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ShaderCorePropertiesFlagsAMD {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ShaderCorePropertiesFlagsAMD {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ShaderCorePropertiesFlagsAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceDiagnosticsConfigFlagsNV(u32);
impl DeviceDiagnosticsConfigFlagsNV {
    pub const ENABLE_SHADER_DEBUG_INFO: Self = Self(0x1);
    pub const ENABLE_RESOURCE_TRACKING: Self = Self(0x2);
    pub const ENABLE_AUTOMATIC_CHECKPOINTS: Self = Self(0x4);
}
impl default::Default for DeviceDiagnosticsConfigFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl DeviceDiagnosticsConfigFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DeviceDiagnosticsConfigFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DeviceDiagnosticsConfigFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DeviceDiagnosticsConfigFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DeviceDiagnosticsConfigFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DeviceDiagnosticsConfigFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DeviceDiagnosticsConfigFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DeviceDiagnosticsConfigFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ENABLE_SHADER_DEBUG_INFO"),
                (0x2, "ENABLE_RESOURCE_TRACKING"),
                (0x4, "ENABLE_AUTOMATIC_CHECKPOINTS"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccessFlags2KHR(u64);
impl AccessFlags2KHR {
    pub const NONE: Self = Self(0x0);
    pub const INDIRECT_COMMAND_READ: Self = Self(0x1);
    pub const INDEX_READ: Self = Self(0x2);
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(0x4);
    pub const UNIFORM_READ: Self = Self(0x8);
    pub const INPUT_ATTACHMENT_READ: Self = Self(0x10);
    pub const SHADER_READ: Self = Self(0x20);
    pub const SHADER_WRITE: Self = Self(0x40);
    pub const COLOR_ATTACHMENT_READ: Self = Self(0x80);
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(0x100);
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(0x200);
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(0x400);
    pub const TRANSFER_READ: Self = Self(0x800);
    pub const TRANSFER_WRITE: Self = Self(0x1000);
    pub const HOST_READ: Self = Self(0x2000);
    pub const HOST_WRITE: Self = Self(0x4000);
    pub const MEMORY_READ: Self = Self(0x8000);
    pub const MEMORY_WRITE: Self = Self(0x10000);
    pub const SHADER_SAMPLED_READ: Self = Self(0x100000000);
    pub const SHADER_STORAGE_READ: Self = Self(0x200000000);
    pub const SHADER_STORAGE_WRITE: Self = Self(0x400000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(0x2000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(0x4000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(0x8000000);
    /// read access flag for reading conditional rendering predicate
    /// Added by extension VK_KHR_synchronization2.
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(0x100000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(0x20000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(0x40000);
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ: Self = Self(0x800000);
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ;
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_READ: Self = Self(0x200000);
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_WRITE: Self = Self(0x400000);
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ;
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE;
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(0x80000);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_READ_HUAWEI: Self = Self(0x8000000000);
}
impl default::Default for AccessFlags2KHR {
    fn default() -> Self {
        Self(0)
    }
}
impl AccessFlags2KHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x870fffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x870fffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AccessFlags2KHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AccessFlags2KHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AccessFlags2KHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AccessFlags2KHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AccessFlags2KHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AccessFlags2KHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AccessFlags2KHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INDIRECT_COMMAND_READ"),
                (0x2, "INDEX_READ"),
                (0x4, "VERTEX_ATTRIBUTE_READ"),
                (0x8, "UNIFORM_READ"),
                (0x10, "INPUT_ATTACHMENT_READ"),
                (0x20, "SHADER_READ"),
                (0x40, "SHADER_WRITE"),
                (0x80, "COLOR_ATTACHMENT_READ"),
                (0x100, "COLOR_ATTACHMENT_WRITE"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT_READ"),
                (0x400, "DEPTH_STENCIL_ATTACHMENT_WRITE"),
                (0x800, "TRANSFER_READ"),
                (0x1000, "TRANSFER_WRITE"),
                (0x2000, "HOST_READ"),
                (0x4000, "HOST_WRITE"),
                (0x8000, "MEMORY_READ"),
                (0x10000, "MEMORY_WRITE"),
                (0x100000000, "SHADER_SAMPLED_READ"),
                (0x200000000, "SHADER_STORAGE_READ"),
                (0x400000000, "SHADER_STORAGE_WRITE"),
                (0x2000000, "TRANSFORM_FEEDBACK_WRITE_EXT"),
                (0x4000000, "TRANSFORM_FEEDBACK_COUNTER_READ_EXT"),
                (0x8000000, "TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT"),
                (0x100000, "CONDITIONAL_RENDERING_READ_EXT"),
                (0x20000, "COMMAND_PREPROCESS_READ_NV"),
                (0x40000, "COMMAND_PREPROCESS_WRITE_NV"),
                (0x800000, "FRAGMENT_SHADING_RATE_ATTACHMENT_READ"),
                (0x200000, "ACCELERATION_STRUCTURE_READ"),
                (0x400000, "ACCELERATION_STRUCTURE_WRITE"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_READ_EXT"),
                (0x80000, "COLOR_ATTACHMENT_READ_NONCOHERENT_EXT"),
                (0x8000000000, "INVOCATION_MASK_READ_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineStageFlags2KHR(u64);
impl PipelineStageFlags2KHR {
    pub const NONE: Self = Self(0x0);
    pub const TOP_OF_PIPE: Self = Self(0x1);
    pub const DRAW_INDIRECT: Self = Self(0x2);
    pub const VERTEX_INPUT: Self = Self(0x4);
    pub const VERTEX_SHADER: Self = Self(0x8);
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(0x10);
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(0x20);
    pub const GEOMETRY_SHADER: Self = Self(0x40);
    pub const FRAGMENT_SHADER: Self = Self(0x80);
    pub const EARLY_FRAGMENT_TESTS: Self = Self(0x100);
    pub const LATE_FRAGMENT_TESTS: Self = Self(0x200);
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(0x400);
    pub const COMPUTE_SHADER: Self = Self(0x800);
    pub const ALL_TRANSFER: Self = Self(0x1000);
    pub const TRANSFER: Self = Self::ALL_TRANSFER;
    pub const BOTTOM_OF_PIPE: Self = Self(0x2000);
    pub const HOST: Self = Self(0x4000);
    pub const ALL_GRAPHICS: Self = Self(0x8000);
    pub const ALL_COMMANDS: Self = Self(0x10000);
    pub const COPY: Self = Self(0x100000000);
    pub const RESOLVE: Self = Self(0x200000000);
    pub const BLIT: Self = Self(0x400000000);
    pub const CLEAR: Self = Self(0x800000000);
    pub const INDEX_INPUT: Self = Self(0x1000000000);
    pub const VERTEX_ATTRIBUTE_INPUT: Self = Self(0x2000000000);
    pub const PRE_RASTERIZATION_SHADERS: Self = Self(0x4000000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(0x1000000);
    /// A pipeline stage for conditional rendering predicate fetch
    /// Added by extension VK_KHR_synchronization2.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x40000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_NV: Self = Self(0x20000);
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT: Self = Self(0x400000);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT;
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_BUILD: Self = Self(0x2000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const RAY_TRACING_SHADER: Self = Self(0x200000);
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER;
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD;
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(0x800000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TASK_SHADER_NV: Self = Self(0x80000);
    /// Added by extension VK_KHR_synchronization2.
    pub const MESH_SHADER_NV: Self = Self(0x100000);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(0x8000000000);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_HUAWEI: Self = Self(0x10000000000);
}
impl default::Default for PipelineStageFlags2KHR {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineStageFlags2KHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1ff03ffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1ff03ffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineStageFlags2KHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineStageFlags2KHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineStageFlags2KHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineStageFlags2KHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineStageFlags2KHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineStageFlags2KHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineStageFlags2KHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TOP_OF_PIPE"),
                (0x2, "DRAW_INDIRECT"),
                (0x4, "VERTEX_INPUT"),
                (0x8, "VERTEX_SHADER"),
                (0x10, "TESSELLATION_CONTROL_SHADER"),
                (0x20, "TESSELLATION_EVALUATION_SHADER"),
                (0x40, "GEOMETRY_SHADER"),
                (0x80, "FRAGMENT_SHADER"),
                (0x100, "EARLY_FRAGMENT_TESTS"),
                (0x200, "LATE_FRAGMENT_TESTS"),
                (0x400, "COLOR_ATTACHMENT_OUTPUT"),
                (0x800, "COMPUTE_SHADER"),
                (0x1000, "ALL_TRANSFER"),
                (0x2000, "BOTTOM_OF_PIPE"),
                (0x4000, "HOST"),
                (0x8000, "ALL_GRAPHICS"),
                (0x10000, "ALL_COMMANDS"),
                (0x100000000, "COPY"),
                (0x200000000, "RESOLVE"),
                (0x400000000, "BLIT"),
                (0x800000000, "CLEAR"),
                (0x1000000000, "INDEX_INPUT"),
                (0x2000000000, "VERTEX_ATTRIBUTE_INPUT"),
                (0x4000000000, "PRE_RASTERIZATION_SHADERS"),
                (0x1000000, "TRANSFORM_FEEDBACK_EXT"),
                (0x40000, "CONDITIONAL_RENDERING_EXT"),
                (0x20000, "COMMAND_PREPROCESS_NV"),
                (0x400000, "FRAGMENT_SHADING_RATE_ATTACHMENT"),
                (0x2000000, "ACCELERATION_STRUCTURE_BUILD"),
                (0x200000, "RAY_TRACING_SHADER"),
                (0x800000, "FRAGMENT_DENSITY_PROCESS_EXT"),
                (0x80000, "TASK_SHADER_NV"),
                (0x100000, "MESH_SHADER_NV"),
                (0x8000000000, "SUBPASS_SHADING_HUAWEI"),
                (0x10000000000, "INVOCATION_MASK_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInfoFlagsNV(u32);
impl AccelerationStructureMotionInfoFlagsNV {}
impl default::Default for AccelerationStructureMotionInfoFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl AccelerationStructureMotionInfoFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AccelerationStructureMotionInfoFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AccelerationStructureMotionInfoFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AccelerationStructureMotionInfoFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AccelerationStructureMotionInfoFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AccelerationStructureMotionInfoFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AccelerationStructureMotionInfoFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AccelerationStructureMotionInfoFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInstanceFlagsNV(u32);
impl AccelerationStructureMotionInstanceFlagsNV {}
impl default::Default for AccelerationStructureMotionInstanceFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl AccelerationStructureMotionInstanceFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AccelerationStructureMotionInstanceFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AccelerationStructureMotionInstanceFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AccelerationStructureMotionInstanceFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AccelerationStructureMotionInstanceFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AccelerationStructureMotionInstanceFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AccelerationStructureMotionInstanceFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AccelerationStructureMotionInstanceFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FormatFeatureFlags2KHR(u64);
impl FormatFeatureFlags2KHR {
    pub const SAMPLED_IMAGE: Self = Self(0x1);
    pub const STORAGE_IMAGE: Self = Self(0x2);
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(0x4);
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x8);
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x10);
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(0x20);
    pub const VERTEX_BUFFER: Self = Self(0x40);
    pub const COLOR_ATTACHMENT: Self = Self(0x80);
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(0x100);
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x200);
    pub const BLIT_SRC: Self = Self(0x400);
    pub const BLIT_DST: Self = Self(0x800);
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(0x1000);
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self(0x2000);
    pub const TRANSFER_SRC: Self = Self(0x4000);
    pub const TRANSFER_DST: Self = Self(0x8000);
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(0x10000);
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(0x20000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(0x40000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(0x80000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(0x100000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(0x200000);
    pub const DISJOINT: Self = Self(0x400000);
    pub const COSITED_CHROMA_SAMPLES: Self = Self(0x800000);
    pub const STORAGE_READ_WITHOUT_FORMAT: Self = Self(0x80000000);
    pub const STORAGE_WRITE_WITHOUT_FORMAT: Self = Self(0x100000000);
    pub const SAMPLED_IMAGE_DEPTH_COMPARISON: Self = Self(0x200000000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER: Self = Self(0x20000000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT: Self = Self(0x40000000);
}
impl default::Default for FormatFeatureFlags2KHR {
    fn default() -> Self {
        Self(0)
    }
}
impl FormatFeatureFlags2KHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3e1ffffff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3e1ffffff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for FormatFeatureFlags2KHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for FormatFeatureFlags2KHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for FormatFeatureFlags2KHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for FormatFeatureFlags2KHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for FormatFeatureFlags2KHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for FormatFeatureFlags2KHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for FormatFeatureFlags2KHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SAMPLED_IMAGE"),
                (0x2, "STORAGE_IMAGE"),
                (0x4, "STORAGE_IMAGE_ATOMIC"),
                (0x8, "UNIFORM_TEXEL_BUFFER"),
                (0x10, "STORAGE_TEXEL_BUFFER"),
                (0x20, "STORAGE_TEXEL_BUFFER_ATOMIC"),
                (0x40, "VERTEX_BUFFER"),
                (0x80, "COLOR_ATTACHMENT"),
                (0x100, "COLOR_ATTACHMENT_BLEND"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT"),
                (0x400, "BLIT_SRC"),
                (0x800, "BLIT_DST"),
                (0x1000, "SAMPLED_IMAGE_FILTER_LINEAR"),
                (0x2000, "SAMPLED_IMAGE_FILTER_CUBIC_EXT"),
                (0x4000, "TRANSFER_SRC"),
                (0x8000, "TRANSFER_DST"),
                (0x10000, "SAMPLED_IMAGE_FILTER_MINMAX"),
                (0x20000, "MIDPOINT_CHROMA_SAMPLES"),
                (0x40000, "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER"),
                (0x80000, "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER"),
                (
                    0x100000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT",
                ),
                (
                    0x200000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE",
                ),
                (0x400000, "DISJOINT"),
                (0x800000, "COSITED_CHROMA_SAMPLES"),
                (0x80000000, "STORAGE_READ_WITHOUT_FORMAT"),
                (0x100000000, "STORAGE_WRITE_WITHOUT_FORMAT"),
                (0x200000000, "SAMPLED_IMAGE_DEPTH_COMPARISON"),
                (0x20000000, "ACCELERATION_STRUCTURE_VERTEX_BUFFER"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x40000000, "FRAGMENT_SHADING_RATE_ATTACHMENT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct RenderingFlagsKHR(u32);
impl RenderingFlagsKHR {
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS: Self = Self(0x1);
    pub const SUSPENDING: Self = Self(0x2);
    pub const RESUMING: Self = Self(0x4);
}
impl default::Default for RenderingFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl RenderingFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for RenderingFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for RenderingFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for RenderingFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for RenderingFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for RenderingFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for RenderingFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for RenderingFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "CONTENTS_SECONDARY_COMMAND_BUFFERS"),
                (0x2, "SUSPENDING"),
                (0x4, "RESUMING"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CompositeAlphaFlagsKHR(u32);
impl CompositeAlphaFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const PRE_MULTIPLIED: Self = Self(0x2);
    pub const POST_MULTIPLIED: Self = Self(0x4);
    pub const INHERIT: Self = Self(0x8);
}
impl default::Default for CompositeAlphaFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl CompositeAlphaFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CompositeAlphaFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CompositeAlphaFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CompositeAlphaFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CompositeAlphaFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CompositeAlphaFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CompositeAlphaFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CompositeAlphaFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE"),
                (0x2, "PRE_MULTIPLIED"),
                (0x4, "POST_MULTIPLIED"),
                (0x8, "INHERIT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayPlaneAlphaFlagsKHR(u32);
impl DisplayPlaneAlphaFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const GLOBAL: Self = Self(0x2);
    pub const PER_PIXEL: Self = Self(0x4);
    pub const PER_PIXEL_PREMULTIPLIED: Self = Self(0x8);
}
impl default::Default for DisplayPlaneAlphaFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl DisplayPlaneAlphaFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DisplayPlaneAlphaFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DisplayPlaneAlphaFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DisplayPlaneAlphaFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DisplayPlaneAlphaFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DisplayPlaneAlphaFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DisplayPlaneAlphaFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DisplayPlaneAlphaFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE"),
                (0x2, "GLOBAL"),
                (0x4, "PER_PIXEL"),
                (0x8, "PER_PIXEL_PREMULTIPLIED"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceTransformFlagsKHR(u32);
impl SurfaceTransformFlagsKHR {
    pub const IDENTITY: Self = Self(0x1);
    pub const ROTATE_90: Self = Self(0x2);
    pub const ROTATE_180: Self = Self(0x4);
    pub const ROTATE_270: Self = Self(0x8);
    pub const HORIZONTAL_MIRROR: Self = Self(0x10);
    pub const HORIZONTAL_MIRROR_ROTATE_90: Self = Self(0x20);
    pub const HORIZONTAL_MIRROR_ROTATE_180: Self = Self(0x40);
    pub const HORIZONTAL_MIRROR_ROTATE_270: Self = Self(0x80);
    pub const INHERIT: Self = Self(0x100);
}
impl default::Default for SurfaceTransformFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl SurfaceTransformFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1ff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1ff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SurfaceTransformFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SurfaceTransformFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SurfaceTransformFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SurfaceTransformFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SurfaceTransformFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SurfaceTransformFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SurfaceTransformFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "IDENTITY"),
                (0x2, "ROTATE_90"),
                (0x4, "ROTATE_180"),
                (0x8, "ROTATE_270"),
                (0x10, "HORIZONTAL_MIRROR"),
                (0x20, "HORIZONTAL_MIRROR_ROTATE_90"),
                (0x40, "HORIZONTAL_MIRROR_ROTATE_180"),
                (0x80, "HORIZONTAL_MIRROR_ROTATE_270"),
                (0x100, "INHERIT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SwapchainCreateFlagsKHR(u32);
impl SwapchainCreateFlagsKHR {
    /// Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
    /// Added by extension VK_KHR_device_group.
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(0x1);
    /// Swapchain is protected
    /// Added by extension VK_KHR_swapchain.
    pub const PROTECTED: Self = Self(0x2);
    /// Added by extension VK_KHR_swapchain_mutable_format.
    pub const MUTABLE_FORMAT: Self = Self(0x4);
}
impl default::Default for SwapchainCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl SwapchainCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SwapchainCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SwapchainCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SwapchainCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SwapchainCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SwapchainCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SwapchainCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SwapchainCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPLIT_INSTANCE_BIND_REGIONS"),
                (0x2, "PROTECTED"),
                (0x4, "MUTABLE_FORMAT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayModeCreateFlagsKHR(u32);
impl DisplayModeCreateFlagsKHR {}
impl default::Default for DisplayModeCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl DisplayModeCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DisplayModeCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DisplayModeCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DisplayModeCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DisplayModeCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DisplayModeCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DisplayModeCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DisplayModeCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplaySurfaceCreateFlagsKHR(u32);
impl DisplaySurfaceCreateFlagsKHR {}
impl default::Default for DisplaySurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl DisplaySurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DisplaySurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DisplaySurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DisplaySurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DisplaySurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DisplaySurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DisplaySurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DisplaySurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AndroidSurfaceCreateFlagsKHR(u32);
impl AndroidSurfaceCreateFlagsKHR {}
impl default::Default for AndroidSurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl AndroidSurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for AndroidSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for AndroidSurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for AndroidSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for AndroidSurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for AndroidSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for AndroidSurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for AndroidSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ViSurfaceCreateFlagsNN(u32);
impl ViSurfaceCreateFlagsNN {}
impl default::Default for ViSurfaceCreateFlagsNN {
    fn default() -> Self {
        Self(0)
    }
}
impl ViSurfaceCreateFlagsNN {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ViSurfaceCreateFlagsNN {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ViSurfaceCreateFlagsNN {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ViSurfaceCreateFlagsNN {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ViSurfaceCreateFlagsNN {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ViSurfaceCreateFlagsNN {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ViSurfaceCreateFlagsNN {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ViSurfaceCreateFlagsNN {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct WaylandSurfaceCreateFlagsKHR(u32);
impl WaylandSurfaceCreateFlagsKHR {}
impl default::Default for WaylandSurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl WaylandSurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for WaylandSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for WaylandSurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for WaylandSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for WaylandSurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for WaylandSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for WaylandSurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for WaylandSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Win32SurfaceCreateFlagsKHR(u32);
impl Win32SurfaceCreateFlagsKHR {}
impl default::Default for Win32SurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl Win32SurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for Win32SurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for Win32SurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for Win32SurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for Win32SurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for Win32SurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for Win32SurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for Win32SurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct XlibSurfaceCreateFlagsKHR(u32);
impl XlibSurfaceCreateFlagsKHR {}
impl default::Default for XlibSurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl XlibSurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for XlibSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for XlibSurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for XlibSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for XlibSurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for XlibSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for XlibSurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for XlibSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct XcbSurfaceCreateFlagsKHR(u32);
impl XcbSurfaceCreateFlagsKHR {}
impl default::Default for XcbSurfaceCreateFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl XcbSurfaceCreateFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for XcbSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for XcbSurfaceCreateFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for XcbSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for XcbSurfaceCreateFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for XcbSurfaceCreateFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for XcbSurfaceCreateFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for XcbSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DirectFBSurfaceCreateFlagsEXT(u32);
impl DirectFBSurfaceCreateFlagsEXT {}
impl default::Default for DirectFBSurfaceCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DirectFBSurfaceCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DirectFBSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DirectFBSurfaceCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DirectFBSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DirectFBSurfaceCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DirectFBSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DirectFBSurfaceCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DirectFBSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct IOSSurfaceCreateFlagsMVK(u32);
impl IOSSurfaceCreateFlagsMVK {}
impl default::Default for IOSSurfaceCreateFlagsMVK {
    fn default() -> Self {
        Self(0)
    }
}
impl IOSSurfaceCreateFlagsMVK {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for IOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for IOSSurfaceCreateFlagsMVK {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for IOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for IOSSurfaceCreateFlagsMVK {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for IOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for IOSSurfaceCreateFlagsMVK {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for IOSSurfaceCreateFlagsMVK {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MacOSSurfaceCreateFlagsMVK(u32);
impl MacOSSurfaceCreateFlagsMVK {}
impl default::Default for MacOSSurfaceCreateFlagsMVK {
    fn default() -> Self {
        Self(0)
    }
}
impl MacOSSurfaceCreateFlagsMVK {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MacOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MacOSSurfaceCreateFlagsMVK {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MacOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MacOSSurfaceCreateFlagsMVK {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MacOSSurfaceCreateFlagsMVK {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MacOSSurfaceCreateFlagsMVK {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MacOSSurfaceCreateFlagsMVK {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MetalSurfaceCreateFlagsEXT(u32);
impl MetalSurfaceCreateFlagsEXT {}
impl default::Default for MetalSurfaceCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl MetalSurfaceCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MetalSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MetalSurfaceCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MetalSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MetalSurfaceCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MetalSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MetalSurfaceCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MetalSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImagePipeSurfaceCreateFlagsFUCHSIA(u32);
impl ImagePipeSurfaceCreateFlagsFUCHSIA {}
impl default::Default for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn default() -> Self {
        Self(0)
    }
}
impl ImagePipeSurfaceCreateFlagsFUCHSIA {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImagePipeSurfaceCreateFlagsFUCHSIA {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImagePipeSurfaceCreateFlagsFUCHSIA {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImagePipeSurfaceCreateFlagsFUCHSIA {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HeadlessSurfaceCreateFlagsEXT(u32);
impl HeadlessSurfaceCreateFlagsEXT {}
impl default::Default for HeadlessSurfaceCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl HeadlessSurfaceCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for HeadlessSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for HeadlessSurfaceCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for HeadlessSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for HeadlessSurfaceCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for HeadlessSurfaceCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for HeadlessSurfaceCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for HeadlessSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PeerMemoryFeatureFlags(u32);
impl PeerMemoryFeatureFlags {
    /// Can read with vkCmdCopy commands
    pub const COPY_SRC: Self = Self(0x1);
    /// Can write with vkCmdCopy commands
    pub const COPY_DST: Self = Self(0x2);
    /// Can read with any access type/command
    pub const GENERIC_SRC: Self = Self(0x4);
    /// Can write with and access type/command
    pub const GENERIC_DST: Self = Self(0x8);
    pub const COPY_SRC_KHR: Self = Self::COPY_SRC;
    pub const COPY_DST_KHR: Self = Self::COPY_DST;
    pub const GENERIC_SRC_KHR: Self = Self::GENERIC_SRC;
    pub const GENERIC_DST_KHR: Self = Self::GENERIC_DST;
}
impl default::Default for PeerMemoryFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl PeerMemoryFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PeerMemoryFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PeerMemoryFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PeerMemoryFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PeerMemoryFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PeerMemoryFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PeerMemoryFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PeerMemoryFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "COPY_SRC"),
                (0x2, "COPY_DST"),
                (0x4, "GENERIC_SRC"),
                (0x8, "GENERIC_DST"),
            ],
            f,
        )
    }
}
pub type PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryAllocateFlags(u32);
impl MemoryAllocateFlags {
    /// Force allocation on specific devices
    pub const DEVICE_MASK: Self = Self(0x1);
    pub const DEVICE_ADDRESS: Self = Self(0x2);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x4);
    pub const DEVICE_MASK_KHR: Self = Self::DEVICE_MASK;
    pub const DEVICE_ADDRESS_KHR: Self = Self::DEVICE_ADDRESS;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
}
impl default::Default for MemoryAllocateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl MemoryAllocateFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for MemoryAllocateFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for MemoryAllocateFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for MemoryAllocateFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for MemoryAllocateFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for MemoryAllocateFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for MemoryAllocateFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for MemoryAllocateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DEVICE_MASK"),
                (0x2, "DEVICE_ADDRESS"),
                (0x4, "DEVICE_ADDRESS_CAPTURE_REPLAY"),
            ],
            f,
        )
    }
}
pub type MemoryAllocateFlagsKHR = MemoryAllocateFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceGroupPresentModeFlagsKHR(u32);
impl DeviceGroupPresentModeFlagsKHR {
    /// Present from local memory
    pub const LOCAL: Self = Self(0x1);
    /// Present from remote memory
    pub const REMOTE: Self = Self(0x2);
    /// Present sum of local and/or remote memory
    pub const SUM: Self = Self(0x4);
    /// Each physical device presents from local memory
    pub const LOCAL_MULTI_DEVICE: Self = Self(0x8);
}
impl default::Default for DeviceGroupPresentModeFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl DeviceGroupPresentModeFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DeviceGroupPresentModeFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DeviceGroupPresentModeFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DeviceGroupPresentModeFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DeviceGroupPresentModeFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DeviceGroupPresentModeFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DeviceGroupPresentModeFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DeviceGroupPresentModeFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "LOCAL"),
                (0x2, "REMOTE"),
                (0x4, "SUM"),
                (0x8, "LOCAL_MULTI_DEVICE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugReportFlagsEXT(u32);
impl DebugReportFlagsEXT {
    pub const INFORMATION: Self = Self(0x1);
    pub const WARNING: Self = Self(0x2);
    pub const PERFORMANCE_WARNING: Self = Self(0x4);
    pub const ERROR: Self = Self(0x8);
    pub const DEBUG: Self = Self(0x10);
}
impl default::Default for DebugReportFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DebugReportFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DebugReportFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DebugReportFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DebugReportFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DebugReportFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DebugReportFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DebugReportFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DebugReportFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INFORMATION"),
                (0x2, "WARNING"),
                (0x4, "PERFORMANCE_WARNING"),
                (0x8, "ERROR"),
                (0x10, "DEBUG"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandPoolTrimFlags(u32);
impl CommandPoolTrimFlags {}
impl default::Default for CommandPoolTrimFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl CommandPoolTrimFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for CommandPoolTrimFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for CommandPoolTrimFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for CommandPoolTrimFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for CommandPoolTrimFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for CommandPoolTrimFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for CommandPoolTrimFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for CommandPoolTrimFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
pub type CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalMemoryHandleTypeFlagsNV(u32);
impl ExternalMemoryHandleTypeFlagsNV {
    pub const OPAQUE_WIN32: Self = Self(0x1);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x2);
    pub const D3D11_IMAGE: Self = Self(0x4);
    pub const D3D11_IMAGE_KMT: Self = Self(0x8);
}
impl default::Default for ExternalMemoryHandleTypeFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalMemoryHandleTypeFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalMemoryHandleTypeFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalMemoryHandleTypeFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalMemoryHandleTypeFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalMemoryHandleTypeFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalMemoryHandleTypeFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalMemoryHandleTypeFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalMemoryHandleTypeFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_WIN32"),
                (0x2, "OPAQUE_WIN32_KMT"),
                (0x4, "D3D11_IMAGE"),
                (0x8, "D3D11_IMAGE_KMT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalMemoryFeatureFlagsNV(u32);
impl ExternalMemoryFeatureFlagsNV {
    pub const DEDICATED_ONLY: Self = Self(0x1);
    pub const EXPORTABLE: Self = Self(0x2);
    pub const IMPORTABLE: Self = Self(0x4);
}
impl default::Default for ExternalMemoryFeatureFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalMemoryFeatureFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalMemoryFeatureFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalMemoryFeatureFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalMemoryFeatureFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalMemoryFeatureFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalMemoryFeatureFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalMemoryFeatureFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalMemoryFeatureFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEDICATED_ONLY"), (0x2, "EXPORTABLE"), (0x4, "IMPORTABLE")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalMemoryHandleTypeFlags(u32);
impl ExternalMemoryHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const D3D11_TEXTURE: Self = Self(0x8);
    pub const D3D11_TEXTURE_KMT: Self = Self(0x10);
    pub const D3D12_HEAP: Self = Self(0x20);
    pub const D3D12_RESOURCE: Self = Self(0x40);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const D3D11_TEXTURE_KHR: Self = Self::D3D11_TEXTURE;
    pub const D3D11_TEXTURE_KMT_KHR: Self = Self::D3D11_TEXTURE_KMT;
    pub const D3D12_HEAP_KHR: Self = Self::D3D12_HEAP;
    pub const D3D12_RESOURCE_KHR: Self = Self::D3D12_RESOURCE;
    /// Added by extension VK_EXT_external_memory_dma_buf.
    pub const DMA_BUF_EXT: Self = Self(0x200);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_ANDROID: Self = Self(0x400);
    /// Added by extension VK_EXT_external_memory_host.
    pub const HOST_ALLOCATION_EXT: Self = Self(0x80);
    /// Added by extension VK_EXT_external_memory_host.
    pub const HOST_MAPPED_FOREIGN_MEMORY_EXT: Self = Self(0x100);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const ZIRCON_VMO_FUCHSIA: Self = Self(0x800);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const RDMA_ADDRESS_NV: Self = Self(0x1000);
}
impl default::Default for ExternalMemoryHandleTypeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalMemoryHandleTypeFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1fff)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1fff
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalMemoryHandleTypeFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalMemoryHandleTypeFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalMemoryHandleTypeFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalMemoryHandleTypeFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalMemoryHandleTypeFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalMemoryHandleTypeFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalMemoryHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "D3D11_TEXTURE"),
                (0x10, "D3D11_TEXTURE_KMT"),
                (0x20, "D3D12_HEAP"),
                (0x40, "D3D12_RESOURCE"),
                (0x200, "DMA_BUF_EXT"),
                (0x400, "ANDROID_HARDWARE_BUFFER_ANDROID"),
                (0x80, "HOST_ALLOCATION_EXT"),
                (0x100, "HOST_MAPPED_FOREIGN_MEMORY_EXT"),
                (0x800, "ZIRCON_VMO_FUCHSIA"),
                (0x1000, "RDMA_ADDRESS_NV"),
            ],
            f,
        )
    }
}
pub type ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalMemoryFeatureFlags(u32);
impl ExternalMemoryFeatureFlags {
    pub const DEDICATED_ONLY: Self = Self(0x1);
    pub const EXPORTABLE: Self = Self(0x2);
    pub const IMPORTABLE: Self = Self(0x4);
    pub const DEDICATED_ONLY_KHR: Self = Self::DEDICATED_ONLY;
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl default::Default for ExternalMemoryFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalMemoryFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalMemoryFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalMemoryFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalMemoryFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalMemoryFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalMemoryFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalMemoryFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalMemoryFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEDICATED_ONLY"), (0x2, "EXPORTABLE"), (0x4, "IMPORTABLE")],
            f,
        )
    }
}
pub type ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalSemaphoreHandleTypeFlags(u32);
impl ExternalSemaphoreHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const D3D12_FENCE: Self = Self(0x8);
    pub const D3D11_FENCE: Self = Self::D3D12_FENCE;
    pub const SYNC_FD: Self = Self(0x10);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const D3D12_FENCE_KHR: Self = Self::D3D12_FENCE;
    pub const SYNC_FD_KHR: Self = Self::SYNC_FD;
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const ZIRCON_EVENT_FUCHSIA: Self = Self(0x80);
}
impl default::Default for ExternalSemaphoreHandleTypeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalSemaphoreHandleTypeFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x9f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x9f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalSemaphoreHandleTypeFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalSemaphoreHandleTypeFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalSemaphoreHandleTypeFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalSemaphoreHandleTypeFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalSemaphoreHandleTypeFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalSemaphoreHandleTypeFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalSemaphoreHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "D3D12_FENCE"),
                (0x10, "SYNC_FD"),
                (0x80, "ZIRCON_EVENT_FUCHSIA"),
            ],
            f,
        )
    }
}
pub type ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalSemaphoreFeatureFlags(u32);
impl ExternalSemaphoreFeatureFlags {
    pub const EXPORTABLE: Self = Self(0x1);
    pub const IMPORTABLE: Self = Self(0x2);
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl default::Default for ExternalSemaphoreFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalSemaphoreFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalSemaphoreFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalSemaphoreFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalSemaphoreFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalSemaphoreFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalSemaphoreFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalSemaphoreFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalSemaphoreFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXPORTABLE"), (0x2, "IMPORTABLE")], f)
    }
}
pub type ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SemaphoreImportFlags(u32);
impl SemaphoreImportFlags {
    pub const TEMPORARY: Self = Self(0x1);
    pub const TEMPORARY_KHR: Self = Self::TEMPORARY;
}
impl default::Default for SemaphoreImportFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl SemaphoreImportFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SemaphoreImportFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SemaphoreImportFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SemaphoreImportFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SemaphoreImportFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SemaphoreImportFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SemaphoreImportFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SemaphoreImportFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "TEMPORARY")], f)
    }
}
pub type SemaphoreImportFlagsKHR = SemaphoreImportFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalFenceHandleTypeFlags(u32);
impl ExternalFenceHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const SYNC_FD: Self = Self(0x8);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const SYNC_FD_KHR: Self = Self::SYNC_FD;
}
impl default::Default for ExternalFenceHandleTypeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalFenceHandleTypeFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalFenceHandleTypeFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalFenceHandleTypeFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalFenceHandleTypeFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalFenceHandleTypeFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalFenceHandleTypeFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalFenceHandleTypeFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalFenceHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "SYNC_FD"),
            ],
            f,
        )
    }
}
pub type ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalFenceFeatureFlags(u32);
impl ExternalFenceFeatureFlags {
    pub const EXPORTABLE: Self = Self(0x1);
    pub const IMPORTABLE: Self = Self(0x2);
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl default::Default for ExternalFenceFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ExternalFenceFeatureFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x3)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x3
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ExternalFenceFeatureFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ExternalFenceFeatureFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ExternalFenceFeatureFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ExternalFenceFeatureFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ExternalFenceFeatureFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ExternalFenceFeatureFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ExternalFenceFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXPORTABLE"), (0x2, "IMPORTABLE")], f)
    }
}
pub type ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FenceImportFlags(u32);
impl FenceImportFlags {
    pub const TEMPORARY: Self = Self(0x1);
    pub const TEMPORARY_KHR: Self = Self::TEMPORARY;
}
impl default::Default for FenceImportFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl FenceImportFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for FenceImportFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for FenceImportFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for FenceImportFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for FenceImportFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for FenceImportFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for FenceImportFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for FenceImportFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "TEMPORARY")], f)
    }
}
pub type FenceImportFlagsKHR = FenceImportFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceCounterFlagsEXT(u32);
impl SurfaceCounterFlagsEXT {
    pub const VBLANK: Self = Self(0x1);
}
impl default::Default for SurfaceCounterFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl SurfaceCounterFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SurfaceCounterFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SurfaceCounterFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SurfaceCounterFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SurfaceCounterFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SurfaceCounterFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SurfaceCounterFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SurfaceCounterFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "VBLANK")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineViewportSwizzleStateCreateFlagsNV(u32);
impl PipelineViewportSwizzleStateCreateFlagsNV {}
impl default::Default for PipelineViewportSwizzleStateCreateFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineViewportSwizzleStateCreateFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineViewportSwizzleStateCreateFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineViewportSwizzleStateCreateFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineViewportSwizzleStateCreateFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineViewportSwizzleStateCreateFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineViewportSwizzleStateCreateFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineViewportSwizzleStateCreateFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineViewportSwizzleStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineDiscardRectangleStateCreateFlagsEXT(u32);
impl PipelineDiscardRectangleStateCreateFlagsEXT {}
impl default::Default for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineDiscardRectangleStateCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineDiscardRectangleStateCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineDiscardRectangleStateCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineDiscardRectangleStateCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCoverageToColorStateCreateFlagsNV(u32);
impl PipelineCoverageToColorStateCreateFlagsNV {}
impl default::Default for PipelineCoverageToColorStateCreateFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCoverageToColorStateCreateFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCoverageToColorStateCreateFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCoverageToColorStateCreateFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCoverageToColorStateCreateFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCoverageToColorStateCreateFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCoverageToColorStateCreateFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCoverageToColorStateCreateFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCoverageToColorStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCoverageModulationStateCreateFlagsNV(u32);
impl PipelineCoverageModulationStateCreateFlagsNV {}
impl default::Default for PipelineCoverageModulationStateCreateFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCoverageModulationStateCreateFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCoverageModulationStateCreateFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCoverageModulationStateCreateFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCoverageModulationStateCreateFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCoverageModulationStateCreateFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCoverageModulationStateCreateFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCoverageModulationStateCreateFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCoverageModulationStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCoverageReductionStateCreateFlagsNV(u32);
impl PipelineCoverageReductionStateCreateFlagsNV {}
impl default::Default for PipelineCoverageReductionStateCreateFlagsNV {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCoverageReductionStateCreateFlagsNV {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineCoverageReductionStateCreateFlagsNV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineCoverageReductionStateCreateFlagsNV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineCoverageReductionStateCreateFlagsNV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineCoverageReductionStateCreateFlagsNV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineCoverageReductionStateCreateFlagsNV {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineCoverageReductionStateCreateFlagsNV {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineCoverageReductionStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ValidationCacheCreateFlagsEXT(u32);
impl ValidationCacheCreateFlagsEXT {}
impl default::Default for ValidationCacheCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ValidationCacheCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ValidationCacheCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ValidationCacheCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ValidationCacheCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ValidationCacheCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ValidationCacheCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ValidationCacheCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ValidationCacheCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessageSeverityFlagsEXT(u32);
impl DebugUtilsMessageSeverityFlagsEXT {
    pub const VERBOSE: Self = Self(0x1);
    pub const INFO: Self = Self(0x10);
    pub const WARNING: Self = Self(0x100);
    pub const ERROR: Self = Self(0x1000);
}
impl default::Default for DebugUtilsMessageSeverityFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DebugUtilsMessageSeverityFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1111)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1111
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DebugUtilsMessageSeverityFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DebugUtilsMessageSeverityFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DebugUtilsMessageSeverityFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DebugUtilsMessageSeverityFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DebugUtilsMessageSeverityFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DebugUtilsMessageSeverityFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DebugUtilsMessageSeverityFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "VERBOSE"), (0x10, "INFO"), (0x100, "WARNING"), (0x1000, "ERROR")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessageTypeFlagsEXT(u32);
impl DebugUtilsMessageTypeFlagsEXT {
    pub const GENERAL: Self = Self(0x1);
    pub const VALIDATION: Self = Self(0x2);
    pub const PERFORMANCE: Self = Self(0x4);
}
impl default::Default for DebugUtilsMessageTypeFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DebugUtilsMessageTypeFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DebugUtilsMessageTypeFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DebugUtilsMessageTypeFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DebugUtilsMessageTypeFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DebugUtilsMessageTypeFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DebugUtilsMessageTypeFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DebugUtilsMessageTypeFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DebugUtilsMessageTypeFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "GENERAL"), (0x2, "VALIDATION"), (0x4, "PERFORMANCE")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerCreateFlagsEXT(u32);
impl DebugUtilsMessengerCreateFlagsEXT {}
impl default::Default for DebugUtilsMessengerCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DebugUtilsMessengerCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DebugUtilsMessengerCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DebugUtilsMessengerCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DebugUtilsMessengerCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DebugUtilsMessengerCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DebugUtilsMessengerCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DebugUtilsMessengerCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DebugUtilsMessengerCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerCallbackDataFlagsEXT(u32);
impl DebugUtilsMessengerCallbackDataFlagsEXT {}
impl default::Default for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DebugUtilsMessengerCallbackDataFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DebugUtilsMessengerCallbackDataFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DebugUtilsMessengerCallbackDataFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DebugUtilsMessengerCallbackDataFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceMemoryReportFlagsEXT(u32);
impl DeviceMemoryReportFlagsEXT {}
impl default::Default for DeviceMemoryReportFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl DeviceMemoryReportFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DeviceMemoryReportFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DeviceMemoryReportFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DeviceMemoryReportFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DeviceMemoryReportFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DeviceMemoryReportFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DeviceMemoryReportFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DeviceMemoryReportFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationConservativeStateCreateFlagsEXT(u32);
impl PipelineRasterizationConservativeStateCreateFlagsEXT {}
impl default::Default for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineRasterizationConservativeStateCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineRasterizationConservativeStateCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineRasterizationConservativeStateCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineRasterizationConservativeStateCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorBindingFlags(u32);
impl DescriptorBindingFlags {
    pub const UPDATE_AFTER_BIND: Self = Self(0x1);
    pub const UPDATE_UNUSED_WHILE_PENDING: Self = Self(0x2);
    pub const PARTIALLY_BOUND: Self = Self(0x4);
    pub const VARIABLE_DESCRIPTOR_COUNT: Self = Self(0x8);
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    pub const UPDATE_UNUSED_WHILE_PENDING_EXT: Self = Self::UPDATE_UNUSED_WHILE_PENDING;
    pub const PARTIALLY_BOUND_EXT: Self = Self::PARTIALLY_BOUND;
    pub const VARIABLE_DESCRIPTOR_COUNT_EXT: Self = Self::VARIABLE_DESCRIPTOR_COUNT;
}
impl default::Default for DescriptorBindingFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl DescriptorBindingFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for DescriptorBindingFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for DescriptorBindingFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for DescriptorBindingFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for DescriptorBindingFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for DescriptorBindingFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for DescriptorBindingFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for DescriptorBindingFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "UPDATE_AFTER_BIND"),
                (0x2, "UPDATE_UNUSED_WHILE_PENDING"),
                (0x4, "PARTIALLY_BOUND"),
                (0x8, "VARIABLE_DESCRIPTOR_COUNT"),
            ],
            f,
        )
    }
}
pub type DescriptorBindingFlagsEXT = DescriptorBindingFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ConditionalRenderingFlagsEXT(u32);
impl ConditionalRenderingFlagsEXT {
    pub const INVERTED: Self = Self(0x1);
}
impl default::Default for ConditionalRenderingFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ConditionalRenderingFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ConditionalRenderingFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ConditionalRenderingFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ConditionalRenderingFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ConditionalRenderingFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ConditionalRenderingFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ConditionalRenderingFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ConditionalRenderingFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "INVERTED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ResolveModeFlags(u32);
impl ResolveModeFlags {
    pub const NONE: Self = Self(0x0);
    pub const SAMPLE_ZERO: Self = Self(0x1);
    pub const AVERAGE: Self = Self(0x2);
    pub const MIN: Self = Self(0x4);
    pub const MAX: Self = Self(0x8);
    pub const NONE_KHR: Self = Self::NONE;
    pub const SAMPLE_ZERO_KHR: Self = Self::SAMPLE_ZERO;
    pub const AVERAGE_KHR: Self = Self::AVERAGE;
    pub const MIN_KHR: Self = Self::MIN;
    pub const MAX_KHR: Self = Self::MAX;
}
impl default::Default for ResolveModeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ResolveModeFlags {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0xf)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0xf
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ResolveModeFlags {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ResolveModeFlags {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ResolveModeFlags {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ResolveModeFlags {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ResolveModeFlags {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ResolveModeFlags {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ResolveModeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "SAMPLE_ZERO"), (0x2, "AVERAGE"), (0x4, "MIN"), (0x8, "MAX")],
            f,
        )
    }
}
pub type ResolveModeFlagsKHR = ResolveModeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationStateStreamCreateFlagsEXT(u32);
impl PipelineRasterizationStateStreamCreateFlagsEXT {}
impl default::Default for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineRasterizationStateStreamCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineRasterizationStateStreamCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineRasterizationStateStreamCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineRasterizationStateStreamCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationDepthClipStateCreateFlagsEXT(u32);
impl PipelineRasterizationDepthClipStateCreateFlagsEXT {}
impl default::Default for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineRasterizationDepthClipStateCreateFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ToolPurposeFlagsEXT(u32);
impl ToolPurposeFlagsEXT {
    pub const VALIDATION: Self = Self(0x1);
    pub const PROFILING: Self = Self(0x2);
    pub const TRACING: Self = Self(0x4);
    pub const ADDITIONAL_FEATURES: Self = Self(0x8);
    pub const MODIFYING_FEATURES: Self = Self(0x10);
    /// Added by extension VK_EXT_tooling_info.
    pub const DEBUG_REPORTING: Self = Self(0x20);
    /// Added by extension VK_EXT_tooling_info.
    pub const DEBUG_MARKERS: Self = Self(0x40);
}
impl default::Default for ToolPurposeFlagsEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ToolPurposeFlagsEXT {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x7f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x7f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ToolPurposeFlagsEXT {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ToolPurposeFlagsEXT {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ToolPurposeFlagsEXT {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ToolPurposeFlagsEXT {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ToolPurposeFlagsEXT {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ToolPurposeFlagsEXT {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ToolPurposeFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VALIDATION"),
                (0x2, "PROFILING"),
                (0x4, "TRACING"),
                (0x8, "ADDITIONAL_FEATURES"),
                (0x10, "MODIFYING_FEATURES"),
                (0x20, "DEBUG_REPORTING"),
                (0x40, "DEBUG_MARKERS"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SubmitFlagsKHR(u32);
impl SubmitFlagsKHR {
    pub const PROTECTED: Self = Self(0x1);
}
impl default::Default for SubmitFlagsKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl SubmitFlagsKHR {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for SubmitFlagsKHR {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for SubmitFlagsKHR {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for SubmitFlagsKHR {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for SubmitFlagsKHR {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for SubmitFlagsKHR {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for SubmitFlagsKHR {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for SubmitFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PROTECTED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageFormatConstraintsFlagsFUCHSIA(u32);
impl ImageFormatConstraintsFlagsFUCHSIA {}
impl default::Default for ImageFormatConstraintsFlagsFUCHSIA {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageFormatConstraintsFlagsFUCHSIA {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x0)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x0
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageFormatConstraintsFlagsFUCHSIA {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageFormatConstraintsFlagsFUCHSIA {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageFormatConstraintsFlagsFUCHSIA {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageFormatConstraintsFlagsFUCHSIA {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageFormatConstraintsFlagsFUCHSIA {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageFormatConstraintsFlagsFUCHSIA {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageFormatConstraintsFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageConstraintsInfoFlagsFUCHSIA(u32);
impl ImageConstraintsInfoFlagsFUCHSIA {
    pub const CPU_READ_RARELY: Self = Self(0x1);
    pub const CPU_READ_OFTEN: Self = Self(0x2);
    pub const CPU_WRITE_RARELY: Self = Self(0x4);
    pub const CPU_WRITE_OFTEN: Self = Self(0x8);
    pub const PROTECTED_OPTIONAL: Self = Self(0x10);
}
impl default::Default for ImageConstraintsInfoFlagsFUCHSIA {
    fn default() -> Self {
        Self(0)
    }
}
impl ImageConstraintsInfoFlagsFUCHSIA {
    pub fn empty() -> Self {
        Self(0)
    }
    pub fn all() -> Self {
        Self(0x1f)
    }
    pub fn is_empty(self) -> bool {
        self.0 == 0
    }
    pub fn is_all(self) -> bool {
        self.0 == 0x1f
    }
    pub fn intersects(self, other: Self) -> bool {
        (self.0 & other.0) != 0
    }
    pub fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }
}
impl ops::BitOr for ImageConstraintsInfoFlagsFUCHSIA {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ops::BitOrAssign for ImageConstraintsInfoFlagsFUCHSIA {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0 |= rhs.0;
    }
}
impl ops::BitAnd for ImageConstraintsInfoFlagsFUCHSIA {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ops::BitAndAssign for ImageConstraintsInfoFlagsFUCHSIA {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0 &= rhs.0;
    }
}
impl ops::BitXor for ImageConstraintsInfoFlagsFUCHSIA {
    type Output = Self;
    fn bitxor(self, rhs: Self) -> Self {
        Self(self.0 ^ rhs.0)
    }
}
impl ops::BitXorAssign for ImageConstraintsInfoFlagsFUCHSIA {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0 ^= rhs.0;
    }
}
impl fmt::Display for ImageConstraintsInfoFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "CPU_READ_RARELY"),
                (0x2, "CPU_READ_OFTEN"),
                (0x4, "CPU_WRITE_RARELY"),
                (0x8, "CPU_WRITE_OFTEN"),
                (0x10, "PROTECTED_OPTIONAL"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Instance(num::NonZeroUsize);
impl Instance {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysicalDevice(num::NonZeroUsize);
impl PhysicalDevice {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Device(num::NonZeroUsize);
impl Device {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Queue(num::NonZeroUsize);
impl Queue {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandBuffer(num::NonZeroUsize);
impl CommandBuffer {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceMemory(num::NonZeroU64);
impl DeviceMemory {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandPool(num::NonZeroU64);
impl CommandPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Buffer(num::NonZeroU64);
impl Buffer {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferView(num::NonZeroU64);
impl BufferView {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Image(num::NonZeroU64);
impl Image {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageView(num::NonZeroU64);
impl ImageView {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderModule(num::NonZeroU64);
impl ShaderModule {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Pipeline(num::NonZeroU64);
impl Pipeline {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineLayout(num::NonZeroU64);
impl PipelineLayout {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Sampler(num::NonZeroU64);
impl Sampler {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorSet(num::NonZeroU64);
impl DescriptorSet {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorSetLayout(num::NonZeroU64);
impl DescriptorSetLayout {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorPool(num::NonZeroU64);
impl DescriptorPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Fence(num::NonZeroU64);
impl Fence {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Semaphore(num::NonZeroU64);
impl Semaphore {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Event(num::NonZeroU64);
impl Event {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPool(num::NonZeroU64);
impl QueryPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Framebuffer(num::NonZeroU64);
impl Framebuffer {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct RenderPass(num::NonZeroU64);
impl RenderPass {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCache(num::NonZeroU64);
impl PipelineCache {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct IndirectCommandsLayoutNV(num::NonZeroU64);
impl IndirectCommandsLayoutNV {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplate(num::NonZeroU64);
impl DescriptorUpdateTemplate {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
pub type DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrConversion(num::NonZeroU64);
impl SamplerYcbcrConversion {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
pub type SamplerYcbcrConversionKHR = SamplerYcbcrConversion;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ValidationCacheEXT(num::NonZeroU64);
impl ValidationCacheEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureKHR(num::NonZeroU64);
impl AccelerationStructureKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureNV(num::NonZeroU64);
impl AccelerationStructureNV {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PerformanceConfigurationINTEL(num::NonZeroU64);
impl PerformanceConfigurationINTEL {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferCollectionFUCHSIA(num::NonZeroU64);
impl BufferCollectionFUCHSIA {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeferredOperationKHR(num::NonZeroU64);
impl DeferredOperationKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PrivateDataSlotEXT(num::NonZeroU64);
impl PrivateDataSlotEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CuModuleNVX(num::NonZeroU64);
impl CuModuleNVX {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CuFunctionNVX(num::NonZeroU64);
impl CuFunctionNVX {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayKHR(num::NonZeroU64);
impl DisplayKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayModeKHR(num::NonZeroU64);
impl DisplayModeKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceKHR(num::NonZeroU64);
impl SurfaceKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SwapchainKHR(num::NonZeroU64);
impl SwapchainKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugReportCallbackEXT(num::NonZeroU64);
impl DebugReportCallbackEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerEXT(num::NonZeroU64);
impl DebugUtilsMessengerEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VideoSessionKHR(num::NonZeroU64);
impl VideoSessionKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VideoSessionParametersKHR(num::NonZeroU64);
impl VideoSessionParametersKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AttachmentLoadOp(i32);
impl AttachmentLoadOp {
    pub const LOAD: Self = Self(0);
    pub const CLEAR: Self = Self(1);
    pub const DONT_CARE: Self = Self(2);
    /// Added by extension VK_EXT_load_store_op_none.
    pub const NONE_EXT: Self = Self(1000400000);
}
impl default::Default for AttachmentLoadOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AttachmentLoadOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"LOAD"),
            1 => Some(&"CLEAR"),
            2 => Some(&"DONT_CARE"),
            1000400000 => Some(&"NONE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AttachmentStoreOp(i32);
impl AttachmentStoreOp {
    pub const STORE: Self = Self(0);
    pub const DONT_CARE: Self = Self(1);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const NONE_KHR: Self = Self(1000301000);
    pub const NONE_QCOM: Self = Self::NONE_KHR;
    pub const NONE_EXT: Self = Self::NONE_KHR;
}
impl default::Default for AttachmentStoreOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AttachmentStoreOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STORE"),
            1 => Some(&"DONT_CARE"),
            1000301000 => Some(&"NONE_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendFactor(i32);
impl BlendFactor {
    pub const ZERO: Self = Self(0);
    pub const ONE: Self = Self(1);
    pub const SRC_COLOR: Self = Self(2);
    pub const ONE_MINUS_SRC_COLOR: Self = Self(3);
    pub const DST_COLOR: Self = Self(4);
    pub const ONE_MINUS_DST_COLOR: Self = Self(5);
    pub const SRC_ALPHA: Self = Self(6);
    pub const ONE_MINUS_SRC_ALPHA: Self = Self(7);
    pub const DST_ALPHA: Self = Self(8);
    pub const ONE_MINUS_DST_ALPHA: Self = Self(9);
    pub const CONSTANT_COLOR: Self = Self(10);
    pub const ONE_MINUS_CONSTANT_COLOR: Self = Self(11);
    pub const CONSTANT_ALPHA: Self = Self(12);
    pub const ONE_MINUS_CONSTANT_ALPHA: Self = Self(13);
    pub const SRC_ALPHA_SATURATE: Self = Self(14);
    pub const SRC1_COLOR: Self = Self(15);
    pub const ONE_MINUS_SRC1_COLOR: Self = Self(16);
    pub const SRC1_ALPHA: Self = Self(17);
    pub const ONE_MINUS_SRC1_ALPHA: Self = Self(18);
}
impl default::Default for BlendFactor {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for BlendFactor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ZERO"),
            1 => Some(&"ONE"),
            2 => Some(&"SRC_COLOR"),
            3 => Some(&"ONE_MINUS_SRC_COLOR"),
            4 => Some(&"DST_COLOR"),
            5 => Some(&"ONE_MINUS_DST_COLOR"),
            6 => Some(&"SRC_ALPHA"),
            7 => Some(&"ONE_MINUS_SRC_ALPHA"),
            8 => Some(&"DST_ALPHA"),
            9 => Some(&"ONE_MINUS_DST_ALPHA"),
            10 => Some(&"CONSTANT_COLOR"),
            11 => Some(&"ONE_MINUS_CONSTANT_COLOR"),
            12 => Some(&"CONSTANT_ALPHA"),
            13 => Some(&"ONE_MINUS_CONSTANT_ALPHA"),
            14 => Some(&"SRC_ALPHA_SATURATE"),
            15 => Some(&"SRC1_COLOR"),
            16 => Some(&"ONE_MINUS_SRC1_COLOR"),
            17 => Some(&"SRC1_ALPHA"),
            18 => Some(&"ONE_MINUS_SRC1_ALPHA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendOp(i32);
impl BlendOp {
    pub const ADD: Self = Self(0);
    pub const SUBTRACT: Self = Self(1);
    pub const REVERSE_SUBTRACT: Self = Self(2);
    pub const MIN: Self = Self(3);
    pub const MAX: Self = Self(4);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const ZERO_EXT: Self = Self(1000148000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_EXT: Self = Self(1000148001);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_EXT: Self = Self(1000148002);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_OVER_EXT: Self = Self(1000148003);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_OVER_EXT: Self = Self(1000148004);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_IN_EXT: Self = Self(1000148005);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_IN_EXT: Self = Self(1000148006);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_OUT_EXT: Self = Self(1000148007);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_OUT_EXT: Self = Self(1000148008);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_ATOP_EXT: Self = Self(1000148009);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_ATOP_EXT: Self = Self(1000148010);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const XOR_EXT: Self = Self(1000148011);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MULTIPLY_EXT: Self = Self(1000148012);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SCREEN_EXT: Self = Self(1000148013);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const OVERLAY_EXT: Self = Self(1000148014);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DARKEN_EXT: Self = Self(1000148015);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LIGHTEN_EXT: Self = Self(1000148016);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLORDODGE_EXT: Self = Self(1000148017);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLORBURN_EXT: Self = Self(1000148018);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HARDLIGHT_EXT: Self = Self(1000148019);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SOFTLIGHT_EXT: Self = Self(1000148020);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DIFFERENCE_EXT: Self = Self(1000148021);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const EXCLUSION_EXT: Self = Self(1000148022);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_EXT: Self = Self(1000148023);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_RGB_EXT: Self = Self(1000148024);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARDODGE_EXT: Self = Self(1000148025);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARBURN_EXT: Self = Self(1000148026);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const VIVIDLIGHT_EXT: Self = Self(1000148027);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARLIGHT_EXT: Self = Self(1000148028);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PINLIGHT_EXT: Self = Self(1000148029);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HARDMIX_EXT: Self = Self(1000148030);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_HUE_EXT: Self = Self(1000148031);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_SATURATION_EXT: Self = Self(1000148032);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_COLOR_EXT: Self = Self(1000148033);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_LUMINOSITY_EXT: Self = Self(1000148034);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_EXT: Self = Self(1000148035);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_CLAMPED_EXT: Self = Self(1000148036);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_CLAMPED_ALPHA_EXT: Self = Self(1000148037);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_DARKER_EXT: Self = Self(1000148038);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MINUS_EXT: Self = Self(1000148039);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MINUS_CLAMPED_EXT: Self = Self(1000148040);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const CONTRAST_EXT: Self = Self(1000148041);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_OVG_EXT: Self = Self(1000148042);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const RED_EXT: Self = Self(1000148043);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const GREEN_EXT: Self = Self(1000148044);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const BLUE_EXT: Self = Self(1000148045);
}
impl default::Default for BlendOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for BlendOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ADD"),
            1 => Some(&"SUBTRACT"),
            2 => Some(&"REVERSE_SUBTRACT"),
            3 => Some(&"MIN"),
            4 => Some(&"MAX"),
            1000148000 => Some(&"ZERO_EXT"),
            1000148001 => Some(&"SRC_EXT"),
            1000148002 => Some(&"DST_EXT"),
            1000148003 => Some(&"SRC_OVER_EXT"),
            1000148004 => Some(&"DST_OVER_EXT"),
            1000148005 => Some(&"SRC_IN_EXT"),
            1000148006 => Some(&"DST_IN_EXT"),
            1000148007 => Some(&"SRC_OUT_EXT"),
            1000148008 => Some(&"DST_OUT_EXT"),
            1000148009 => Some(&"SRC_ATOP_EXT"),
            1000148010 => Some(&"DST_ATOP_EXT"),
            1000148011 => Some(&"XOR_EXT"),
            1000148012 => Some(&"MULTIPLY_EXT"),
            1000148013 => Some(&"SCREEN_EXT"),
            1000148014 => Some(&"OVERLAY_EXT"),
            1000148015 => Some(&"DARKEN_EXT"),
            1000148016 => Some(&"LIGHTEN_EXT"),
            1000148017 => Some(&"COLORDODGE_EXT"),
            1000148018 => Some(&"COLORBURN_EXT"),
            1000148019 => Some(&"HARDLIGHT_EXT"),
            1000148020 => Some(&"SOFTLIGHT_EXT"),
            1000148021 => Some(&"DIFFERENCE_EXT"),
            1000148022 => Some(&"EXCLUSION_EXT"),
            1000148023 => Some(&"INVERT_EXT"),
            1000148024 => Some(&"INVERT_RGB_EXT"),
            1000148025 => Some(&"LINEARDODGE_EXT"),
            1000148026 => Some(&"LINEARBURN_EXT"),
            1000148027 => Some(&"VIVIDLIGHT_EXT"),
            1000148028 => Some(&"LINEARLIGHT_EXT"),
            1000148029 => Some(&"PINLIGHT_EXT"),
            1000148030 => Some(&"HARDMIX_EXT"),
            1000148031 => Some(&"HSL_HUE_EXT"),
            1000148032 => Some(&"HSL_SATURATION_EXT"),
            1000148033 => Some(&"HSL_COLOR_EXT"),
            1000148034 => Some(&"HSL_LUMINOSITY_EXT"),
            1000148035 => Some(&"PLUS_EXT"),
            1000148036 => Some(&"PLUS_CLAMPED_EXT"),
            1000148037 => Some(&"PLUS_CLAMPED_ALPHA_EXT"),
            1000148038 => Some(&"PLUS_DARKER_EXT"),
            1000148039 => Some(&"MINUS_EXT"),
            1000148040 => Some(&"MINUS_CLAMPED_EXT"),
            1000148041 => Some(&"CONTRAST_EXT"),
            1000148042 => Some(&"INVERT_OVG_EXT"),
            1000148043 => Some(&"RED_EXT"),
            1000148044 => Some(&"GREEN_EXT"),
            1000148045 => Some(&"BLUE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BorderColor(i32);
impl BorderColor {
    pub const FLOAT_TRANSPARENT_BLACK: Self = Self(0);
    pub const INT_TRANSPARENT_BLACK: Self = Self(1);
    pub const FLOAT_OPAQUE_BLACK: Self = Self(2);
    pub const INT_OPAQUE_BLACK: Self = Self(3);
    pub const FLOAT_OPAQUE_WHITE: Self = Self(4);
    pub const INT_OPAQUE_WHITE: Self = Self(5);
    /// Added by extension VK_EXT_custom_border_color.
    pub const FLOAT_CUSTOM_EXT: Self = Self(1000287003);
    /// Added by extension VK_EXT_custom_border_color.
    pub const INT_CUSTOM_EXT: Self = Self(1000287004);
}
impl default::Default for BorderColor {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for BorderColor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FLOAT_TRANSPARENT_BLACK"),
            1 => Some(&"INT_TRANSPARENT_BLACK"),
            2 => Some(&"FLOAT_OPAQUE_BLACK"),
            3 => Some(&"INT_OPAQUE_BLACK"),
            4 => Some(&"FLOAT_OPAQUE_WHITE"),
            5 => Some(&"INT_OPAQUE_WHITE"),
            1000287003 => Some(&"FLOAT_CUSTOM_EXT"),
            1000287004 => Some(&"INT_CUSTOM_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineCacheHeaderVersion(i32);
impl PipelineCacheHeaderVersion {
    pub const ONE: Self = Self(1);
}
impl default::Default for PipelineCacheHeaderVersion {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PipelineCacheHeaderVersion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"ONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ComponentSwizzle(i32);
impl ComponentSwizzle {
    pub const IDENTITY: Self = Self(0);
    pub const ZERO: Self = Self(1);
    pub const ONE: Self = Self(2);
    pub const R: Self = Self(3);
    pub const G: Self = Self(4);
    pub const B: Self = Self(5);
    pub const A: Self = Self(6);
}
impl default::Default for ComponentSwizzle {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ComponentSwizzle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"IDENTITY"),
            1 => Some(&"ZERO"),
            2 => Some(&"ONE"),
            3 => Some(&"R"),
            4 => Some(&"G"),
            5 => Some(&"B"),
            6 => Some(&"A"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CommandBufferLevel(i32);
impl CommandBufferLevel {
    pub const PRIMARY: Self = Self(0);
    pub const SECONDARY: Self = Self(1);
}
impl default::Default for CommandBufferLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CommandBufferLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"PRIMARY"),
            1 => Some(&"SECONDARY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CompareOp(i32);
impl CompareOp {
    pub const NEVER: Self = Self(0);
    pub const LESS: Self = Self(1);
    pub const EQUAL: Self = Self(2);
    pub const LESS_OR_EQUAL: Self = Self(3);
    pub const GREATER: Self = Self(4);
    pub const NOT_EQUAL: Self = Self(5);
    pub const GREATER_OR_EQUAL: Self = Self(6);
    pub const ALWAYS: Self = Self(7);
}
impl default::Default for CompareOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CompareOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEVER"),
            1 => Some(&"LESS"),
            2 => Some(&"EQUAL"),
            3 => Some(&"LESS_OR_EQUAL"),
            4 => Some(&"GREATER"),
            5 => Some(&"NOT_EQUAL"),
            6 => Some(&"GREATER_OR_EQUAL"),
            7 => Some(&"ALWAYS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DescriptorType(i32);
impl DescriptorType {
    pub const SAMPLER: Self = Self(0);
    pub const COMBINED_IMAGE_SAMPLER: Self = Self(1);
    pub const SAMPLED_IMAGE: Self = Self(2);
    pub const STORAGE_IMAGE: Self = Self(3);
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    pub const STORAGE_TEXEL_BUFFER: Self = Self(5);
    pub const UNIFORM_BUFFER: Self = Self(6);
    pub const STORAGE_BUFFER: Self = Self(7);
    pub const UNIFORM_BUFFER_DYNAMIC: Self = Self(8);
    pub const STORAGE_BUFFER_DYNAMIC: Self = Self(9);
    pub const INPUT_ATTACHMENT: Self = Self(10);
    /// Added by extension VK_EXT_inline_uniform_block.
    pub const INLINE_UNIFORM_BLOCK_EXT: Self = Self(1000138000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const MUTABLE_VALVE: Self = Self(1000351000);
}
impl default::Default for DescriptorType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DescriptorType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SAMPLER"),
            1 => Some(&"COMBINED_IMAGE_SAMPLER"),
            2 => Some(&"SAMPLED_IMAGE"),
            3 => Some(&"STORAGE_IMAGE"),
            4 => Some(&"UNIFORM_TEXEL_BUFFER"),
            5 => Some(&"STORAGE_TEXEL_BUFFER"),
            6 => Some(&"UNIFORM_BUFFER"),
            7 => Some(&"STORAGE_BUFFER"),
            8 => Some(&"UNIFORM_BUFFER_DYNAMIC"),
            9 => Some(&"STORAGE_BUFFER_DYNAMIC"),
            10 => Some(&"INPUT_ATTACHMENT"),
            1000138000 => Some(&"INLINE_UNIFORM_BLOCK_EXT"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000351000 => Some(&"MUTABLE_VALVE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DynamicState(i32);
impl DynamicState {
    pub const VIEWPORT: Self = Self(0);
    pub const SCISSOR: Self = Self(1);
    pub const LINE_WIDTH: Self = Self(2);
    pub const DEPTH_BIAS: Self = Self(3);
    pub const BLEND_CONSTANTS: Self = Self(4);
    pub const DEPTH_BOUNDS: Self = Self(5);
    pub const STENCIL_COMPARE_MASK: Self = Self(6);
    pub const STENCIL_WRITE_MASK: Self = Self(7);
    pub const STENCIL_REFERENCE: Self = Self(8);
    /// Added by extension VK_NV_clip_space_w_scaling.
    pub const VIEWPORT_W_SCALING_NV: Self = Self(1000087000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const DISCARD_RECTANGLE_EXT: Self = Self(1000099000);
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_EXT: Self = Self(1000143000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_STACK_SIZE_KHR: Self = Self(1000347000);
    /// Added by extension VK_NV_shading_rate_image.
    pub const VIEWPORT_SHADING_RATE_PALETTE_NV: Self = Self(1000164004);
    /// Added by extension VK_NV_shading_rate_image.
    pub const VIEWPORT_COARSE_SAMPLE_ORDER_NV: Self = Self(1000164006);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const EXCLUSIVE_SCISSOR_NV: Self = Self(1000205001);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226000);
    /// Added by extension VK_EXT_line_rasterization.
    pub const LINE_STIPPLE_EXT: Self = Self(1000259000);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const CULL_MODE_EXT: Self = Self(1000267000);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const FRONT_FACE_EXT: Self = Self(1000267001);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const PRIMITIVE_TOPOLOGY_EXT: Self = Self(1000267002);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const VIEWPORT_WITH_COUNT_EXT: Self = Self(1000267003);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const SCISSOR_WITH_COUNT_EXT: Self = Self(1000267004);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const VERTEX_INPUT_BINDING_STRIDE_EXT: Self = Self(1000267005);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const DEPTH_TEST_ENABLE_EXT: Self = Self(1000267006);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const DEPTH_WRITE_ENABLE_EXT: Self = Self(1000267007);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const DEPTH_COMPARE_OP_EXT: Self = Self(1000267008);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const DEPTH_BOUNDS_TEST_ENABLE_EXT: Self = Self(1000267009);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const STENCIL_TEST_ENABLE_EXT: Self = Self(1000267010);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const STENCIL_OP_EXT: Self = Self(1000267011);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_EXT: Self = Self(1000352000);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const PATCH_CONTROL_POINTS_EXT: Self = Self(1000377000);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const RASTERIZER_DISCARD_ENABLE_EXT: Self = Self(1000377001);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const DEPTH_BIAS_ENABLE_EXT: Self = Self(1000377002);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const LOGIC_OP_EXT: Self = Self(1000377003);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const PRIMITIVE_RESTART_ENABLE_EXT: Self = Self(1000377004);
    /// Added by extension VK_EXT_color_write_enable.
    pub const COLOR_WRITE_ENABLE_EXT: Self = Self(1000381000);
}
impl default::Default for DynamicState {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DynamicState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"VIEWPORT"),
            1 => Some(&"SCISSOR"),
            2 => Some(&"LINE_WIDTH"),
            3 => Some(&"DEPTH_BIAS"),
            4 => Some(&"BLEND_CONSTANTS"),
            5 => Some(&"DEPTH_BOUNDS"),
            6 => Some(&"STENCIL_COMPARE_MASK"),
            7 => Some(&"STENCIL_WRITE_MASK"),
            8 => Some(&"STENCIL_REFERENCE"),
            1000087000 => Some(&"VIEWPORT_W_SCALING_NV"),
            1000099000 => Some(&"DISCARD_RECTANGLE_EXT"),
            1000143000 => Some(&"SAMPLE_LOCATIONS_EXT"),
            1000347000 => Some(&"RAY_TRACING_PIPELINE_STACK_SIZE_KHR"),
            1000164004 => Some(&"VIEWPORT_SHADING_RATE_PALETTE_NV"),
            1000164006 => Some(&"VIEWPORT_COARSE_SAMPLE_ORDER_NV"),
            1000205001 => Some(&"EXCLUSIVE_SCISSOR_NV"),
            1000226000 => Some(&"FRAGMENT_SHADING_RATE_KHR"),
            1000259000 => Some(&"LINE_STIPPLE_EXT"),
            1000267000 => Some(&"CULL_MODE_EXT"),
            1000267001 => Some(&"FRONT_FACE_EXT"),
            1000267002 => Some(&"PRIMITIVE_TOPOLOGY_EXT"),
            1000267003 => Some(&"VIEWPORT_WITH_COUNT_EXT"),
            1000267004 => Some(&"SCISSOR_WITH_COUNT_EXT"),
            1000267005 => Some(&"VERTEX_INPUT_BINDING_STRIDE_EXT"),
            1000267006 => Some(&"DEPTH_TEST_ENABLE_EXT"),
            1000267007 => Some(&"DEPTH_WRITE_ENABLE_EXT"),
            1000267008 => Some(&"DEPTH_COMPARE_OP_EXT"),
            1000267009 => Some(&"DEPTH_BOUNDS_TEST_ENABLE_EXT"),
            1000267010 => Some(&"STENCIL_TEST_ENABLE_EXT"),
            1000267011 => Some(&"STENCIL_OP_EXT"),
            1000352000 => Some(&"VERTEX_INPUT_EXT"),
            1000377000 => Some(&"PATCH_CONTROL_POINTS_EXT"),
            1000377001 => Some(&"RASTERIZER_DISCARD_ENABLE_EXT"),
            1000377002 => Some(&"DEPTH_BIAS_ENABLE_EXT"),
            1000377003 => Some(&"LOGIC_OP_EXT"),
            1000377004 => Some(&"PRIMITIVE_RESTART_ENABLE_EXT"),
            1000381000 => Some(&"COLOR_WRITE_ENABLE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PolygonMode(i32);
impl PolygonMode {
    pub const FILL: Self = Self(0);
    pub const LINE: Self = Self(1);
    pub const POINT: Self = Self(2);
    /// Added by extension VK_NV_fill_rectangle.
    pub const FILL_RECTANGLE_NV: Self = Self(1000153000);
}
impl default::Default for PolygonMode {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PolygonMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FILL"),
            1 => Some(&"LINE"),
            2 => Some(&"POINT"),
            1000153000 => Some(&"FILL_RECTANGLE_NV"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Format(i32);
impl Format {
    pub const UNDEFINED: Self = Self(0);
    pub const R4G4_UNORM_PACK8: Self = Self(1);
    pub const R4G4B4A4_UNORM_PACK16: Self = Self(2);
    pub const B4G4R4A4_UNORM_PACK16: Self = Self(3);
    pub const R5G6B5_UNORM_PACK16: Self = Self(4);
    pub const B5G6R5_UNORM_PACK16: Self = Self(5);
    pub const R5G5B5A1_UNORM_PACK16: Self = Self(6);
    pub const B5G5R5A1_UNORM_PACK16: Self = Self(7);
    pub const A1R5G5B5_UNORM_PACK16: Self = Self(8);
    pub const R8_UNORM: Self = Self(9);
    pub const R8_SNORM: Self = Self(10);
    pub const R8_USCALED: Self = Self(11);
    pub const R8_SSCALED: Self = Self(12);
    pub const R8_UINT: Self = Self(13);
    pub const R8_SINT: Self = Self(14);
    pub const R8_SRGB: Self = Self(15);
    pub const R8G8_UNORM: Self = Self(16);
    pub const R8G8_SNORM: Self = Self(17);
    pub const R8G8_USCALED: Self = Self(18);
    pub const R8G8_SSCALED: Self = Self(19);
    pub const R8G8_UINT: Self = Self(20);
    pub const R8G8_SINT: Self = Self(21);
    pub const R8G8_SRGB: Self = Self(22);
    pub const R8G8B8_UNORM: Self = Self(23);
    pub const R8G8B8_SNORM: Self = Self(24);
    pub const R8G8B8_USCALED: Self = Self(25);
    pub const R8G8B8_SSCALED: Self = Self(26);
    pub const R8G8B8_UINT: Self = Self(27);
    pub const R8G8B8_SINT: Self = Self(28);
    pub const R8G8B8_SRGB: Self = Self(29);
    pub const B8G8R8_UNORM: Self = Self(30);
    pub const B8G8R8_SNORM: Self = Self(31);
    pub const B8G8R8_USCALED: Self = Self(32);
    pub const B8G8R8_SSCALED: Self = Self(33);
    pub const B8G8R8_UINT: Self = Self(34);
    pub const B8G8R8_SINT: Self = Self(35);
    pub const B8G8R8_SRGB: Self = Self(36);
    pub const R8G8B8A8_UNORM: Self = Self(37);
    pub const R8G8B8A8_SNORM: Self = Self(38);
    pub const R8G8B8A8_USCALED: Self = Self(39);
    pub const R8G8B8A8_SSCALED: Self = Self(40);
    pub const R8G8B8A8_UINT: Self = Self(41);
    pub const R8G8B8A8_SINT: Self = Self(42);
    pub const R8G8B8A8_SRGB: Self = Self(43);
    pub const B8G8R8A8_UNORM: Self = Self(44);
    pub const B8G8R8A8_SNORM: Self = Self(45);
    pub const B8G8R8A8_USCALED: Self = Self(46);
    pub const B8G8R8A8_SSCALED: Self = Self(47);
    pub const B8G8R8A8_UINT: Self = Self(48);
    pub const B8G8R8A8_SINT: Self = Self(49);
    pub const B8G8R8A8_SRGB: Self = Self(50);
    pub const A8B8G8R8_UNORM_PACK32: Self = Self(51);
    pub const A8B8G8R8_SNORM_PACK32: Self = Self(52);
    pub const A8B8G8R8_USCALED_PACK32: Self = Self(53);
    pub const A8B8G8R8_SSCALED_PACK32: Self = Self(54);
    pub const A8B8G8R8_UINT_PACK32: Self = Self(55);
    pub const A8B8G8R8_SINT_PACK32: Self = Self(56);
    pub const A8B8G8R8_SRGB_PACK32: Self = Self(57);
    pub const A2R10G10B10_UNORM_PACK32: Self = Self(58);
    pub const A2R10G10B10_SNORM_PACK32: Self = Self(59);
    pub const A2R10G10B10_USCALED_PACK32: Self = Self(60);
    pub const A2R10G10B10_SSCALED_PACK32: Self = Self(61);
    pub const A2R10G10B10_UINT_PACK32: Self = Self(62);
    pub const A2R10G10B10_SINT_PACK32: Self = Self(63);
    pub const A2B10G10R10_UNORM_PACK32: Self = Self(64);
    pub const A2B10G10R10_SNORM_PACK32: Self = Self(65);
    pub const A2B10G10R10_USCALED_PACK32: Self = Self(66);
    pub const A2B10G10R10_SSCALED_PACK32: Self = Self(67);
    pub const A2B10G10R10_UINT_PACK32: Self = Self(68);
    pub const A2B10G10R10_SINT_PACK32: Self = Self(69);
    pub const R16_UNORM: Self = Self(70);
    pub const R16_SNORM: Self = Self(71);
    pub const R16_USCALED: Self = Self(72);
    pub const R16_SSCALED: Self = Self(73);
    pub const R16_UINT: Self = Self(74);
    pub const R16_SINT: Self = Self(75);
    pub const R16_SFLOAT: Self = Self(76);
    pub const R16G16_UNORM: Self = Self(77);
    pub const R16G16_SNORM: Self = Self(78);
    pub const R16G16_USCALED: Self = Self(79);
    pub const R16G16_SSCALED: Self = Self(80);
    pub const R16G16_UINT: Self = Self(81);
    pub const R16G16_SINT: Self = Self(82);
    pub const R16G16_SFLOAT: Self = Self(83);
    pub const R16G16B16_UNORM: Self = Self(84);
    pub const R16G16B16_SNORM: Self = Self(85);
    pub const R16G16B16_USCALED: Self = Self(86);
    pub const R16G16B16_SSCALED: Self = Self(87);
    pub const R16G16B16_UINT: Self = Self(88);
    pub const R16G16B16_SINT: Self = Self(89);
    pub const R16G16B16_SFLOAT: Self = Self(90);
    pub const R16G16B16A16_UNORM: Self = Self(91);
    pub const R16G16B16A16_SNORM: Self = Self(92);
    pub const R16G16B16A16_USCALED: Self = Self(93);
    pub const R16G16B16A16_SSCALED: Self = Self(94);
    pub const R16G16B16A16_UINT: Self = Self(95);
    pub const R16G16B16A16_SINT: Self = Self(96);
    pub const R16G16B16A16_SFLOAT: Self = Self(97);
    pub const R32_UINT: Self = Self(98);
    pub const R32_SINT: Self = Self(99);
    pub const R32_SFLOAT: Self = Self(100);
    pub const R32G32_UINT: Self = Self(101);
    pub const R32G32_SINT: Self = Self(102);
    pub const R32G32_SFLOAT: Self = Self(103);
    pub const R32G32B32_UINT: Self = Self(104);
    pub const R32G32B32_SINT: Self = Self(105);
    pub const R32G32B32_SFLOAT: Self = Self(106);
    pub const R32G32B32A32_UINT: Self = Self(107);
    pub const R32G32B32A32_SINT: Self = Self(108);
    pub const R32G32B32A32_SFLOAT: Self = Self(109);
    pub const R64_UINT: Self = Self(110);
    pub const R64_SINT: Self = Self(111);
    pub const R64_SFLOAT: Self = Self(112);
    pub const R64G64_UINT: Self = Self(113);
    pub const R64G64_SINT: Self = Self(114);
    pub const R64G64_SFLOAT: Self = Self(115);
    pub const R64G64B64_UINT: Self = Self(116);
    pub const R64G64B64_SINT: Self = Self(117);
    pub const R64G64B64_SFLOAT: Self = Self(118);
    pub const R64G64B64A64_UINT: Self = Self(119);
    pub const R64G64B64A64_SINT: Self = Self(120);
    pub const R64G64B64A64_SFLOAT: Self = Self(121);
    pub const B10G11R11_UFLOAT_PACK32: Self = Self(122);
    pub const E5B9G9R9_UFLOAT_PACK32: Self = Self(123);
    pub const D16_UNORM: Self = Self(124);
    pub const X8_D24_UNORM_PACK32: Self = Self(125);
    pub const D32_SFLOAT: Self = Self(126);
    pub const S8_UINT: Self = Self(127);
    pub const D16_UNORM_S8_UINT: Self = Self(128);
    pub const D24_UNORM_S8_UINT: Self = Self(129);
    pub const D32_SFLOAT_S8_UINT: Self = Self(130);
    pub const BC1_RGB_UNORM_BLOCK: Self = Self(131);
    pub const BC1_RGB_SRGB_BLOCK: Self = Self(132);
    pub const BC1_RGBA_UNORM_BLOCK: Self = Self(133);
    pub const BC1_RGBA_SRGB_BLOCK: Self = Self(134);
    pub const BC2_UNORM_BLOCK: Self = Self(135);
    pub const BC2_SRGB_BLOCK: Self = Self(136);
    pub const BC3_UNORM_BLOCK: Self = Self(137);
    pub const BC3_SRGB_BLOCK: Self = Self(138);
    pub const BC4_UNORM_BLOCK: Self = Self(139);
    pub const BC4_SNORM_BLOCK: Self = Self(140);
    pub const BC5_UNORM_BLOCK: Self = Self(141);
    pub const BC5_SNORM_BLOCK: Self = Self(142);
    pub const BC6H_UFLOAT_BLOCK: Self = Self(143);
    pub const BC6H_SFLOAT_BLOCK: Self = Self(144);
    pub const BC7_UNORM_BLOCK: Self = Self(145);
    pub const BC7_SRGB_BLOCK: Self = Self(146);
    pub const ETC2_R8G8B8_UNORM_BLOCK: Self = Self(147);
    pub const ETC2_R8G8B8_SRGB_BLOCK: Self = Self(148);
    pub const ETC2_R8G8B8A1_UNORM_BLOCK: Self = Self(149);
    pub const ETC2_R8G8B8A1_SRGB_BLOCK: Self = Self(150);
    pub const ETC2_R8G8B8A8_UNORM_BLOCK: Self = Self(151);
    pub const ETC2_R8G8B8A8_SRGB_BLOCK: Self = Self(152);
    pub const EAC_R11_UNORM_BLOCK: Self = Self(153);
    pub const EAC_R11_SNORM_BLOCK: Self = Self(154);
    pub const EAC_R11G11_UNORM_BLOCK: Self = Self(155);
    pub const EAC_R11G11_SNORM_BLOCK: Self = Self(156);
    pub const ASTC_4X4_UNORM_BLOCK: Self = Self(157);
    pub const ASTC_4X4_SRGB_BLOCK: Self = Self(158);
    pub const ASTC_5X4_UNORM_BLOCK: Self = Self(159);
    pub const ASTC_5X4_SRGB_BLOCK: Self = Self(160);
    pub const ASTC_5X5_UNORM_BLOCK: Self = Self(161);
    pub const ASTC_5X5_SRGB_BLOCK: Self = Self(162);
    pub const ASTC_6X5_UNORM_BLOCK: Self = Self(163);
    pub const ASTC_6X5_SRGB_BLOCK: Self = Self(164);
    pub const ASTC_6X6_UNORM_BLOCK: Self = Self(165);
    pub const ASTC_6X6_SRGB_BLOCK: Self = Self(166);
    pub const ASTC_8X5_UNORM_BLOCK: Self = Self(167);
    pub const ASTC_8X5_SRGB_BLOCK: Self = Self(168);
    pub const ASTC_8X6_UNORM_BLOCK: Self = Self(169);
    pub const ASTC_8X6_SRGB_BLOCK: Self = Self(170);
    pub const ASTC_8X8_UNORM_BLOCK: Self = Self(171);
    pub const ASTC_8X8_SRGB_BLOCK: Self = Self(172);
    pub const ASTC_10X5_UNORM_BLOCK: Self = Self(173);
    pub const ASTC_10X5_SRGB_BLOCK: Self = Self(174);
    pub const ASTC_10X6_UNORM_BLOCK: Self = Self(175);
    pub const ASTC_10X6_SRGB_BLOCK: Self = Self(176);
    pub const ASTC_10X8_UNORM_BLOCK: Self = Self(177);
    pub const ASTC_10X8_SRGB_BLOCK: Self = Self(178);
    pub const ASTC_10X10_UNORM_BLOCK: Self = Self(179);
    pub const ASTC_10X10_SRGB_BLOCK: Self = Self(180);
    pub const ASTC_12X10_UNORM_BLOCK: Self = Self(181);
    pub const ASTC_12X10_SRGB_BLOCK: Self = Self(182);
    pub const ASTC_12X12_UNORM_BLOCK: Self = Self(183);
    pub const ASTC_12X12_SRGB_BLOCK: Self = Self(184);
    pub const G8B8G8R8_422_UNORM: Self = Self(1000156000);
    pub const B8G8R8G8_422_UNORM: Self = Self(1000156001);
    pub const G8_B8_R8_3PLANE_420_UNORM: Self = Self(1000156002);
    pub const G8_B8R8_2PLANE_420_UNORM: Self = Self(1000156003);
    pub const G8_B8_R8_3PLANE_422_UNORM: Self = Self(1000156004);
    pub const G8_B8R8_2PLANE_422_UNORM: Self = Self(1000156005);
    pub const G8_B8_R8_3PLANE_444_UNORM: Self = Self(1000156006);
    pub const R10X6_UNORM_PACK16: Self = Self(1000156007);
    pub const R10X6G10X6_UNORM_2PACK16: Self = Self(1000156008);
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16: Self = Self(1000156009);
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: Self = Self(1000156010);
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: Self = Self(1000156011);
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: Self = Self(1000156012);
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: Self = Self(1000156013);
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: Self = Self(1000156014);
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: Self = Self(1000156015);
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: Self = Self(1000156016);
    pub const R12X4_UNORM_PACK16: Self = Self(1000156017);
    pub const R12X4G12X4_UNORM_2PACK16: Self = Self(1000156018);
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16: Self = Self(1000156019);
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: Self = Self(1000156020);
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: Self = Self(1000156021);
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: Self = Self(1000156022);
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: Self = Self(1000156023);
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: Self = Self(1000156024);
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: Self = Self(1000156025);
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: Self = Self(1000156026);
    pub const G16B16G16R16_422_UNORM: Self = Self(1000156027);
    pub const B16G16R16G16_422_UNORM: Self = Self(1000156028);
    pub const G16_B16_R16_3PLANE_420_UNORM: Self = Self(1000156029);
    pub const G16_B16R16_2PLANE_420_UNORM: Self = Self(1000156030);
    pub const G16_B16_R16_3PLANE_422_UNORM: Self = Self(1000156031);
    pub const G16_B16R16_2PLANE_422_UNORM: Self = Self(1000156032);
    pub const G16_B16_R16_3PLANE_444_UNORM: Self = Self(1000156033);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_2BPP_UNORM_BLOCK_IMG: Self = Self(1000054000);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_4BPP_UNORM_BLOCK_IMG: Self = Self(1000054001);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_2BPP_UNORM_BLOCK_IMG: Self = Self(1000054002);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_4BPP_UNORM_BLOCK_IMG: Self = Self(1000054003);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_2BPP_SRGB_BLOCK_IMG: Self = Self(1000054004);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_4BPP_SRGB_BLOCK_IMG: Self = Self(1000054005);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_2BPP_SRGB_BLOCK_IMG: Self = Self(1000054006);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_4BPP_SRGB_BLOCK_IMG: Self = Self(1000054007);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_4X4_SFLOAT_BLOCK_EXT: Self = Self(1000066000);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_5X4_SFLOAT_BLOCK_EXT: Self = Self(1000066001);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_5X5_SFLOAT_BLOCK_EXT: Self = Self(1000066002);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_6X5_SFLOAT_BLOCK_EXT: Self = Self(1000066003);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_6X6_SFLOAT_BLOCK_EXT: Self = Self(1000066004);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_8X5_SFLOAT_BLOCK_EXT: Self = Self(1000066005);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_8X6_SFLOAT_BLOCK_EXT: Self = Self(1000066006);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_8X8_SFLOAT_BLOCK_EXT: Self = Self(1000066007);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_10X5_SFLOAT_BLOCK_EXT: Self = Self(1000066008);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_10X6_SFLOAT_BLOCK_EXT: Self = Self(1000066009);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_10X8_SFLOAT_BLOCK_EXT: Self = Self(1000066010);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_10X10_SFLOAT_BLOCK_EXT: Self = Self(1000066011);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_12X10_SFLOAT_BLOCK_EXT: Self = Self(1000066012);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const ASTC_12X12_SFLOAT_BLOCK_EXT: Self = Self(1000066013);
    pub const G8B8G8R8_422_UNORM_KHR: Self = Self::G8B8G8R8_422_UNORM;
    pub const B8G8R8G8_422_UNORM_KHR: Self = Self::B8G8R8G8_422_UNORM;
    pub const G8_B8_R8_3PLANE_420_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_420_UNORM;
    pub const G8_B8R8_2PLANE_420_UNORM_KHR: Self = Self::G8_B8R8_2PLANE_420_UNORM;
    pub const G8_B8_R8_3PLANE_422_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_422_UNORM;
    pub const G8_B8R8_2PLANE_422_UNORM_KHR: Self = Self::G8_B8R8_2PLANE_422_UNORM;
    pub const G8_B8_R8_3PLANE_444_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_444_UNORM;
    pub const R10X6_UNORM_PACK16_KHR: Self = Self::R10X6_UNORM_PACK16;
    pub const R10X6G10X6_UNORM_2PACK16_KHR: Self = Self::R10X6G10X6_UNORM_2PACK16;
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: Self = Self::R10X6G10X6B10X6A10X6_UNORM_4PACK16;
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: Self = Self::G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: Self = Self::B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
    pub const R12X4_UNORM_PACK16_KHR: Self = Self::R12X4_UNORM_PACK16;
    pub const R12X4G12X4_UNORM_2PACK16_KHR: Self = Self::R12X4G12X4_UNORM_2PACK16;
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: Self = Self::R12X4G12X4B12X4A12X4_UNORM_4PACK16;
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: Self = Self::G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: Self = Self::B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
    pub const G16B16G16R16_422_UNORM_KHR: Self = Self::G16B16G16R16_422_UNORM;
    pub const B16G16R16G16_422_UNORM_KHR: Self = Self::B16G16R16G16_422_UNORM;
    pub const G16_B16_R16_3PLANE_420_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_420_UNORM;
    pub const G16_B16R16_2PLANE_420_UNORM_KHR: Self = Self::G16_B16R16_2PLANE_420_UNORM;
    pub const G16_B16_R16_3PLANE_422_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_422_UNORM;
    pub const G16_B16R16_2PLANE_422_UNORM_KHR: Self = Self::G16_B16R16_2PLANE_422_UNORM;
    pub const G16_B16_R16_3PLANE_444_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_444_UNORM;
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const G8_B8R8_2PLANE_444_UNORM_EXT: Self = Self(1000330000);
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: Self = Self(1000330001);
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: Self = Self(1000330002);
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const G16_B16R16_2PLANE_444_UNORM_EXT: Self = Self(1000330003);
    /// Added by extension VK_EXT_4444_formats.
    pub const A4R4G4B4_UNORM_PACK16_EXT: Self = Self(1000340000);
    /// Added by extension VK_EXT_4444_formats.
    pub const A4B4G4R4_UNORM_PACK16_EXT: Self = Self(1000340001);
}
impl default::Default for Format {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNDEFINED"),
            1 => Some(&"R4G4_UNORM_PACK8"),
            2 => Some(&"R4G4B4A4_UNORM_PACK16"),
            3 => Some(&"B4G4R4A4_UNORM_PACK16"),
            4 => Some(&"R5G6B5_UNORM_PACK16"),
            5 => Some(&"B5G6R5_UNORM_PACK16"),
            6 => Some(&"R5G5B5A1_UNORM_PACK16"),
            7 => Some(&"B5G5R5A1_UNORM_PACK16"),
            8 => Some(&"A1R5G5B5_UNORM_PACK16"),
            9 => Some(&"R8_UNORM"),
            10 => Some(&"R8_SNORM"),
            11 => Some(&"R8_USCALED"),
            12 => Some(&"R8_SSCALED"),
            13 => Some(&"R8_UINT"),
            14 => Some(&"R8_SINT"),
            15 => Some(&"R8_SRGB"),
            16 => Some(&"R8G8_UNORM"),
            17 => Some(&"R8G8_SNORM"),
            18 => Some(&"R8G8_USCALED"),
            19 => Some(&"R8G8_SSCALED"),
            20 => Some(&"R8G8_UINT"),
            21 => Some(&"R8G8_SINT"),
            22 => Some(&"R8G8_SRGB"),
            23 => Some(&"R8G8B8_UNORM"),
            24 => Some(&"R8G8B8_SNORM"),
            25 => Some(&"R8G8B8_USCALED"),
            26 => Some(&"R8G8B8_SSCALED"),
            27 => Some(&"R8G8B8_UINT"),
            28 => Some(&"R8G8B8_SINT"),
            29 => Some(&"R8G8B8_SRGB"),
            30 => Some(&"B8G8R8_UNORM"),
            31 => Some(&"B8G8R8_SNORM"),
            32 => Some(&"B8G8R8_USCALED"),
            33 => Some(&"B8G8R8_SSCALED"),
            34 => Some(&"B8G8R8_UINT"),
            35 => Some(&"B8G8R8_SINT"),
            36 => Some(&"B8G8R8_SRGB"),
            37 => Some(&"R8G8B8A8_UNORM"),
            38 => Some(&"R8G8B8A8_SNORM"),
            39 => Some(&"R8G8B8A8_USCALED"),
            40 => Some(&"R8G8B8A8_SSCALED"),
            41 => Some(&"R8G8B8A8_UINT"),
            42 => Some(&"R8G8B8A8_SINT"),
            43 => Some(&"R8G8B8A8_SRGB"),
            44 => Some(&"B8G8R8A8_UNORM"),
            45 => Some(&"B8G8R8A8_SNORM"),
            46 => Some(&"B8G8R8A8_USCALED"),
            47 => Some(&"B8G8R8A8_SSCALED"),
            48 => Some(&"B8G8R8A8_UINT"),
            49 => Some(&"B8G8R8A8_SINT"),
            50 => Some(&"B8G8R8A8_SRGB"),
            51 => Some(&"A8B8G8R8_UNORM_PACK32"),
            52 => Some(&"A8B8G8R8_SNORM_PACK32"),
            53 => Some(&"A8B8G8R8_USCALED_PACK32"),
            54 => Some(&"A8B8G8R8_SSCALED_PACK32"),
            55 => Some(&"A8B8G8R8_UINT_PACK32"),
            56 => Some(&"A8B8G8R8_SINT_PACK32"),
            57 => Some(&"A8B8G8R8_SRGB_PACK32"),
            58 => Some(&"A2R10G10B10_UNORM_PACK32"),
            59 => Some(&"A2R10G10B10_SNORM_PACK32"),
            60 => Some(&"A2R10G10B10_USCALED_PACK32"),
            61 => Some(&"A2R10G10B10_SSCALED_PACK32"),
            62 => Some(&"A2R10G10B10_UINT_PACK32"),
            63 => Some(&"A2R10G10B10_SINT_PACK32"),
            64 => Some(&"A2B10G10R10_UNORM_PACK32"),
            65 => Some(&"A2B10G10R10_SNORM_PACK32"),
            66 => Some(&"A2B10G10R10_USCALED_PACK32"),
            67 => Some(&"A2B10G10R10_SSCALED_PACK32"),
            68 => Some(&"A2B10G10R10_UINT_PACK32"),
            69 => Some(&"A2B10G10R10_SINT_PACK32"),
            70 => Some(&"R16_UNORM"),
            71 => Some(&"R16_SNORM"),
            72 => Some(&"R16_USCALED"),
            73 => Some(&"R16_SSCALED"),
            74 => Some(&"R16_UINT"),
            75 => Some(&"R16_SINT"),
            76 => Some(&"R16_SFLOAT"),
            77 => Some(&"R16G16_UNORM"),
            78 => Some(&"R16G16_SNORM"),
            79 => Some(&"R16G16_USCALED"),
            80 => Some(&"R16G16_SSCALED"),
            81 => Some(&"R16G16_UINT"),
            82 => Some(&"R16G16_SINT"),
            83 => Some(&"R16G16_SFLOAT"),
            84 => Some(&"R16G16B16_UNORM"),
            85 => Some(&"R16G16B16_SNORM"),
            86 => Some(&"R16G16B16_USCALED"),
            87 => Some(&"R16G16B16_SSCALED"),
            88 => Some(&"R16G16B16_UINT"),
            89 => Some(&"R16G16B16_SINT"),
            90 => Some(&"R16G16B16_SFLOAT"),
            91 => Some(&"R16G16B16A16_UNORM"),
            92 => Some(&"R16G16B16A16_SNORM"),
            93 => Some(&"R16G16B16A16_USCALED"),
            94 => Some(&"R16G16B16A16_SSCALED"),
            95 => Some(&"R16G16B16A16_UINT"),
            96 => Some(&"R16G16B16A16_SINT"),
            97 => Some(&"R16G16B16A16_SFLOAT"),
            98 => Some(&"R32_UINT"),
            99 => Some(&"R32_SINT"),
            100 => Some(&"R32_SFLOAT"),
            101 => Some(&"R32G32_UINT"),
            102 => Some(&"R32G32_SINT"),
            103 => Some(&"R32G32_SFLOAT"),
            104 => Some(&"R32G32B32_UINT"),
            105 => Some(&"R32G32B32_SINT"),
            106 => Some(&"R32G32B32_SFLOAT"),
            107 => Some(&"R32G32B32A32_UINT"),
            108 => Some(&"R32G32B32A32_SINT"),
            109 => Some(&"R32G32B32A32_SFLOAT"),
            110 => Some(&"R64_UINT"),
            111 => Some(&"R64_SINT"),
            112 => Some(&"R64_SFLOAT"),
            113 => Some(&"R64G64_UINT"),
            114 => Some(&"R64G64_SINT"),
            115 => Some(&"R64G64_SFLOAT"),
            116 => Some(&"R64G64B64_UINT"),
            117 => Some(&"R64G64B64_SINT"),
            118 => Some(&"R64G64B64_SFLOAT"),
            119 => Some(&"R64G64B64A64_UINT"),
            120 => Some(&"R64G64B64A64_SINT"),
            121 => Some(&"R64G64B64A64_SFLOAT"),
            122 => Some(&"B10G11R11_UFLOAT_PACK32"),
            123 => Some(&"E5B9G9R9_UFLOAT_PACK32"),
            124 => Some(&"D16_UNORM"),
            125 => Some(&"X8_D24_UNORM_PACK32"),
            126 => Some(&"D32_SFLOAT"),
            127 => Some(&"S8_UINT"),
            128 => Some(&"D16_UNORM_S8_UINT"),
            129 => Some(&"D24_UNORM_S8_UINT"),
            130 => Some(&"D32_SFLOAT_S8_UINT"),
            131 => Some(&"BC1_RGB_UNORM_BLOCK"),
            132 => Some(&"BC1_RGB_SRGB_BLOCK"),
            133 => Some(&"BC1_RGBA_UNORM_BLOCK"),
            134 => Some(&"BC1_RGBA_SRGB_BLOCK"),
            135 => Some(&"BC2_UNORM_BLOCK"),
            136 => Some(&"BC2_SRGB_BLOCK"),
            137 => Some(&"BC3_UNORM_BLOCK"),
            138 => Some(&"BC3_SRGB_BLOCK"),
            139 => Some(&"BC4_UNORM_BLOCK"),
            140 => Some(&"BC4_SNORM_BLOCK"),
            141 => Some(&"BC5_UNORM_BLOCK"),
            142 => Some(&"BC5_SNORM_BLOCK"),
            143 => Some(&"BC6H_UFLOAT_BLOCK"),
            144 => Some(&"BC6H_SFLOAT_BLOCK"),
            145 => Some(&"BC7_UNORM_BLOCK"),
            146 => Some(&"BC7_SRGB_BLOCK"),
            147 => Some(&"ETC2_R8G8B8_UNORM_BLOCK"),
            148 => Some(&"ETC2_R8G8B8_SRGB_BLOCK"),
            149 => Some(&"ETC2_R8G8B8A1_UNORM_BLOCK"),
            150 => Some(&"ETC2_R8G8B8A1_SRGB_BLOCK"),
            151 => Some(&"ETC2_R8G8B8A8_UNORM_BLOCK"),
            152 => Some(&"ETC2_R8G8B8A8_SRGB_BLOCK"),
            153 => Some(&"EAC_R11_UNORM_BLOCK"),
            154 => Some(&"EAC_R11_SNORM_BLOCK"),
            155 => Some(&"EAC_R11G11_UNORM_BLOCK"),
            156 => Some(&"EAC_R11G11_SNORM_BLOCK"),
            157 => Some(&"ASTC_4X4_UNORM_BLOCK"),
            158 => Some(&"ASTC_4X4_SRGB_BLOCK"),
            159 => Some(&"ASTC_5X4_UNORM_BLOCK"),
            160 => Some(&"ASTC_5X4_SRGB_BLOCK"),
            161 => Some(&"ASTC_5X5_UNORM_BLOCK"),
            162 => Some(&"ASTC_5X5_SRGB_BLOCK"),
            163 => Some(&"ASTC_6X5_UNORM_BLOCK"),
            164 => Some(&"ASTC_6X5_SRGB_BLOCK"),
            165 => Some(&"ASTC_6X6_UNORM_BLOCK"),
            166 => Some(&"ASTC_6X6_SRGB_BLOCK"),
            167 => Some(&"ASTC_8X5_UNORM_BLOCK"),
            168 => Some(&"ASTC_8X5_SRGB_BLOCK"),
            169 => Some(&"ASTC_8X6_UNORM_BLOCK"),
            170 => Some(&"ASTC_8X6_SRGB_BLOCK"),
            171 => Some(&"ASTC_8X8_UNORM_BLOCK"),
            172 => Some(&"ASTC_8X8_SRGB_BLOCK"),
            173 => Some(&"ASTC_10X5_UNORM_BLOCK"),
            174 => Some(&"ASTC_10X5_SRGB_BLOCK"),
            175 => Some(&"ASTC_10X6_UNORM_BLOCK"),
            176 => Some(&"ASTC_10X6_SRGB_BLOCK"),
            177 => Some(&"ASTC_10X8_UNORM_BLOCK"),
            178 => Some(&"ASTC_10X8_SRGB_BLOCK"),
            179 => Some(&"ASTC_10X10_UNORM_BLOCK"),
            180 => Some(&"ASTC_10X10_SRGB_BLOCK"),
            181 => Some(&"ASTC_12X10_UNORM_BLOCK"),
            182 => Some(&"ASTC_12X10_SRGB_BLOCK"),
            183 => Some(&"ASTC_12X12_UNORM_BLOCK"),
            184 => Some(&"ASTC_12X12_SRGB_BLOCK"),
            1000156000 => Some(&"G8B8G8R8_422_UNORM"),
            1000156001 => Some(&"B8G8R8G8_422_UNORM"),
            1000156002 => Some(&"G8_B8_R8_3PLANE_420_UNORM"),
            1000156003 => Some(&"G8_B8R8_2PLANE_420_UNORM"),
            1000156004 => Some(&"G8_B8_R8_3PLANE_422_UNORM"),
            1000156005 => Some(&"G8_B8R8_2PLANE_422_UNORM"),
            1000156006 => Some(&"G8_B8_R8_3PLANE_444_UNORM"),
            1000156007 => Some(&"R10X6_UNORM_PACK16"),
            1000156008 => Some(&"R10X6G10X6_UNORM_2PACK16"),
            1000156009 => Some(&"R10X6G10X6B10X6A10X6_UNORM_4PACK16"),
            1000156010 => Some(&"G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"),
            1000156011 => Some(&"B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"),
            1000156012 => Some(&"G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"),
            1000156013 => Some(&"G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"),
            1000156014 => Some(&"G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"),
            1000156015 => Some(&"G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"),
            1000156016 => Some(&"G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"),
            1000156017 => Some(&"R12X4_UNORM_PACK16"),
            1000156018 => Some(&"R12X4G12X4_UNORM_2PACK16"),
            1000156019 => Some(&"R12X4G12X4B12X4A12X4_UNORM_4PACK16"),
            1000156020 => Some(&"G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"),
            1000156021 => Some(&"B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"),
            1000156022 => Some(&"G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"),
            1000156023 => Some(&"G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"),
            1000156024 => Some(&"G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"),
            1000156025 => Some(&"G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"),
            1000156026 => Some(&"G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"),
            1000156027 => Some(&"G16B16G16R16_422_UNORM"),
            1000156028 => Some(&"B16G16R16G16_422_UNORM"),
            1000156029 => Some(&"G16_B16_R16_3PLANE_420_UNORM"),
            1000156030 => Some(&"G16_B16R16_2PLANE_420_UNORM"),
            1000156031 => Some(&"G16_B16_R16_3PLANE_422_UNORM"),
            1000156032 => Some(&"G16_B16R16_2PLANE_422_UNORM"),
            1000156033 => Some(&"G16_B16_R16_3PLANE_444_UNORM"),
            1000054000 => Some(&"PVRTC1_2BPP_UNORM_BLOCK_IMG"),
            1000054001 => Some(&"PVRTC1_4BPP_UNORM_BLOCK_IMG"),
            1000054002 => Some(&"PVRTC2_2BPP_UNORM_BLOCK_IMG"),
            1000054003 => Some(&"PVRTC2_4BPP_UNORM_BLOCK_IMG"),
            1000054004 => Some(&"PVRTC1_2BPP_SRGB_BLOCK_IMG"),
            1000054005 => Some(&"PVRTC1_4BPP_SRGB_BLOCK_IMG"),
            1000054006 => Some(&"PVRTC2_2BPP_SRGB_BLOCK_IMG"),
            1000054007 => Some(&"PVRTC2_4BPP_SRGB_BLOCK_IMG"),
            1000066000 => Some(&"ASTC_4X4_SFLOAT_BLOCK_EXT"),
            1000066001 => Some(&"ASTC_5X4_SFLOAT_BLOCK_EXT"),
            1000066002 => Some(&"ASTC_5X5_SFLOAT_BLOCK_EXT"),
            1000066003 => Some(&"ASTC_6X5_SFLOAT_BLOCK_EXT"),
            1000066004 => Some(&"ASTC_6X6_SFLOAT_BLOCK_EXT"),
            1000066005 => Some(&"ASTC_8X5_SFLOAT_BLOCK_EXT"),
            1000066006 => Some(&"ASTC_8X6_SFLOAT_BLOCK_EXT"),
            1000066007 => Some(&"ASTC_8X8_SFLOAT_BLOCK_EXT"),
            1000066008 => Some(&"ASTC_10X5_SFLOAT_BLOCK_EXT"),
            1000066009 => Some(&"ASTC_10X6_SFLOAT_BLOCK_EXT"),
            1000066010 => Some(&"ASTC_10X8_SFLOAT_BLOCK_EXT"),
            1000066011 => Some(&"ASTC_10X10_SFLOAT_BLOCK_EXT"),
            1000066012 => Some(&"ASTC_12X10_SFLOAT_BLOCK_EXT"),
            1000066013 => Some(&"ASTC_12X12_SFLOAT_BLOCK_EXT"),
            1000330000 => Some(&"G8_B8R8_2PLANE_444_UNORM_EXT"),
            1000330001 => Some(&"G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT"),
            1000330002 => Some(&"G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT"),
            1000330003 => Some(&"G16_B16R16_2PLANE_444_UNORM_EXT"),
            1000340000 => Some(&"A4R4G4B4_UNORM_PACK16_EXT"),
            1000340001 => Some(&"A4B4G4R4_UNORM_PACK16_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FrontFace(i32);
impl FrontFace {
    pub const COUNTER_CLOCKWISE: Self = Self(0);
    pub const CLOCKWISE: Self = Self(1);
}
impl default::Default for FrontFace {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for FrontFace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COUNTER_CLOCKWISE"),
            1 => Some(&"CLOCKWISE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageLayout(i32);
impl ImageLayout {
    /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    pub const UNDEFINED: Self = Self(0);
    /// General layout when image can be used for any kind of access
    pub const GENERAL: Self = Self(1);
    /// Optimal layout when image is only used for color attachment read/write
    pub const COLOR_ATTACHMENT_OPTIMAL: Self = Self(2);
    /// Optimal layout when image is only used for depth/stencil attachment read/write
    pub const DEPTH_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(3);
    /// Optimal layout when image is used for read only depth/stencil attachment and shader access
    pub const DEPTH_STENCIL_READ_ONLY_OPTIMAL: Self = Self(4);
    /// Optimal layout when image is used for read only shader access
    pub const SHADER_READ_ONLY_OPTIMAL: Self = Self(5);
    /// Optimal layout when image is used only as source of transfer operations
    pub const TRANSFER_SRC_OPTIMAL: Self = Self(6);
    /// Optimal layout when image is used only as destination of transfer operations
    pub const TRANSFER_DST_OPTIMAL: Self = Self(7);
    /// Initial layout used when the data is populated by the CPU
    pub const PREINITIALIZED: Self = Self(8);
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000117000);
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000117001);
    pub const DEPTH_ATTACHMENT_OPTIMAL: Self = Self(1000241000);
    pub const DEPTH_READ_ONLY_OPTIMAL: Self = Self(1000241001);
    pub const STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000241002);
    pub const STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000241003);
    /// Added by extension VK_KHR_swapchain.
    pub const PRESENT_SRC_KHR: Self = Self(1000001002);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_PRESENT_KHR: Self = Self(1000111000);
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    pub const SHADING_RATE_OPTIMAL_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: Self = Self(1000218000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR: Self = Self(1000164003);
    pub const DEPTH_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_OPTIMAL;
    pub const DEPTH_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_OPTIMAL;
    pub const STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::STENCIL_ATTACHMENT_OPTIMAL;
    pub const STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::STENCIL_READ_ONLY_OPTIMAL;
    /// Added by extension VK_KHR_synchronization2.
    pub const READ_ONLY_OPTIMAL_KHR: Self = Self(1000314000);
    /// Added by extension VK_KHR_synchronization2.
    pub const ATTACHMENT_OPTIMAL_KHR: Self = Self(1000314001);
}
impl default::Default for ImageLayout {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ImageLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNDEFINED"),
            1 => Some(&"GENERAL"),
            2 => Some(&"COLOR_ATTACHMENT_OPTIMAL"),
            3 => Some(&"DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
            4 => Some(&"DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
            5 => Some(&"SHADER_READ_ONLY_OPTIMAL"),
            6 => Some(&"TRANSFER_SRC_OPTIMAL"),
            7 => Some(&"TRANSFER_DST_OPTIMAL"),
            8 => Some(&"PREINITIALIZED"),
            1000117000 => Some(&"DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"),
            1000117001 => Some(&"DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"),
            1000241000 => Some(&"DEPTH_ATTACHMENT_OPTIMAL"),
            1000241001 => Some(&"DEPTH_READ_ONLY_OPTIMAL"),
            1000241002 => Some(&"STENCIL_ATTACHMENT_OPTIMAL"),
            1000241003 => Some(&"STENCIL_READ_ONLY_OPTIMAL"),
            1000001002 => Some(&"PRESENT_SRC_KHR"),
            1000111000 => Some(&"SHARED_PRESENT_KHR"),
            1000218000 => Some(&"FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"),
            1000164003 => Some(&"FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"),
            1000314000 => Some(&"READ_ONLY_OPTIMAL_KHR"),
            1000314001 => Some(&"ATTACHMENT_OPTIMAL_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageTiling(i32);
impl ImageTiling {
    pub const OPTIMAL: Self = Self(0);
    pub const LINEAR: Self = Self(1);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_EXT: Self = Self(1000158000);
}
impl default::Default for ImageTiling {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ImageTiling {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OPTIMAL"),
            1 => Some(&"LINEAR"),
            1000158000 => Some(&"DRM_FORMAT_MODIFIER_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageType(i32);
impl ImageType {
    pub const N1D: Self = Self(0);
    pub const N2D: Self = Self(1);
    pub const N3D: Self = Self(2);
}
impl default::Default for ImageType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ImageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1D"),
            1 => Some(&"N2D"),
            2 => Some(&"N3D"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageViewType(i32);
impl ImageViewType {
    pub const N1D: Self = Self(0);
    pub const N2D: Self = Self(1);
    pub const N3D: Self = Self(2);
    pub const CUBE: Self = Self(3);
    pub const N1D_ARRAY: Self = Self(4);
    pub const N2D_ARRAY: Self = Self(5);
    pub const CUBE_ARRAY: Self = Self(6);
}
impl default::Default for ImageViewType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ImageViewType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1D"),
            1 => Some(&"N2D"),
            2 => Some(&"N3D"),
            3 => Some(&"CUBE"),
            4 => Some(&"N1D_ARRAY"),
            5 => Some(&"N2D_ARRAY"),
            6 => Some(&"CUBE_ARRAY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SharingMode(i32);
impl SharingMode {
    pub const EXCLUSIVE: Self = Self(0);
    pub const CONCURRENT: Self = Self(1);
}
impl default::Default for SharingMode {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SharingMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"EXCLUSIVE"),
            1 => Some(&"CONCURRENT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct IndexType(i32);
impl IndexType {
    pub const UINT16: Self = Self(0);
    pub const UINT32: Self = Self(1);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const NONE_KHR: Self = Self(1000165000);
    pub const NONE_NV: Self = Self::NONE_KHR;
    /// Added by extension VK_EXT_index_type_uint8.
    pub const UINT8_EXT: Self = Self(1000265000);
}
impl default::Default for IndexType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for IndexType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UINT16"),
            1 => Some(&"UINT32"),
            1000165000 => Some(&"NONE_KHR"),
            1000265000 => Some(&"UINT8_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct LogicOp(i32);
impl LogicOp {
    pub const CLEAR: Self = Self(0);
    pub const AND: Self = Self(1);
    pub const AND_REVERSE: Self = Self(2);
    pub const COPY: Self = Self(3);
    pub const AND_INVERTED: Self = Self(4);
    pub const NO_OP: Self = Self(5);
    pub const XOR: Self = Self(6);
    pub const OR: Self = Self(7);
    pub const NOR: Self = Self(8);
    pub const EQUIVALENT: Self = Self(9);
    pub const INVERT: Self = Self(10);
    pub const OR_REVERSE: Self = Self(11);
    pub const COPY_INVERTED: Self = Self(12);
    pub const OR_INVERTED: Self = Self(13);
    pub const NAND: Self = Self(14);
    pub const SET: Self = Self(15);
}
impl default::Default for LogicOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for LogicOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"CLEAR"),
            1 => Some(&"AND"),
            2 => Some(&"AND_REVERSE"),
            3 => Some(&"COPY"),
            4 => Some(&"AND_INVERTED"),
            5 => Some(&"NO_OP"),
            6 => Some(&"XOR"),
            7 => Some(&"OR"),
            8 => Some(&"NOR"),
            9 => Some(&"EQUIVALENT"),
            10 => Some(&"INVERT"),
            11 => Some(&"OR_REVERSE"),
            12 => Some(&"COPY_INVERTED"),
            13 => Some(&"OR_INVERTED"),
            14 => Some(&"NAND"),
            15 => Some(&"SET"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceType(i32);
impl PhysicalDeviceType {
    pub const OTHER: Self = Self(0);
    pub const INTEGRATED_GPU: Self = Self(1);
    pub const DISCRETE_GPU: Self = Self(2);
    pub const VIRTUAL_GPU: Self = Self(3);
    pub const CPU: Self = Self(4);
}
impl default::Default for PhysicalDeviceType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PhysicalDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OTHER"),
            1 => Some(&"INTEGRATED_GPU"),
            2 => Some(&"DISCRETE_GPU"),
            3 => Some(&"VIRTUAL_GPU"),
            4 => Some(&"CPU"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineBindPoint(i32);
impl PipelineBindPoint {
    pub const GRAPHICS: Self = Self(0);
    pub const COMPUTE: Self = Self(1);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_KHR: Self = Self(1000165000);
    pub const RAY_TRACING_NV: Self = Self::RAY_TRACING_KHR;
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(1000369003);
}
impl default::Default for PipelineBindPoint {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PipelineBindPoint {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GRAPHICS"),
            1 => Some(&"COMPUTE"),
            1000165000 => Some(&"RAY_TRACING_KHR"),
            1000369003 => Some(&"SUBPASS_SHADING_HUAWEI"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PrimitiveTopology(i32);
impl PrimitiveTopology {
    pub const POINT_LIST: Self = Self(0);
    pub const LINE_LIST: Self = Self(1);
    pub const LINE_STRIP: Self = Self(2);
    pub const TRIANGLE_LIST: Self = Self(3);
    pub const TRIANGLE_STRIP: Self = Self(4);
    pub const TRIANGLE_FAN: Self = Self(5);
    pub const LINE_LIST_WITH_ADJACENCY: Self = Self(6);
    pub const LINE_STRIP_WITH_ADJACENCY: Self = Self(7);
    pub const TRIANGLE_LIST_WITH_ADJACENCY: Self = Self(8);
    pub const TRIANGLE_STRIP_WITH_ADJACENCY: Self = Self(9);
    pub const PATCH_LIST: Self = Self(10);
}
impl default::Default for PrimitiveTopology {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PrimitiveTopology {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"POINT_LIST"),
            1 => Some(&"LINE_LIST"),
            2 => Some(&"LINE_STRIP"),
            3 => Some(&"TRIANGLE_LIST"),
            4 => Some(&"TRIANGLE_STRIP"),
            5 => Some(&"TRIANGLE_FAN"),
            6 => Some(&"LINE_LIST_WITH_ADJACENCY"),
            7 => Some(&"LINE_STRIP_WITH_ADJACENCY"),
            8 => Some(&"TRIANGLE_LIST_WITH_ADJACENCY"),
            9 => Some(&"TRIANGLE_STRIP_WITH_ADJACENCY"),
            10 => Some(&"PATCH_LIST"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueryType(i32);
impl QueryType {
    pub const OCCLUSION: Self = Self(0);
    /// Optional
    pub const PIPELINE_STATISTICS: Self = Self(1);
    pub const TIMESTAMP: Self = Self(2);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_STREAM_EXT: Self = Self(1000028004);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_QUERY_KHR: Self = Self(1000116000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR: Self = Self(1000150000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR: Self = Self(1000150001);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: Self = Self(1000165000);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_QUERY_INTEL: Self = Self(1000210000);
}
impl default::Default for QueryType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for QueryType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OCCLUSION"),
            1 => Some(&"PIPELINE_STATISTICS"),
            2 => Some(&"TIMESTAMP"),
            1000028004 => Some(&"TRANSFORM_FEEDBACK_STREAM_EXT"),
            1000116000 => Some(&"PERFORMANCE_QUERY_KHR"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"),
            1000150001 => Some(&"ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"),
            1000210000 => Some(&"PERFORMANCE_QUERY_INTEL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SubpassContents(i32);
impl SubpassContents {
    pub const INLINE: Self = Self(0);
    pub const SECONDARY_COMMAND_BUFFERS: Self = Self(1);
}
impl default::Default for SubpassContents {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SubpassContents {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INLINE"),
            1 => Some(&"SECONDARY_COMMAND_BUFFERS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Result(i32);
impl Result {
    /// Command completed successfully
    pub const SUCCESS: Self = Self(0);
    /// A fence or query has not yet completed
    pub const NOT_READY: Self = Self(1);
    /// A wait operation has not completed in the specified time
    pub const TIMEOUT: Self = Self(2);
    /// An event is signaled
    pub const EVENT_SET: Self = Self(3);
    /// An event is unsignaled
    pub const EVENT_RESET: Self = Self(4);
    /// A return array was too small for the result
    pub const INCOMPLETE: Self = Self(5);
    /// A host memory allocation has failed
    pub const ERROR_OUT_OF_HOST_MEMORY: Self = Self(-1);
    /// A device memory allocation has failed
    pub const ERROR_OUT_OF_DEVICE_MEMORY: Self = Self(-2);
    /// Initialization of a object has failed
    pub const ERROR_INITIALIZATION_FAILED: Self = Self(-3);
    /// The logical device has been lost. See <<devsandqueues-lost-device>>
    pub const ERROR_DEVICE_LOST: Self = Self(-4);
    /// Mapping of a memory object has failed
    pub const ERROR_MEMORY_MAP_FAILED: Self = Self(-5);
    /// Layer specified does not exist
    pub const ERROR_LAYER_NOT_PRESENT: Self = Self(-6);
    /// Extension specified does not exist
    pub const ERROR_EXTENSION_NOT_PRESENT: Self = Self(-7);
    /// Requested feature is not available on this device
    pub const ERROR_FEATURE_NOT_PRESENT: Self = Self(-8);
    /// Unable to find a Vulkan driver
    pub const ERROR_INCOMPATIBLE_DRIVER: Self = Self(-9);
    /// Too many objects of the type have already been created
    pub const ERROR_TOO_MANY_OBJECTS: Self = Self(-10);
    /// Requested format is not supported on this device
    pub const ERROR_FORMAT_NOT_SUPPORTED: Self = Self(-11);
    /// A requested pool allocation has failed due to fragmentation of the pool's memory
    pub const ERROR_FRAGMENTED_POOL: Self = Self(-12);
    /// An unknown error has occurred, due to an implementation or application bug
    pub const ERROR_UNKNOWN: Self = Self(-13);
    pub const ERROR_OUT_OF_POOL_MEMORY: Self = Self(-1000069000);
    pub const ERROR_INVALID_EXTERNAL_HANDLE: Self = Self(-1000072003);
    pub const ERROR_FRAGMENTATION: Self = Self(-1000161000);
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: Self = Self(-1000257000);
    /// Added by extension VK_KHR_surface.
    pub const ERROR_SURFACE_LOST_KHR: Self = Self(-1000000000);
    /// Added by extension VK_KHR_surface.
    pub const ERROR_NATIVE_WINDOW_IN_USE_KHR: Self = Self(-1000000001);
    /// Added by extension VK_KHR_swapchain.
    pub const SUBOPTIMAL_KHR: Self = Self(1000001003);
    /// Added by extension VK_KHR_swapchain.
    pub const ERROR_OUT_OF_DATE_KHR: Self = Self(-1000001004);
    /// Added by extension VK_KHR_display_swapchain.
    pub const ERROR_INCOMPATIBLE_DISPLAY_KHR: Self = Self(-1000003001);
    /// Added by extension VK_EXT_debug_report.
    pub const ERROR_VALIDATION_FAILED_EXT: Self = Self(-1000011001);
    /// Added by extension VK_NV_glsl_shader.
    pub const ERROR_INVALID_SHADER_NV: Self = Self(-1000012000);
    pub const ERROR_OUT_OF_POOL_MEMORY_KHR: Self = Self::ERROR_OUT_OF_POOL_MEMORY;
    pub const ERROR_INVALID_EXTERNAL_HANDLE_KHR: Self = Self::ERROR_INVALID_EXTERNAL_HANDLE;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: Self = Self(-1000158000);
    pub const ERROR_FRAGMENTATION_EXT: Self = Self::ERROR_FRAGMENTATION;
    /// Added by extension VK_EXT_global_priority.
    pub const ERROR_NOT_PERMITTED_EXT: Self = Self(-1000174001);
    pub const ERROR_INVALID_DEVICE_ADDRESS_EXT: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: Self = Self(-1000255000);
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const THREAD_IDLE_KHR: Self = Self(1000268000);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const THREAD_DONE_KHR: Self = Self(1000268001);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const OPERATION_DEFERRED_KHR: Self = Self(1000268002);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const OPERATION_NOT_DEFERRED_KHR: Self = Self(1000268003);
    /// Added by extension VK_EXT_pipeline_creation_cache_control.
    pub const PIPELINE_COMPILE_REQUIRED_EXT: Self = Self(1000297000);
    pub const ERROR_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::PIPELINE_COMPILE_REQUIRED_EXT;
}
impl default::Default for Result {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for Result {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SUCCESS"),
            1 => Some(&"NOT_READY"),
            2 => Some(&"TIMEOUT"),
            3 => Some(&"EVENT_SET"),
            4 => Some(&"EVENT_RESET"),
            5 => Some(&"INCOMPLETE"),
            -1 => Some(&"ERROR_OUT_OF_HOST_MEMORY"),
            -2 => Some(&"ERROR_OUT_OF_DEVICE_MEMORY"),
            -3 => Some(&"ERROR_INITIALIZATION_FAILED"),
            -4 => Some(&"ERROR_DEVICE_LOST"),
            -5 => Some(&"ERROR_MEMORY_MAP_FAILED"),
            -6 => Some(&"ERROR_LAYER_NOT_PRESENT"),
            -7 => Some(&"ERROR_EXTENSION_NOT_PRESENT"),
            -8 => Some(&"ERROR_FEATURE_NOT_PRESENT"),
            -9 => Some(&"ERROR_INCOMPATIBLE_DRIVER"),
            -10 => Some(&"ERROR_TOO_MANY_OBJECTS"),
            -11 => Some(&"ERROR_FORMAT_NOT_SUPPORTED"),
            -12 => Some(&"ERROR_FRAGMENTED_POOL"),
            -13 => Some(&"ERROR_UNKNOWN"),
            -1000069000 => Some(&"ERROR_OUT_OF_POOL_MEMORY"),
            -1000072003 => Some(&"ERROR_INVALID_EXTERNAL_HANDLE"),
            -1000161000 => Some(&"ERROR_FRAGMENTATION"),
            -1000257000 => Some(&"ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"),
            -1000000000 => Some(&"ERROR_SURFACE_LOST_KHR"),
            -1000000001 => Some(&"ERROR_NATIVE_WINDOW_IN_USE_KHR"),
            1000001003 => Some(&"SUBOPTIMAL_KHR"),
            -1000001004 => Some(&"ERROR_OUT_OF_DATE_KHR"),
            -1000003001 => Some(&"ERROR_INCOMPATIBLE_DISPLAY_KHR"),
            -1000011001 => Some(&"ERROR_VALIDATION_FAILED_EXT"),
            -1000012000 => Some(&"ERROR_INVALID_SHADER_NV"),
            -1000158000 => Some(&"ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"),
            -1000174001 => Some(&"ERROR_NOT_PERMITTED_EXT"),
            -1000255000 => Some(&"ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"),
            1000268000 => Some(&"THREAD_IDLE_KHR"),
            1000268001 => Some(&"THREAD_DONE_KHR"),
            1000268002 => Some(&"OPERATION_DEFERRED_KHR"),
            1000268003 => Some(&"OPERATION_NOT_DEFERRED_KHR"),
            1000297000 => Some(&"PIPELINE_COMPILE_REQUIRED_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct StencilOp(i32);
impl StencilOp {
    pub const KEEP: Self = Self(0);
    pub const ZERO: Self = Self(1);
    pub const REPLACE: Self = Self(2);
    pub const INCREMENT_AND_CLAMP: Self = Self(3);
    pub const DECREMENT_AND_CLAMP: Self = Self(4);
    pub const INVERT: Self = Self(5);
    pub const INCREMENT_AND_WRAP: Self = Self(6);
    pub const DECREMENT_AND_WRAP: Self = Self(7);
}
impl default::Default for StencilOp {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for StencilOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"KEEP"),
            1 => Some(&"ZERO"),
            2 => Some(&"REPLACE"),
            3 => Some(&"INCREMENT_AND_CLAMP"),
            4 => Some(&"DECREMENT_AND_CLAMP"),
            5 => Some(&"INVERT"),
            6 => Some(&"INCREMENT_AND_WRAP"),
            7 => Some(&"DECREMENT_AND_WRAP"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct StructureType(i32);
impl StructureType {
    pub const APPLICATION_INFO: Self = Self(0);
    pub const INSTANCE_CREATE_INFO: Self = Self(1);
    pub const DEVICE_QUEUE_CREATE_INFO: Self = Self(2);
    pub const DEVICE_CREATE_INFO: Self = Self(3);
    pub const SUBMIT_INFO: Self = Self(4);
    pub const MEMORY_ALLOCATE_INFO: Self = Self(5);
    pub const MAPPED_MEMORY_RANGE: Self = Self(6);
    pub const BIND_SPARSE_INFO: Self = Self(7);
    pub const FENCE_CREATE_INFO: Self = Self(8);
    pub const SEMAPHORE_CREATE_INFO: Self = Self(9);
    pub const EVENT_CREATE_INFO: Self = Self(10);
    pub const QUERY_POOL_CREATE_INFO: Self = Self(11);
    pub const BUFFER_CREATE_INFO: Self = Self(12);
    pub const BUFFER_VIEW_CREATE_INFO: Self = Self(13);
    pub const IMAGE_CREATE_INFO: Self = Self(14);
    pub const IMAGE_VIEW_CREATE_INFO: Self = Self(15);
    pub const SHADER_MODULE_CREATE_INFO: Self = Self(16);
    pub const PIPELINE_CACHE_CREATE_INFO: Self = Self(17);
    pub const PIPELINE_SHADER_STAGE_CREATE_INFO: Self = Self(18);
    pub const PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: Self = Self(19);
    pub const PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: Self = Self(20);
    pub const PIPELINE_TESSELLATION_STATE_CREATE_INFO: Self = Self(21);
    pub const PIPELINE_VIEWPORT_STATE_CREATE_INFO: Self = Self(22);
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_INFO: Self = Self(23);
    pub const PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: Self = Self(24);
    pub const PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: Self = Self(25);
    pub const PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: Self = Self(26);
    pub const PIPELINE_DYNAMIC_STATE_CREATE_INFO: Self = Self(27);
    pub const GRAPHICS_PIPELINE_CREATE_INFO: Self = Self(28);
    pub const COMPUTE_PIPELINE_CREATE_INFO: Self = Self(29);
    pub const PIPELINE_LAYOUT_CREATE_INFO: Self = Self(30);
    pub const SAMPLER_CREATE_INFO: Self = Self(31);
    pub const DESCRIPTOR_SET_LAYOUT_CREATE_INFO: Self = Self(32);
    pub const DESCRIPTOR_POOL_CREATE_INFO: Self = Self(33);
    pub const DESCRIPTOR_SET_ALLOCATE_INFO: Self = Self(34);
    pub const WRITE_DESCRIPTOR_SET: Self = Self(35);
    pub const COPY_DESCRIPTOR_SET: Self = Self(36);
    pub const FRAMEBUFFER_CREATE_INFO: Self = Self(37);
    pub const RENDER_PASS_CREATE_INFO: Self = Self(38);
    pub const COMMAND_POOL_CREATE_INFO: Self = Self(39);
    pub const COMMAND_BUFFER_ALLOCATE_INFO: Self = Self(40);
    pub const COMMAND_BUFFER_INHERITANCE_INFO: Self = Self(41);
    pub const COMMAND_BUFFER_BEGIN_INFO: Self = Self(42);
    pub const RENDER_PASS_BEGIN_INFO: Self = Self(43);
    pub const BUFFER_MEMORY_BARRIER: Self = Self(44);
    pub const IMAGE_MEMORY_BARRIER: Self = Self(45);
    pub const MEMORY_BARRIER: Self = Self(46);
    /// Reserved for internal use by the loader, layers, and ICDs
    pub const LOADER_INSTANCE_CREATE_INFO: Self = Self(47);
    /// Reserved for internal use by the loader, layers, and ICDs
    pub const LOADER_DEVICE_CREATE_INFO: Self = Self(48);
    pub const PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: Self = Self(1000094000);
    pub const BIND_BUFFER_MEMORY_INFO: Self = Self(1000157000);
    pub const BIND_IMAGE_MEMORY_INFO: Self = Self(1000157001);
    pub const PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: Self = Self(1000083000);
    pub const MEMORY_DEDICATED_REQUIREMENTS: Self = Self(1000127000);
    pub const MEMORY_DEDICATED_ALLOCATE_INFO: Self = Self(1000127001);
    pub const MEMORY_ALLOCATE_FLAGS_INFO: Self = Self(1000060000);
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: Self = Self(1000060003);
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: Self = Self(1000060004);
    pub const DEVICE_GROUP_SUBMIT_INFO: Self = Self(1000060005);
    pub const DEVICE_GROUP_BIND_SPARSE_INFO: Self = Self(1000060006);
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060013);
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060014);
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES: Self = Self(1000070000);
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO: Self = Self(1000070001);
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146000);
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146001);
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146002);
    pub const MEMORY_REQUIREMENTS_2: Self = Self(1000146003);
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: Self = Self(1000146004);
    pub const PHYSICAL_DEVICE_FEATURES_2: Self = Self(1000059000);
    pub const PHYSICAL_DEVICE_PROPERTIES_2: Self = Self(1000059001);
    pub const FORMAT_PROPERTIES_2: Self = Self(1000059002);
    pub const IMAGE_FORMAT_PROPERTIES_2: Self = Self(1000059003);
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: Self = Self(1000059004);
    pub const QUEUE_FAMILY_PROPERTIES_2: Self = Self(1000059005);
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: Self = Self(1000059006);
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES_2: Self = Self(1000059007);
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: Self = Self(1000059008);
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: Self = Self(1000117000);
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: Self = Self(1000117001);
    pub const IMAGE_VIEW_USAGE_CREATE_INFO: Self = Self(1000117002);
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: Self = Self(1000117003);
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO: Self = Self(1000053000);
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES: Self = Self(1000053001);
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: Self = Self(1000053002);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: Self = Self(1000120000);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    pub const PROTECTED_SUBMIT_INFO: Self = Self(1000145000);
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: Self = Self(1000145001);
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: Self = Self(1000145002);
    pub const DEVICE_QUEUE_INFO_2: Self = Self(1000145003);
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO: Self = Self(1000156000);
    pub const SAMPLER_YCBCR_CONVERSION_INFO: Self = Self(1000156001);
    pub const BIND_IMAGE_PLANE_MEMORY_INFO: Self = Self(1000156002);
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: Self = Self(1000156003);
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: Self = Self(1000156004);
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: Self = Self(1000156005);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: Self = Self(1000085000);
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: Self = Self(1000071000);
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES: Self = Self(1000071001);
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: Self = Self(1000071002);
    pub const EXTERNAL_BUFFER_PROPERTIES: Self = Self(1000071003);
    pub const PHYSICAL_DEVICE_ID_PROPERTIES: Self = Self(1000071004);
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO: Self = Self(1000072000);
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO: Self = Self(1000072001);
    pub const EXPORT_MEMORY_ALLOCATE_INFO: Self = Self(1000072002);
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: Self = Self(1000112000);
    pub const EXTERNAL_FENCE_PROPERTIES: Self = Self(1000112001);
    pub const EXPORT_FENCE_CREATE_INFO: Self = Self(1000113000);
    pub const EXPORT_SEMAPHORE_CREATE_INFO: Self = Self(1000077000);
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: Self = Self(1000076000);
    pub const EXTERNAL_SEMAPHORE_PROPERTIES: Self = Self(1000076001);
    pub const PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: Self = Self(1000168000);
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT: Self = Self(1000168001);
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: Self = Self(1000063000);
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: Self =
        Self::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    pub const PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: Self = Self(49);
    pub const PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: Self = Self(50);
    pub const PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: Self = Self(51);
    pub const PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: Self = Self(52);
    pub const IMAGE_FORMAT_LIST_CREATE_INFO: Self = Self(1000147000);
    pub const ATTACHMENT_DESCRIPTION_2: Self = Self(1000109000);
    pub const ATTACHMENT_REFERENCE_2: Self = Self(1000109001);
    pub const SUBPASS_DESCRIPTION_2: Self = Self(1000109002);
    pub const SUBPASS_DEPENDENCY_2: Self = Self(1000109003);
    pub const RENDER_PASS_CREATE_INFO_2: Self = Self(1000109004);
    pub const SUBPASS_BEGIN_INFO: Self = Self(1000109005);
    pub const SUBPASS_END_INFO: Self = Self(1000109006);
    pub const PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: Self = Self(1000177000);
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES: Self = Self(1000196000);
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: Self = Self(1000180000);
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: Self = Self(1000082000);
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: Self = Self(1000197000);
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: Self = Self(1000161000);
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: Self = Self(1000161001);
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: Self = Self(1000161002);
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: Self = Self(1000161003);
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: Self = Self(1000161004);
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: Self = Self(1000199000);
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: Self = Self(1000199001);
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: Self = Self(1000221000);
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO: Self = Self(1000246000);
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: Self = Self(1000130000);
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO: Self = Self(1000130001);
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: Self = Self(1000211000);
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: Self = Self(1000108000);
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: Self = Self(1000108001);
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: Self = Self(1000108002);
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO: Self = Self(1000108003);
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: Self = Self(1000253000);
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: Self = Self(1000175000);
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: Self = Self(1000241000);
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT: Self = Self(1000241001);
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: Self = Self(1000241002);
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: Self = Self(1000261000);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: Self = Self(1000207000);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: Self = Self(1000207001);
    pub const SEMAPHORE_TYPE_CREATE_INFO: Self = Self(1000207002);
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO: Self = Self(1000207003);
    pub const SEMAPHORE_WAIT_INFO: Self = Self(1000207004);
    pub const SEMAPHORE_SIGNAL_INFO: Self = Self(1000207005);
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: Self = Self(1000257000);
    pub const BUFFER_DEVICE_ADDRESS_INFO: Self = Self(1000244001);
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: Self = Self(1000257002);
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: Self = Self(1000257003);
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: Self = Self(1000257004);
    /// Added by extension VK_KHR_swapchain.
    pub const SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000001000);
    /// Added by extension VK_KHR_swapchain.
    pub const PRESENT_INFO_KHR: Self = Self(1000001001);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: Self = Self(1000060007);
    /// Added by extension VK_KHR_device_group.
    pub const IMAGE_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060008);
    /// Added by extension VK_KHR_device_group.
    pub const BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: Self = Self(1000060009);
    /// Added by extension VK_KHR_device_group.
    pub const ACQUIRE_NEXT_IMAGE_INFO_KHR: Self = Self(1000060010);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_PRESENT_INFO_KHR: Self = Self(1000060011);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060012);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_MODE_CREATE_INFO_KHR: Self = Self(1000002000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_SURFACE_CREATE_INFO_KHR: Self = Self(1000002001);
    /// Added by extension VK_KHR_display_swapchain.
    pub const DISPLAY_PRESENT_INFO_KHR: Self = Self(1000003000);
    /// Added by extension VK_KHR_xlib_surface.
    pub const XLIB_SURFACE_CREATE_INFO_KHR: Self = Self(1000004000);
    /// Added by extension VK_KHR_xcb_surface.
    pub const XCB_SURFACE_CREATE_INFO_KHR: Self = Self(1000005000);
    /// Added by extension VK_KHR_wayland_surface.
    pub const WAYLAND_SURFACE_CREATE_INFO_KHR: Self = Self(1000006000);
    /// Added by extension VK_KHR_android_surface.
    pub const ANDROID_SURFACE_CREATE_INFO_KHR: Self = Self(1000008000);
    /// Added by extension VK_KHR_win32_surface.
    pub const WIN32_SURFACE_CREATE_INFO_KHR: Self = Self(1000009000);
    /// Added by extension VK_EXT_debug_report.
    pub const DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: Self = Self(1000011000);
    pub const DEBUG_REPORT_CREATE_INFO_EXT: Self = Self::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    /// Added by extension VK_AMD_rasterization_order.
    pub const PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: Self = Self(1000018000);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_OBJECT_NAME_INFO_EXT: Self = Self(1000022000);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_OBJECT_TAG_INFO_EXT: Self = Self(1000022001);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_MARKER_INFO_EXT: Self = Self(1000022002);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: Self = Self(1000026000);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: Self = Self(1000026001);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000026002);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: Self = Self(1000028000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: Self = Self(1000028001);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: Self = Self(1000028002);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_CREATE_INFO_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_CREATE_INFO_NVX: Self = Self(1000029001);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_LAUNCH_INFO_NVX: Self = Self(1000029002);
    /// Added by extension VK_NVX_image_view_handle.
    pub const IMAGE_VIEW_HANDLE_INFO_NVX: Self = Self(1000030000);
    /// Added by extension VK_NVX_image_view_handle.
    pub const IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: Self = Self(1000030001);
    /// Added by extension VK_AMD_texture_gather_bias_lod.
    pub const TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: Self = Self(1000041000);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_INFO_KHR: Self = Self(1000044000);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_ATTACHMENT_INFO_KHR: Self = Self(1000044001);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const PIPELINE_RENDERING_CREATE_INFO_KHR: Self = Self(1000044002);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: Self = Self(1000044003);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: Self = Self(1000044004);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000044006);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: Self = Self(1000044007);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_AMD: Self = Self(1000044008);
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_NV: Self = Self::ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: Self = Self(1000044009);
    /// Added by extension VK_NV_corner_sampled_image.
    pub const PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: Self = Self(1000050000);
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: Self = Self::RENDER_PASS_MULTIVIEW_CREATE_INFO;
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    /// Added by extension VK_NV_external_memory.
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: Self = Self(1000056000);
    /// Added by extension VK_NV_external_memory.
    pub const EXPORT_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000056001);
    /// Added by extension VK_NV_external_memory_win32.
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057000);
    /// Added by extension VK_NV_external_memory_win32.
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057001);
    /// Added by extension VK_NV_win32_keyed_mutex.
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: Self = Self(1000058000);
    pub const PHYSICAL_DEVICE_FEATURES_2_KHR: Self = Self::PHYSICAL_DEVICE_FEATURES_2;
    pub const PHYSICAL_DEVICE_PROPERTIES_2_KHR: Self = Self::PHYSICAL_DEVICE_PROPERTIES_2;
    pub const FORMAT_PROPERTIES_2_KHR: Self = Self::FORMAT_PROPERTIES_2;
    pub const IMAGE_FORMAT_PROPERTIES_2_KHR: Self = Self::IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: Self = Self::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    pub const QUEUE_FAMILY_PROPERTIES_2_KHR: Self = Self::QUEUE_FAMILY_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: Self = Self::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: Self = Self::SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: Self = Self::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    pub const MEMORY_ALLOCATE_FLAGS_INFO_KHR: Self = Self::MEMORY_ALLOCATE_FLAGS_INFO;
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    pub const DEVICE_GROUP_SUBMIT_INFO_KHR: Self = Self::DEVICE_GROUP_SUBMIT_INFO;
    pub const DEVICE_GROUP_BIND_SPARSE_INFO_KHR: Self = Self::DEVICE_GROUP_BIND_SPARSE_INFO;
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    /// Added by extension VK_EXT_validation_flags.
    pub const VALIDATION_FLAGS_EXT: Self = Self(1000061000);
    /// Added by extension VK_NN_vi_surface.
    pub const VI_SURFACE_CREATE_INFO_NN: Self = Self(1000062000);
    /// Added by extension VK_EXT_texture_compression_astc_hdr.
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: Self = Self(1000066000);
    /// Added by extension VK_EXT_astc_decode_mode.
    pub const IMAGE_VIEW_ASTC_DECODE_MODE_EXT: Self = Self(1000067000);
    /// Added by extension VK_EXT_astc_decode_mode.
    pub const PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: Self = Self(1000067001);
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_GROUP_PROPERTIES;
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: Self = Self::DEVICE_GROUP_DEVICE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: Self = Self::EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    pub const EXTERNAL_BUFFER_PROPERTIES_KHR: Self = Self::EXTERNAL_BUFFER_PROPERTIES;
    pub const PHYSICAL_DEVICE_ID_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_ID_PROPERTIES;
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    pub const EXPORT_MEMORY_ALLOCATE_INFO_KHR: Self = Self::EXPORT_MEMORY_ALLOCATE_INFO;
    /// Added by extension VK_KHR_external_memory_win32.
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073000);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073001);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const MEMORY_WIN32_HANDLE_PROPERTIES_KHR: Self = Self(1000073002);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const MEMORY_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000073003);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const IMPORT_MEMORY_FD_INFO_KHR: Self = Self(1000074000);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const MEMORY_FD_PROPERTIES_KHR: Self = Self(1000074001);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const MEMORY_GET_FD_INFO_KHR: Self = Self(1000074002);
    /// Added by extension VK_KHR_win32_keyed_mutex.
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: Self = Self(1000075000);
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    pub const EXTERNAL_SEMAPHORE_PROPERTIES_KHR: Self = Self::EXTERNAL_SEMAPHORE_PROPERTIES;
    pub const EXPORT_SEMAPHORE_CREATE_INFO_KHR: Self = Self::EXPORT_SEMAPHORE_CREATE_INFO;
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078000);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078001);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const D3D12_FENCE_SUBMIT_INFO_KHR: Self = Self(1000078002);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000078003);
    /// Added by extension VK_KHR_external_semaphore_fd.
    pub const IMPORT_SEMAPHORE_FD_INFO_KHR: Self = Self(1000079000);
    /// Added by extension VK_KHR_external_semaphore_fd.
    pub const SEMAPHORE_GET_FD_INFO_KHR: Self = Self(1000079001);
    /// Added by extension VK_KHR_push_descriptor.
    pub const PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: Self = Self(1000080000);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: Self = Self(1000081000);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: Self = Self(1000081001);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_BEGIN_INFO_EXT: Self = Self(1000081002);
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    /// Added by extension VK_KHR_incremental_present.
    pub const PRESENT_REGIONS_KHR: Self = Self(1000084000);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    /// Added by extension VK_NV_clip_space_w_scaling.
    pub const PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: Self = Self(1000087000);
    /// Added by extension VK_EXT_display_surface_counter.
    pub const SURFACE_CAPABILITIES_2_EXT: Self = Self(1000090000);
    pub const SURFACE_CAPABILITIES2_EXT: Self = Self::SURFACE_CAPABILITIES_2_EXT;
    /// Added by extension VK_EXT_display_control.
    pub const DISPLAY_POWER_INFO_EXT: Self = Self(1000091000);
    /// Added by extension VK_EXT_display_control.
    pub const DEVICE_EVENT_INFO_EXT: Self = Self(1000091001);
    /// Added by extension VK_EXT_display_control.
    pub const DISPLAY_EVENT_INFO_EXT: Self = Self(1000091002);
    /// Added by extension VK_EXT_display_control.
    pub const SWAPCHAIN_COUNTER_CREATE_INFO_EXT: Self = Self(1000091003);
    /// Added by extension VK_GOOGLE_display_timing.
    pub const PRESENT_TIMES_INFO_GOOGLE: Self = Self(1000092000);
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: Self = Self(1000097000);
    /// Added by extension VK_NV_viewport_swizzle.
    pub const PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: Self = Self(1000098000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: Self = Self(1000099000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: Self = Self(1000099001);
    /// Added by extension VK_EXT_conservative_rasterization.
    pub const PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000101000);
    /// Added by extension VK_EXT_conservative_rasterization.
    pub const PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: Self = Self(1000101001);
    /// Added by extension VK_EXT_depth_clip_enable.
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: Self = Self(1000102000);
    /// Added by extension VK_EXT_depth_clip_enable.
    pub const PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: Self = Self(1000102001);
    /// Added by extension VK_EXT_hdr_metadata.
    pub const HDR_METADATA_EXT: Self = Self(1000105000);
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: Self = Self::RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    pub const ATTACHMENT_DESCRIPTION_2_KHR: Self = Self::ATTACHMENT_DESCRIPTION_2;
    pub const ATTACHMENT_REFERENCE_2_KHR: Self = Self::ATTACHMENT_REFERENCE_2;
    pub const SUBPASS_DESCRIPTION_2_KHR: Self = Self::SUBPASS_DESCRIPTION_2;
    pub const SUBPASS_DEPENDENCY_2_KHR: Self = Self::SUBPASS_DEPENDENCY_2;
    pub const RENDER_PASS_CREATE_INFO_2_KHR: Self = Self::RENDER_PASS_CREATE_INFO_2;
    pub const SUBPASS_BEGIN_INFO_KHR: Self = Self::SUBPASS_BEGIN_INFO;
    pub const SUBPASS_END_INFO_KHR: Self = Self::SUBPASS_END_INFO;
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: Self = Self(1000111000);
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    pub const EXTERNAL_FENCE_PROPERTIES_KHR: Self = Self::EXTERNAL_FENCE_PROPERTIES;
    pub const EXPORT_FENCE_CREATE_INFO_KHR: Self = Self::EXPORT_FENCE_CREATE_INFO;
    /// Added by extension VK_KHR_external_fence_win32.
    pub const IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114000);
    /// Added by extension VK_KHR_external_fence_win32.
    pub const EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114001);
    /// Added by extension VK_KHR_external_fence_win32.
    pub const FENCE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000114002);
    /// Added by extension VK_KHR_external_fence_fd.
    pub const IMPORT_FENCE_FD_INFO_KHR: Self = Self(1000115000);
    /// Added by extension VK_KHR_external_fence_fd.
    pub const FENCE_GET_FD_INFO_KHR: Self = Self(1000115001);
    /// Added by extension VK_KHR_performance_query.
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: Self = Self(1000116000);
    /// Added by extension VK_KHR_performance_query.
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: Self = Self(1000116001);
    /// Added by extension VK_KHR_performance_query.
    pub const QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: Self = Self(1000116002);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_QUERY_SUBMIT_INFO_KHR: Self = Self(1000116003);
    /// Added by extension VK_KHR_performance_query.
    pub const ACQUIRE_PROFILING_LOCK_INFO_KHR: Self = Self(1000116004);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_COUNTER_KHR: Self = Self(1000116005);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_COUNTER_DESCRIPTION_KHR: Self = Self(1000116006);
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: Self =
        Self::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    pub const IMAGE_VIEW_USAGE_CREATE_INFO_KHR: Self = Self::IMAGE_VIEW_USAGE_CREATE_INFO;
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: Self =
        Self::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: Self = Self(1000119000);
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const SURFACE_CAPABILITIES_2_KHR: Self = Self(1000119001);
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const SURFACE_FORMAT_2_KHR: Self = Self(1000119002);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PROPERTIES_2_KHR: Self = Self(1000121000);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_PROPERTIES_2_KHR: Self = Self(1000121001);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_MODE_PROPERTIES_2_KHR: Self = Self(1000121002);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_INFO_2_KHR: Self = Self(1000121003);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_CAPABILITIES_2_KHR: Self = Self(1000121004);
    /// Added by extension VK_MVK_ios_surface.
    pub const IOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000122000);
    /// Added by extension VK_MVK_macos_surface.
    pub const MACOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000123000);
    pub const MEMORY_DEDICATED_REQUIREMENTS_KHR: Self = Self::MEMORY_DEDICATED_REQUIREMENTS;
    pub const MEMORY_DEDICATED_ALLOCATE_INFO_KHR: Self = Self::MEMORY_DEDICATED_ALLOCATE_INFO;
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_OBJECT_NAME_INFO_EXT: Self = Self(1000128000);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_OBJECT_TAG_INFO_EXT: Self = Self(1000128001);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_LABEL_EXT: Self = Self(1000128002);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: Self = Self(1000128003);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: Self = Self(1000128004);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: Self = Self(1000129000);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: Self = Self(1000129001);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: Self = Self(1000129002);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129003);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129004);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const EXTERNAL_FORMAT_ANDROID: Self = Self(1000129005);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID: Self = Self(1000129006);
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: Self = Self::SAMPLER_REDUCTION_MODE_CREATE_INFO;
    /// Added by extension VK_EXT_inline_uniform_block.
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: Self = Self(1000138000);
    /// Added by extension VK_EXT_inline_uniform_block.
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: Self = Self(1000138001);
    /// Added by extension VK_EXT_inline_uniform_block.
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: Self = Self(1000138002);
    /// Added by extension VK_EXT_inline_uniform_block.
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: Self = Self(1000138003);
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_INFO_EXT: Self = Self(1000143000);
    /// Added by extension VK_EXT_sample_locations.
    pub const RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: Self = Self(1000143001);
    /// Added by extension VK_EXT_sample_locations.
    pub const PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: Self = Self(1000143002);
    /// Added by extension VK_EXT_sample_locations.
    pub const PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: Self = Self(1000143003);
    /// Added by extension VK_EXT_sample_locations.
    pub const MULTISAMPLE_PROPERTIES_EXT: Self = Self(1000143004);
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    pub const MEMORY_REQUIREMENTS_2_KHR: Self = Self::MEMORY_REQUIREMENTS_2;
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: Self = Self::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    pub const IMAGE_FORMAT_LIST_CREATE_INFO_KHR: Self = Self::IMAGE_FORMAT_LIST_CREATE_INFO;
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: Self = Self(1000148000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: Self = Self(1000148001);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: Self = Self(1000148002);
    /// Added by extension VK_NV_fragment_coverage_to_color.
    pub const PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: Self = Self(1000149000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: Self = Self(1000150007);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: Self = Self(1000150000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: Self = Self(1000150002);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: Self = Self(1000150003);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: Self = Self(1000150004);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: Self = Self(1000150005);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_KHR: Self = Self(1000150006);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERSION_INFO_KHR: Self = Self(1000150009);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150010);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: Self = Self(1000150011);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150012);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: Self = Self(1000150013);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: Self = Self(1000150014);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_KHR: Self = Self(1000150017);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: Self = Self(1000150020);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: Self = Self(1000347000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: Self = Self(1000347001);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_KHR: Self = Self(1000150015);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: Self = Self(1000150016);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: Self = Self(1000150018);
    /// Added by extension VK_KHR_ray_query.
    pub const PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: Self = Self(1000348013);
    /// Added by extension VK_NV_framebuffer_mixed_samples.
    pub const PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: Self = Self(1000152000);
    /// Added by extension VK_NV_shader_sm_builtins.
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: Self = Self(1000154000);
    /// Added by extension VK_NV_shader_sm_builtins.
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: Self = Self(1000154001);
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    pub const SAMPLER_YCBCR_CONVERSION_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_INFO;
    pub const BIND_IMAGE_PLANE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_PLANE_MEMORY_INFO;
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: Self = Self::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: Self =
        Self::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    pub const BIND_BUFFER_MEMORY_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_INFO;
    pub const BIND_IMAGE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_INFO;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: Self = Self(1000158000);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: Self = Self(1000158002);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: Self = Self(1000158003);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: Self = Self(1000158004);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: Self = Self(1000158005);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT: Self = Self(1000158006);
    /// Added by extension VK_EXT_validation_cache.
    pub const VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160000);
    /// Added by extension VK_EXT_validation_cache.
    pub const SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160001);
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    /// Added by extension VK_KHR_portability_subset.
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: Self = Self(1000163000);
    /// Added by extension VK_KHR_portability_subset.
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: Self = Self(1000163001);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: Self = Self(1000164000);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: Self = Self(1000164001);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: Self = Self(1000164002);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: Self = Self(1000164005);
    /// Added by extension VK_NV_ray_tracing.
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_NV: Self = Self(1000165000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_NV: Self = Self(1000165001);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_NV: Self = Self(1000165003);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_TRIANGLES_NV: Self = Self(1000165004);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_AABB_NV: Self = Self(1000165005);
    /// Added by extension VK_NV_ray_tracing.
    pub const BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: Self = Self(1000165006);
    /// Added by extension VK_NV_ray_tracing.
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: Self = Self(1000165007);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000165008);
    /// Added by extension VK_NV_ray_tracing.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: Self = Self(1000165009);
    /// Added by extension VK_NV_ray_tracing.
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000165011);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_INFO_NV: Self = Self(1000165012);
    /// Added by extension VK_NV_representative_fragment_test.
    pub const PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: Self = Self(1000166000);
    /// Added by extension VK_NV_representative_fragment_test.
    pub const PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: Self = Self(1000166001);
    pub const PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: Self = Self::DESCRIPTOR_SET_LAYOUT_SUPPORT;
    /// Added by extension VK_EXT_filter_cubic.
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: Self = Self(1000170000);
    /// Added by extension VK_EXT_filter_cubic.
    pub const FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: Self = Self(1000170001);
    /// Added by extension VK_EXT_global_priority.
    pub const DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: Self = Self(1000174000);
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    pub const PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
    /// Added by extension VK_EXT_external_memory_host.
    pub const IMPORT_MEMORY_HOST_POINTER_INFO_EXT: Self = Self(1000178000);
    /// Added by extension VK_EXT_external_memory_host.
    pub const MEMORY_HOST_POINTER_PROPERTIES_EXT: Self = Self(1000178001);
    /// Added by extension VK_EXT_external_memory_host.
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: Self = Self(1000178002);
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    /// Added by extension VK_KHR_shader_clock.
    pub const PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: Self = Self(1000181000);
    /// Added by extension VK_AMD_pipeline_compiler_control.
    pub const PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: Self = Self(1000183000);
    /// Added by extension VK_EXT_calibrated_timestamps.
    pub const CALIBRATED_TIMESTAMP_INFO_EXT: Self = Self(1000184000);
    /// Added by extension VK_AMD_shader_core_properties.
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: Self = Self(1000185000);
    /// Added by extension VK_AMD_memory_overallocation_behavior.
    pub const DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: Self = Self(1000189000);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: Self = Self(1000190000);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: Self = Self(1000190001);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: Self = Self(1000190002);
    /// Added by extension VK_EXT_pipeline_creation_feedback.
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: Self = Self(1000192000);
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: Self = Self::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    /// Added by extension VK_NV_compute_shader_derivatives.
    pub const PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: Self = Self(1000201000);
    /// Added by extension VK_NV_mesh_shader.
    pub const PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: Self = Self(1000202000);
    /// Added by extension VK_NV_mesh_shader.
    pub const PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: Self = Self(1000202001);
    /// Added by extension VK_NV_fragment_shader_barycentric.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: Self = Self(1000203000);
    /// Added by extension VK_NV_shader_image_footprint.
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: Self = Self(1000204000);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: Self = Self(1000205000);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: Self = Self(1000205002);
    /// Added by extension VK_NV_device_diagnostic_checkpoints.
    pub const CHECKPOINT_DATA_NV: Self = Self(1000206000);
    /// Added by extension VK_NV_device_diagnostic_checkpoints.
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: Self = Self(1000206001);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    pub const SEMAPHORE_TYPE_CREATE_INFO_KHR: Self = Self::SEMAPHORE_TYPE_CREATE_INFO;
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: Self = Self::TIMELINE_SEMAPHORE_SUBMIT_INFO;
    pub const SEMAPHORE_WAIT_INFO_KHR: Self = Self::SEMAPHORE_WAIT_INFO;
    pub const SEMAPHORE_SIGNAL_INFO_KHR: Self = Self::SEMAPHORE_SIGNAL_INFO;
    /// Added by extension VK_INTEL_shader_integer_functions2.
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: Self = Self(1000209000);
    /// Added by extension VK_INTEL_performance_query.
    pub const QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: Self = Self(1000210000);
    pub const QUERY_POOL_CREATE_INFO_INTEL: Self = Self::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
    /// Added by extension VK_INTEL_performance_query.
    pub const INITIALIZE_PERFORMANCE_API_INFO_INTEL: Self = Self(1000210001);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_MARKER_INFO_INTEL: Self = Self(1000210002);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_STREAM_MARKER_INFO_INTEL: Self = Self(1000210003);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_OVERRIDE_INFO_INTEL: Self = Self(1000210004);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: Self = Self(1000210005);
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    /// Added by extension VK_EXT_pci_bus_info.
    pub const PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: Self = Self(1000212000);
    /// Added by extension VK_AMD_display_native_hdr.
    pub const DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: Self = Self(1000213000);
    /// Added by extension VK_AMD_display_native_hdr.
    pub const SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: Self = Self(1000213001);
    /// Added by extension VK_FUCHSIA_imagepipe_surface.
    pub const IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: Self = Self(1000214000);
    /// Added by extension VK_KHR_shader_terminate_invocation.
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: Self = Self(1000215000);
    /// Added by extension VK_EXT_metal_surface.
    pub const METAL_SURFACE_CREATE_INFO_EXT: Self = Self(1000217000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: Self = Self(1000218000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: Self = Self(1000218001);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: Self = Self(1000218002);
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    /// Added by extension VK_EXT_subgroup_size_control.
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: Self = Self(1000225000);
    /// Added by extension VK_EXT_subgroup_size_control.
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: Self = Self(1000225001);
    /// Added by extension VK_EXT_subgroup_size_control.
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: Self = Self(1000225002);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000226000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: Self = Self(1000226001);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: Self = Self(1000226002);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: Self = Self(1000226003);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226004);
    /// Added by extension VK_AMD_shader_core_properties2.
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: Self = Self(1000227000);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: Self = Self(1000229000);
    /// Added by extension VK_EXT_shader_image_atomic_int64.
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: Self = Self(1000234000);
    /// Added by extension VK_EXT_memory_budget.
    pub const PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: Self = Self(1000237000);
    /// Added by extension VK_EXT_memory_priority.
    pub const PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: Self = Self(1000238000);
    /// Added by extension VK_EXT_memory_priority.
    pub const MEMORY_PRIORITY_ALLOCATE_INFO_EXT: Self = Self(1000238001);
    /// Added by extension VK_KHR_surface_protected_capabilities.
    pub const SURFACE_PROTECTED_CAPABILITIES_KHR: Self = Self(1000239000);
    /// Added by extension VK_NV_dedicated_allocation_image_aliasing.
    pub const PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: Self = Self(1000240000);
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    /// Added by extension VK_EXT_buffer_device_address.
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: Self = Self(1000244000);
    pub const PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    pub const BUFFER_DEVICE_ADDRESS_INFO_EXT: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    /// Added by extension VK_EXT_buffer_device_address.
    pub const BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: Self = Self(1000244002);
    /// Added by extension VK_EXT_tooling_info.
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: Self = Self(1000245000);
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: Self = Self::IMAGE_STENCIL_USAGE_CREATE_INFO;
    /// Added by extension VK_EXT_validation_features.
    pub const VALIDATION_FEATURES_EXT: Self = Self(1000247000);
    /// Added by extension VK_KHR_present_wait.
    pub const PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: Self = Self(1000248000);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: Self = Self(1000249000);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249001);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249002);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: Self = Self(1000250000);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: Self = Self(1000250001);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: Self = Self(1000250002);
    /// Added by extension VK_EXT_fragment_shader_interlock.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: Self = Self(1000251000);
    /// Added by extension VK_EXT_ycbcr_image_arrays.
    pub const PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: Self = Self(1000252000);
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: Self = Self(1000254000);
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: Self = Self(1000254001);
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: Self = Self(1000254002);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: Self = Self(1000255000);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: Self = Self(1000255002);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: Self = Self(1000255001);
    /// Added by extension VK_EXT_headless_surface.
    pub const HEADLESS_SURFACE_CREATE_INFO_EXT: Self = Self(1000256000);
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    pub const BUFFER_DEVICE_ADDRESS_INFO_KHR: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: Self = Self::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: Self = Self::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: Self = Self::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    /// Added by extension VK_EXT_line_rasterization.
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: Self = Self(1000259000);
    /// Added by extension VK_EXT_line_rasterization.
    pub const PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: Self = Self(1000259001);
    /// Added by extension VK_EXT_line_rasterization.
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000259002);
    /// Added by extension VK_EXT_shader_atomic_float.
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: Self = Self(1000260000);
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
    /// Added by extension VK_EXT_index_type_uint8.
    pub const PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: Self = Self(1000265000);
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000267000);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: Self = Self(1000269000);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_INFO_KHR: Self = Self(1000269001);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_PROPERTIES_KHR: Self = Self(1000269002);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_INFO_KHR: Self = Self(1000269003);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_STATISTIC_KHR: Self = Self(1000269004);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: Self = Self(1000269005);
    /// Added by extension VK_EXT_shader_atomic_float2.
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: Self = Self(1000273000);
    /// Added by extension VK_EXT_shader_demote_to_helper_invocation.
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: Self = Self(1000276000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: Self = Self(1000277000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000277001);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: Self = Self(1000277002);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: Self = Self(1000277003);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: Self = Self(1000277004);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GENERATED_COMMANDS_INFO_NV: Self = Self(1000277005);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000277006);
    /// Added by extension VK_NV_device_generated_commands.
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: Self = Self(1000277007);
    /// Added by extension VK_NV_inherited_viewport_scissor.
    pub const PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: Self = Self(1000278000);
    /// Added by extension VK_NV_inherited_viewport_scissor.
    pub const COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: Self = Self(1000278001);
    /// Added by extension VK_KHR_shader_integer_dot_product.
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR: Self = Self(1000280000);
    /// Added by extension VK_KHR_shader_integer_dot_product.
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR: Self = Self(1000280001);
    /// Added by extension VK_EXT_texel_buffer_alignment.
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: Self = Self(1000281000);
    /// Added by extension VK_EXT_texel_buffer_alignment.
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: Self = Self(1000281001);
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: Self = Self(1000282000);
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: Self = Self(1000282001);
    /// Added by extension VK_EXT_device_memory_report.
    pub const PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: Self = Self(1000284000);
    /// Added by extension VK_EXT_device_memory_report.
    pub const DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: Self = Self(1000284001);
    /// Added by extension VK_EXT_device_memory_report.
    pub const DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: Self = Self(1000284002);
    /// Added by extension VK_EXT_robustness2.
    pub const PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: Self = Self(1000286000);
    /// Added by extension VK_EXT_robustness2.
    pub const PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: Self = Self(1000286001);
    /// Added by extension VK_EXT_custom_border_color.
    pub const SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: Self = Self(1000287000);
    /// Added by extension VK_EXT_custom_border_color.
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: Self = Self(1000287001);
    /// Added by extension VK_EXT_custom_border_color.
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: Self = Self(1000287002);
    /// Added by extension VK_KHR_pipeline_library.
    pub const PIPELINE_LIBRARY_CREATE_INFO_KHR: Self = Self(1000290000);
    /// Added by extension VK_KHR_present_id.
    pub const PRESENT_ID_KHR: Self = Self(1000294000);
    /// Added by extension VK_KHR_present_id.
    pub const PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: Self = Self(1000294001);
    /// Added by extension VK_EXT_private_data.
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: Self = Self(1000295000);
    /// Added by extension VK_EXT_private_data.
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: Self = Self(1000295001);
    /// Added by extension VK_EXT_private_data.
    pub const PRIVATE_DATA_SLOT_CREATE_INFO_EXT: Self = Self(1000295002);
    /// Added by extension VK_EXT_pipeline_creation_cache_control.
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: Self = Self(1000297000);
    /// Added by extension VK_NV_device_diagnostics_config.
    pub const PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: Self = Self(1000300000);
    /// Added by extension VK_NV_device_diagnostics_config.
    pub const DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: Self = Self(1000300001);
    /// Added by extension VK_KHR_synchronization2.
    pub const MEMORY_BARRIER_2_KHR: Self = Self(1000314000);
    /// Added by extension VK_KHR_synchronization2.
    pub const BUFFER_MEMORY_BARRIER_2_KHR: Self = Self(1000314001);
    /// Added by extension VK_KHR_synchronization2.
    pub const IMAGE_MEMORY_BARRIER_2_KHR: Self = Self(1000314002);
    /// Added by extension VK_KHR_synchronization2.
    pub const DEPENDENCY_INFO_KHR: Self = Self(1000314003);
    /// Added by extension VK_KHR_synchronization2.
    pub const SUBMIT_INFO_2_KHR: Self = Self(1000314004);
    /// Added by extension VK_KHR_synchronization2.
    pub const SEMAPHORE_SUBMIT_INFO_KHR: Self = Self(1000314005);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_BUFFER_SUBMIT_INFO_KHR: Self = Self(1000314006);
    /// Added by extension VK_KHR_synchronization2.
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: Self = Self(1000314007);
    /// Added by extension VK_KHR_synchronization2.
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: Self = Self(1000314008);
    /// Added by extension VK_KHR_synchronization2.
    pub const CHECKPOINT_DATA_2_NV: Self = Self(1000314009);
    /// Added by extension VK_KHR_shader_subgroup_uniform_control_flow.
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: Self = Self(1000323000);
    /// Added by extension VK_KHR_zero_initialize_workgroup_memory.
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: Self = Self(1000325000);
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: Self = Self(1000326000);
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: Self = Self(1000326001);
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: Self = Self(1000326002);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: Self = Self(1000327000);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: Self = Self(1000327001);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const ACCELERATION_STRUCTURE_MOTION_INFO_NV: Self = Self(1000327002);
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: Self = Self(1000330000);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: Self = Self(1000332000);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: Self = Self(1000332001);
    /// Added by extension VK_QCOM_rotated_copy_commands.
    pub const COPY_COMMAND_TRANSFORM_INFO_QCOM: Self = Self(1000333000);
    /// Added by extension VK_EXT_image_robustness.
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: Self = Self(1000335000);
    /// Added by extension VK_KHR_workgroup_memory_explicit_layout.
    pub const PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: Self = Self(1000336000);
    /// Added by extension VK_KHR_copy_commands2.
    pub const COPY_BUFFER_INFO_2_KHR: Self = Self(1000337000);
    /// Added by extension VK_KHR_copy_commands2.
    pub const COPY_IMAGE_INFO_2_KHR: Self = Self(1000337001);
    /// Added by extension VK_KHR_copy_commands2.
    pub const COPY_BUFFER_TO_IMAGE_INFO_2_KHR: Self = Self(1000337002);
    /// Added by extension VK_KHR_copy_commands2.
    pub const COPY_IMAGE_TO_BUFFER_INFO_2_KHR: Self = Self(1000337003);
    /// Added by extension VK_KHR_copy_commands2.
    pub const BLIT_IMAGE_INFO_2_KHR: Self = Self(1000337004);
    /// Added by extension VK_KHR_copy_commands2.
    pub const RESOLVE_IMAGE_INFO_2_KHR: Self = Self(1000337005);
    /// Added by extension VK_KHR_copy_commands2.
    pub const BUFFER_COPY_2_KHR: Self = Self(1000337006);
    /// Added by extension VK_KHR_copy_commands2.
    pub const IMAGE_COPY_2_KHR: Self = Self(1000337007);
    /// Added by extension VK_KHR_copy_commands2.
    pub const IMAGE_BLIT_2_KHR: Self = Self(1000337008);
    /// Added by extension VK_KHR_copy_commands2.
    pub const BUFFER_IMAGE_COPY_2_KHR: Self = Self(1000337009);
    /// Added by extension VK_KHR_copy_commands2.
    pub const IMAGE_RESOLVE_2_KHR: Self = Self(1000337010);
    /// Added by extension VK_EXT_4444_formats.
    pub const PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: Self = Self(1000340000);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM: Self = Self(1000342000);
    /// Added by extension VK_EXT_rgba10x6_formats.
    pub const PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: Self = Self(1000344000);
    /// Added by extension VK_EXT_directfb_surface.
    pub const DIRECTFB_SURFACE_CREATE_INFO_EXT: Self = Self(1000346000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: Self = Self(1000351000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: Self = Self(1000351002);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000352000);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: Self = Self(1000352001);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: Self = Self(1000352002);
    /// Added by extension VK_EXT_physical_device_drm.
    pub const PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: Self = Self(1000353000);
    /// Added by extension VK_EXT_depth_clip_control.
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: Self = Self(1000355000);
    /// Added by extension VK_EXT_depth_clip_control.
    pub const PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: Self = Self(1000355001);
    /// Added by extension VK_EXT_primitive_topology_list_restart.
    pub const PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: Self = Self(1000356000);
    /// Added by extension VK_KHR_format_feature_flags2.
    pub const FORMAT_PROPERTIES_3_KHR: Self = Self(1000360000);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364000);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA: Self = Self(1000364001);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364002);
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365000);
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365001);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: Self = Self(1000366000);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366001);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: Self = Self(1000366002);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_PROPERTIES_FUCHSIA: Self = Self(1000366003);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366004);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: Self = Self(1000366005);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMAGE_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366006);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366007);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const SYSMEM_COLOR_SPACE_FUCHSIA: Self = Self(1000366008);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366009);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: Self = Self(1000369000);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: Self = Self(1000369001);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: Self = Self(1000369002);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: Self = Self(1000370000);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const MEMORY_GET_REMOTE_ADDRESS_INFO_NV: Self = Self(1000371000);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: Self = Self(1000371001);
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: Self = Self(1000377000);
    /// Added by extension VK_EXT_color_write_enable.
    pub const PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: Self = Self(1000381000);
    /// Added by extension VK_EXT_color_write_enable.
    pub const PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: Self = Self(1000381001);
    /// Added by extension VK_EXT_global_priority_query.
    pub const PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: Self = Self(1000388000);
    /// Added by extension VK_EXT_global_priority_query.
    pub const QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: Self = Self(1000388001);
    /// Added by extension VK_EXT_image_view_min_lod.
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: Self = Self(1000391000);
    /// Added by extension VK_EXT_image_view_min_lod.
    pub const IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: Self = Self(1000391001);
    /// Added by extension VK_EXT_multi_draw.
    pub const PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: Self = Self(1000392000);
    /// Added by extension VK_EXT_multi_draw.
    pub const PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: Self = Self(1000392001);
    /// Added by extension VK_EXT_border_color_swizzle.
    pub const PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: Self = Self(1000411000);
    /// Added by extension VK_EXT_border_color_swizzle.
    pub const SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: Self = Self(1000411001);
    /// Added by extension VK_EXT_pageable_device_local_memory.
    pub const PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: Self = Self(1000412000);
    /// Added by extension VK_KHR_maintenance4.
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR: Self = Self(1000413000);
    /// Added by extension VK_KHR_maintenance4.
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR: Self = Self(1000413001);
    /// Added by extension VK_KHR_maintenance4.
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: Self = Self(1000413002);
    /// Added by extension VK_KHR_maintenance4.
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: Self = Self(1000413003);
}
impl default::Default for StructureType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for StructureType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"APPLICATION_INFO"),
            1 => Some(&"INSTANCE_CREATE_INFO"),
            2 => Some(&"DEVICE_QUEUE_CREATE_INFO"),
            3 => Some(&"DEVICE_CREATE_INFO"),
            4 => Some(&"SUBMIT_INFO"),
            5 => Some(&"MEMORY_ALLOCATE_INFO"),
            6 => Some(&"MAPPED_MEMORY_RANGE"),
            7 => Some(&"BIND_SPARSE_INFO"),
            8 => Some(&"FENCE_CREATE_INFO"),
            9 => Some(&"SEMAPHORE_CREATE_INFO"),
            10 => Some(&"EVENT_CREATE_INFO"),
            11 => Some(&"QUERY_POOL_CREATE_INFO"),
            12 => Some(&"BUFFER_CREATE_INFO"),
            13 => Some(&"BUFFER_VIEW_CREATE_INFO"),
            14 => Some(&"IMAGE_CREATE_INFO"),
            15 => Some(&"IMAGE_VIEW_CREATE_INFO"),
            16 => Some(&"SHADER_MODULE_CREATE_INFO"),
            17 => Some(&"PIPELINE_CACHE_CREATE_INFO"),
            18 => Some(&"PIPELINE_SHADER_STAGE_CREATE_INFO"),
            19 => Some(&"PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
            20 => Some(&"PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
            21 => Some(&"PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
            22 => Some(&"PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
            23 => Some(&"PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
            24 => Some(&"PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
            25 => Some(&"PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
            26 => Some(&"PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
            27 => Some(&"PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
            28 => Some(&"GRAPHICS_PIPELINE_CREATE_INFO"),
            29 => Some(&"COMPUTE_PIPELINE_CREATE_INFO"),
            30 => Some(&"PIPELINE_LAYOUT_CREATE_INFO"),
            31 => Some(&"SAMPLER_CREATE_INFO"),
            32 => Some(&"DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
            33 => Some(&"DESCRIPTOR_POOL_CREATE_INFO"),
            34 => Some(&"DESCRIPTOR_SET_ALLOCATE_INFO"),
            35 => Some(&"WRITE_DESCRIPTOR_SET"),
            36 => Some(&"COPY_DESCRIPTOR_SET"),
            37 => Some(&"FRAMEBUFFER_CREATE_INFO"),
            38 => Some(&"RENDER_PASS_CREATE_INFO"),
            39 => Some(&"COMMAND_POOL_CREATE_INFO"),
            40 => Some(&"COMMAND_BUFFER_ALLOCATE_INFO"),
            41 => Some(&"COMMAND_BUFFER_INHERITANCE_INFO"),
            42 => Some(&"COMMAND_BUFFER_BEGIN_INFO"),
            43 => Some(&"RENDER_PASS_BEGIN_INFO"),
            44 => Some(&"BUFFER_MEMORY_BARRIER"),
            45 => Some(&"IMAGE_MEMORY_BARRIER"),
            46 => Some(&"MEMORY_BARRIER"),
            47 => Some(&"LOADER_INSTANCE_CREATE_INFO"),
            48 => Some(&"LOADER_DEVICE_CREATE_INFO"),
            1000094000 => Some(&"PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
            1000157000 => Some(&"BIND_BUFFER_MEMORY_INFO"),
            1000157001 => Some(&"BIND_IMAGE_MEMORY_INFO"),
            1000083000 => Some(&"PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"),
            1000127000 => Some(&"MEMORY_DEDICATED_REQUIREMENTS"),
            1000127001 => Some(&"MEMORY_DEDICATED_ALLOCATE_INFO"),
            1000060000 => Some(&"MEMORY_ALLOCATE_FLAGS_INFO"),
            1000060003 => Some(&"DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"),
            1000060004 => Some(&"DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"),
            1000060005 => Some(&"DEVICE_GROUP_SUBMIT_INFO"),
            1000060006 => Some(&"DEVICE_GROUP_BIND_SPARSE_INFO"),
            1000060013 => Some(&"BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"),
            1000060014 => Some(&"BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"),
            1000070000 => Some(&"PHYSICAL_DEVICE_GROUP_PROPERTIES"),
            1000070001 => Some(&"DEVICE_GROUP_DEVICE_CREATE_INFO"),
            1000146000 => Some(&"BUFFER_MEMORY_REQUIREMENTS_INFO_2"),
            1000146001 => Some(&"IMAGE_MEMORY_REQUIREMENTS_INFO_2"),
            1000146002 => Some(&"IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"),
            1000146003 => Some(&"MEMORY_REQUIREMENTS_2"),
            1000146004 => Some(&"SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"),
            1000059000 => Some(&"PHYSICAL_DEVICE_FEATURES_2"),
            1000059001 => Some(&"PHYSICAL_DEVICE_PROPERTIES_2"),
            1000059002 => Some(&"FORMAT_PROPERTIES_2"),
            1000059003 => Some(&"IMAGE_FORMAT_PROPERTIES_2"),
            1000059004 => Some(&"PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"),
            1000059005 => Some(&"QUEUE_FAMILY_PROPERTIES_2"),
            1000059006 => Some(&"PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"),
            1000059007 => Some(&"SPARSE_IMAGE_FORMAT_PROPERTIES_2"),
            1000059008 => Some(&"PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"),
            1000117000 => Some(&"PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"),
            1000117001 => Some(&"RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"),
            1000117002 => Some(&"IMAGE_VIEW_USAGE_CREATE_INFO"),
            1000117003 => Some(&"PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"),
            1000053000 => Some(&"RENDER_PASS_MULTIVIEW_CREATE_INFO"),
            1000053001 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_FEATURES"),
            1000053002 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"),
            1000120000 => Some(&"PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"),
            1000145000 => Some(&"PROTECTED_SUBMIT_INFO"),
            1000145001 => Some(&"PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"),
            1000145002 => Some(&"PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"),
            1000145003 => Some(&"DEVICE_QUEUE_INFO_2"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION_CREATE_INFO"),
            1000156001 => Some(&"SAMPLER_YCBCR_CONVERSION_INFO"),
            1000156002 => Some(&"BIND_IMAGE_PLANE_MEMORY_INFO"),
            1000156003 => Some(&"IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"),
            1000156004 => Some(&"PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"),
            1000156005 => Some(&"SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"),
            1000071000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"),
            1000071001 => Some(&"EXTERNAL_IMAGE_FORMAT_PROPERTIES"),
            1000071002 => Some(&"PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"),
            1000071003 => Some(&"EXTERNAL_BUFFER_PROPERTIES"),
            1000071004 => Some(&"PHYSICAL_DEVICE_ID_PROPERTIES"),
            1000072000 => Some(&"EXTERNAL_MEMORY_BUFFER_CREATE_INFO"),
            1000072001 => Some(&"EXTERNAL_MEMORY_IMAGE_CREATE_INFO"),
            1000072002 => Some(&"EXPORT_MEMORY_ALLOCATE_INFO"),
            1000112000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"),
            1000112001 => Some(&"EXTERNAL_FENCE_PROPERTIES"),
            1000113000 => Some(&"EXPORT_FENCE_CREATE_INFO"),
            1000077000 => Some(&"EXPORT_SEMAPHORE_CREATE_INFO"),
            1000076000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"),
            1000076001 => Some(&"EXTERNAL_SEMAPHORE_PROPERTIES"),
            1000168000 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"),
            1000168001 => Some(&"DESCRIPTOR_SET_LAYOUT_SUPPORT"),
            1000063000 => Some(&"PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"),
            49 => Some(&"PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"),
            50 => Some(&"PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"),
            51 => Some(&"PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"),
            52 => Some(&"PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"),
            1000147000 => Some(&"IMAGE_FORMAT_LIST_CREATE_INFO"),
            1000109000 => Some(&"ATTACHMENT_DESCRIPTION_2"),
            1000109001 => Some(&"ATTACHMENT_REFERENCE_2"),
            1000109002 => Some(&"SUBPASS_DESCRIPTION_2"),
            1000109003 => Some(&"SUBPASS_DEPENDENCY_2"),
            1000109004 => Some(&"RENDER_PASS_CREATE_INFO_2"),
            1000109005 => Some(&"SUBPASS_BEGIN_INFO"),
            1000109006 => Some(&"SUBPASS_END_INFO"),
            1000177000 => Some(&"PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"),
            1000196000 => Some(&"PHYSICAL_DEVICE_DRIVER_PROPERTIES"),
            1000180000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"),
            1000082000 => Some(&"PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"),
            1000197000 => Some(&"PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"),
            1000161000 => Some(&"DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"),
            1000161001 => Some(&"PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"),
            1000161002 => Some(&"PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"),
            1000161003 => Some(&"DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"),
            1000161004 => Some(&"DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"),
            1000199000 => Some(&"PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"),
            1000199001 => Some(&"SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"),
            1000221000 => Some(&"PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"),
            1000246000 => Some(&"IMAGE_STENCIL_USAGE_CREATE_INFO"),
            1000130000 => Some(&"PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"),
            1000130001 => Some(&"SAMPLER_REDUCTION_MODE_CREATE_INFO"),
            1000211000 => Some(&"PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"),
            1000108000 => Some(&"PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"),
            1000108001 => Some(&"FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"),
            1000108002 => Some(&"FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"),
            1000108003 => Some(&"RENDER_PASS_ATTACHMENT_BEGIN_INFO"),
            1000253000 => Some(&"PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"),
            1000175000 => Some(&"PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"),
            1000241000 => Some(&"PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"),
            1000241001 => Some(&"ATTACHMENT_REFERENCE_STENCIL_LAYOUT"),
            1000241002 => Some(&"ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"),
            1000261000 => Some(&"PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"),
            1000207000 => Some(&"PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"),
            1000207001 => Some(&"PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"),
            1000207002 => Some(&"SEMAPHORE_TYPE_CREATE_INFO"),
            1000207003 => Some(&"TIMELINE_SEMAPHORE_SUBMIT_INFO"),
            1000207004 => Some(&"SEMAPHORE_WAIT_INFO"),
            1000207005 => Some(&"SEMAPHORE_SIGNAL_INFO"),
            1000257000 => Some(&"PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"),
            1000244001 => Some(&"BUFFER_DEVICE_ADDRESS_INFO"),
            1000257002 => Some(&"BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"),
            1000257003 => Some(&"MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"),
            1000257004 => Some(&"DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"),
            1000001000 => Some(&"SWAPCHAIN_CREATE_INFO_KHR"),
            1000001001 => Some(&"PRESENT_INFO_KHR"),
            1000060007 => Some(&"DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
            1000060008 => Some(&"IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
            1000060009 => Some(&"BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
            1000060010 => Some(&"ACQUIRE_NEXT_IMAGE_INFO_KHR"),
            1000060011 => Some(&"DEVICE_GROUP_PRESENT_INFO_KHR"),
            1000060012 => Some(&"DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"),
            1000002000 => Some(&"DISPLAY_MODE_CREATE_INFO_KHR"),
            1000002001 => Some(&"DISPLAY_SURFACE_CREATE_INFO_KHR"),
            1000003000 => Some(&"DISPLAY_PRESENT_INFO_KHR"),
            1000004000 => Some(&"XLIB_SURFACE_CREATE_INFO_KHR"),
            1000005000 => Some(&"XCB_SURFACE_CREATE_INFO_KHR"),
            1000006000 => Some(&"WAYLAND_SURFACE_CREATE_INFO_KHR"),
            1000008000 => Some(&"ANDROID_SURFACE_CREATE_INFO_KHR"),
            1000009000 => Some(&"WIN32_SURFACE_CREATE_INFO_KHR"),
            1000011000 => Some(&"DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
            1000018000 => Some(&"PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
            1000022000 => Some(&"DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
            1000022001 => Some(&"DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
            1000022002 => Some(&"DEBUG_MARKER_MARKER_INFO_EXT"),
            1000026000 => Some(&"DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
            1000026001 => Some(&"DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
            1000026002 => Some(&"DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
            1000028000 => Some(&"PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"),
            1000028001 => Some(&"PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"),
            1000028002 => Some(&"PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"),
            1000029000 => Some(&"CU_MODULE_CREATE_INFO_NVX"),
            1000029001 => Some(&"CU_FUNCTION_CREATE_INFO_NVX"),
            1000029002 => Some(&"CU_LAUNCH_INFO_NVX"),
            1000030000 => Some(&"IMAGE_VIEW_HANDLE_INFO_NVX"),
            1000030001 => Some(&"IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"),
            1000041000 => Some(&"TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
            1000044000 => Some(&"RENDERING_INFO_KHR"),
            1000044001 => Some(&"RENDERING_ATTACHMENT_INFO_KHR"),
            1000044002 => Some(&"PIPELINE_RENDERING_CREATE_INFO_KHR"),
            1000044003 => Some(&"PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR"),
            1000044004 => Some(&"COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR"),
            1000044006 => Some(&"RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
            1000044007 => Some(&"RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"),
            1000044008 => Some(&"ATTACHMENT_SAMPLE_COUNT_INFO_AMD"),
            1000044009 => Some(&"MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"),
            1000050000 => Some(&"PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"),
            1000056000 => Some(&"EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
            1000056001 => Some(&"EXPORT_MEMORY_ALLOCATE_INFO_NV"),
            1000057000 => Some(&"IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
            1000057001 => Some(&"EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
            1000058000 => Some(&"WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
            1000061000 => Some(&"VALIDATION_FLAGS_EXT"),
            1000062000 => Some(&"VI_SURFACE_CREATE_INFO_NN"),
            1000066000 => Some(&"PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT"),
            1000067000 => Some(&"IMAGE_VIEW_ASTC_DECODE_MODE_EXT"),
            1000067001 => Some(&"PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"),
            1000073000 => Some(&"IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
            1000073001 => Some(&"EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
            1000073002 => Some(&"MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
            1000073003 => Some(&"MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
            1000074000 => Some(&"IMPORT_MEMORY_FD_INFO_KHR"),
            1000074001 => Some(&"MEMORY_FD_PROPERTIES_KHR"),
            1000074002 => Some(&"MEMORY_GET_FD_INFO_KHR"),
            1000075000 => Some(&"WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
            1000078000 => Some(&"IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
            1000078001 => Some(&"EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
            1000078002 => Some(&"D3D12_FENCE_SUBMIT_INFO_KHR"),
            1000078003 => Some(&"SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
            1000079000 => Some(&"IMPORT_SEMAPHORE_FD_INFO_KHR"),
            1000079001 => Some(&"SEMAPHORE_GET_FD_INFO_KHR"),
            1000080000 => Some(&"PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"),
            1000081000 => Some(&"COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"),
            1000081001 => Some(&"PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"),
            1000081002 => Some(&"CONDITIONAL_RENDERING_BEGIN_INFO_EXT"),
            1000084000 => Some(&"PRESENT_REGIONS_KHR"),
            1000087000 => Some(&"PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
            1000090000 => Some(&"SURFACE_CAPABILITIES_2_EXT"),
            1000091000 => Some(&"DISPLAY_POWER_INFO_EXT"),
            1000091001 => Some(&"DEVICE_EVENT_INFO_EXT"),
            1000091002 => Some(&"DISPLAY_EVENT_INFO_EXT"),
            1000091003 => Some(&"SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
            1000092000 => Some(&"PRESENT_TIMES_INFO_GOOGLE"),
            1000097000 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
            1000098000 => Some(&"PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
            1000099000 => Some(&"PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
            1000099001 => Some(&"PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
            1000101000 => Some(&"PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"),
            1000101001 => Some(&"PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"),
            1000102000 => Some(&"PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"),
            1000102001 => Some(&"PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"),
            1000105000 => Some(&"HDR_METADATA_EXT"),
            1000111000 => Some(&"SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
            1000114000 => Some(&"IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
            1000114001 => Some(&"EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
            1000114002 => Some(&"FENCE_GET_WIN32_HANDLE_INFO_KHR"),
            1000115000 => Some(&"IMPORT_FENCE_FD_INFO_KHR"),
            1000115001 => Some(&"FENCE_GET_FD_INFO_KHR"),
            1000116000 => Some(&"PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"),
            1000116001 => Some(&"PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"),
            1000116002 => Some(&"QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"),
            1000116003 => Some(&"PERFORMANCE_QUERY_SUBMIT_INFO_KHR"),
            1000116004 => Some(&"ACQUIRE_PROFILING_LOCK_INFO_KHR"),
            1000116005 => Some(&"PERFORMANCE_COUNTER_KHR"),
            1000116006 => Some(&"PERFORMANCE_COUNTER_DESCRIPTION_KHR"),
            1000119000 => Some(&"PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
            1000119001 => Some(&"SURFACE_CAPABILITIES_2_KHR"),
            1000119002 => Some(&"SURFACE_FORMAT_2_KHR"),
            1000121000 => Some(&"DISPLAY_PROPERTIES_2_KHR"),
            1000121001 => Some(&"DISPLAY_PLANE_PROPERTIES_2_KHR"),
            1000121002 => Some(&"DISPLAY_MODE_PROPERTIES_2_KHR"),
            1000121003 => Some(&"DISPLAY_PLANE_INFO_2_KHR"),
            1000121004 => Some(&"DISPLAY_PLANE_CAPABILITIES_2_KHR"),
            1000122000 => Some(&"IOS_SURFACE_CREATE_INFO_MVK"),
            1000123000 => Some(&"MACOS_SURFACE_CREATE_INFO_MVK"),
            1000128000 => Some(&"DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
            1000128001 => Some(&"DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
            1000128002 => Some(&"DEBUG_UTILS_LABEL_EXT"),
            1000128003 => Some(&"DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"),
            1000128004 => Some(&"DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
            1000129000 => Some(&"ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
            1000129001 => Some(&"ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"),
            1000129002 => Some(&"ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"),
            1000129003 => Some(&"IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
            1000129004 => Some(&"MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
            1000129005 => Some(&"EXTERNAL_FORMAT_ANDROID"),
            1000129006 => Some(&"ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"),
            1000138000 => Some(&"PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"),
            1000138001 => Some(&"PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"),
            1000138002 => Some(&"WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"),
            1000138003 => Some(&"DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"),
            1000143000 => Some(&"SAMPLE_LOCATIONS_INFO_EXT"),
            1000143001 => Some(&"RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"),
            1000143002 => Some(&"PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"),
            1000143003 => Some(&"PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"),
            1000143004 => Some(&"MULTISAMPLE_PROPERTIES_EXT"),
            1000148000 => Some(&"PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
            1000148001 => Some(&"PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
            1000148002 => Some(&"PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
            1000149000 => Some(&"PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
            1000150007 => Some(&"WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"),
            1000150002 => Some(&"ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"),
            1000150003 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"),
            1000150004 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"),
            1000150005 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"),
            1000150006 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_KHR"),
            1000150009 => Some(&"ACCELERATION_STRUCTURE_VERSION_INFO_KHR"),
            1000150010 => Some(&"COPY_ACCELERATION_STRUCTURE_INFO_KHR"),
            1000150011 => Some(&"COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"),
            1000150012 => Some(&"COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"),
            1000150013 => Some(&"PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"),
            1000150014 => Some(&"PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"),
            1000150017 => Some(&"ACCELERATION_STRUCTURE_CREATE_INFO_KHR"),
            1000150020 => Some(&"ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"),
            1000347000 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"),
            1000347001 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"),
            1000150015 => Some(&"RAY_TRACING_PIPELINE_CREATE_INFO_KHR"),
            1000150016 => Some(&"RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"),
            1000150018 => Some(&"RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"),
            1000348013 => Some(&"PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"),
            1000152000 => Some(&"PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
            1000154000 => Some(&"PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"),
            1000154001 => Some(&"PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"),
            1000158000 => Some(&"DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"),
            1000158002 => Some(&"PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"),
            1000158003 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"),
            1000158004 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"),
            1000158005 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"),
            1000158006 => Some(&"DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"),
            1000160000 => Some(&"VALIDATION_CACHE_CREATE_INFO_EXT"),
            1000160001 => Some(&"SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"),
            1000163000 => Some(&"PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"),
            1000163001 => Some(&"PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"),
            1000164000 => Some(&"PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"),
            1000164001 => Some(&"PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"),
            1000164002 => Some(&"PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"),
            1000164005 => Some(&"PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"),
            1000165000 => Some(&"RAY_TRACING_PIPELINE_CREATE_INFO_NV"),
            1000165001 => Some(&"ACCELERATION_STRUCTURE_CREATE_INFO_NV"),
            1000165003 => Some(&"GEOMETRY_NV"),
            1000165004 => Some(&"GEOMETRY_TRIANGLES_NV"),
            1000165005 => Some(&"GEOMETRY_AABB_NV"),
            1000165006 => Some(&"BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"),
            1000165007 => Some(&"WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"),
            1000165008 => Some(&"ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"),
            1000165009 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"),
            1000165011 => Some(&"RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"),
            1000165012 => Some(&"ACCELERATION_STRUCTURE_INFO_NV"),
            1000166000 => Some(&"PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"),
            1000166001 => Some(&"PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"),
            1000170000 => Some(&"PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"),
            1000170001 => Some(&"FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"),
            1000174000 => Some(&"DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"),
            1000178000 => Some(&"IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
            1000178001 => Some(&"MEMORY_HOST_POINTER_PROPERTIES_EXT"),
            1000178002 => Some(&"PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"),
            1000181000 => Some(&"PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"),
            1000183000 => Some(&"PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"),
            1000184000 => Some(&"CALIBRATED_TIMESTAMP_INFO_EXT"),
            1000185000 => Some(&"PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"),
            1000189000 => Some(&"DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"),
            1000190000 => Some(&"PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"),
            1000190001 => Some(&"PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"),
            1000190002 => Some(&"PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"),
            1000192000 => Some(&"PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"),
            1000201000 => Some(&"PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"),
            1000202000 => Some(&"PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"),
            1000202001 => Some(&"PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"),
            1000203000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"),
            1000204000 => Some(&"PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"),
            1000205000 => Some(&"PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"),
            1000205002 => Some(&"PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"),
            1000206000 => Some(&"CHECKPOINT_DATA_NV"),
            1000206001 => Some(&"QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"),
            1000209000 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"),
            1000210000 => Some(&"QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"),
            1000210001 => Some(&"INITIALIZE_PERFORMANCE_API_INFO_INTEL"),
            1000210002 => Some(&"PERFORMANCE_MARKER_INFO_INTEL"),
            1000210003 => Some(&"PERFORMANCE_STREAM_MARKER_INFO_INTEL"),
            1000210004 => Some(&"PERFORMANCE_OVERRIDE_INFO_INTEL"),
            1000210005 => Some(&"PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"),
            1000212000 => Some(&"PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"),
            1000213000 => Some(&"DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"),
            1000213001 => Some(&"SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"),
            1000214000 => Some(&"IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"),
            1000215000 => Some(&"PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR"),
            1000217000 => Some(&"METAL_SURFACE_CREATE_INFO_EXT"),
            1000218000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"),
            1000218001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"),
            1000218002 => Some(&"RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"),
            1000225000 => Some(&"PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT"),
            1000225001 => Some(&"PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT"),
            1000225002 => Some(&"PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT"),
            1000226000 => Some(&"FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
            1000226001 => Some(&"PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"),
            1000226002 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"),
            1000226003 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"),
            1000226004 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"),
            1000227000 => Some(&"PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"),
            1000229000 => Some(&"PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"),
            1000234000 => Some(&"PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"),
            1000237000 => Some(&"PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"),
            1000238000 => Some(&"PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"),
            1000238001 => Some(&"MEMORY_PRIORITY_ALLOCATE_INFO_EXT"),
            1000239000 => Some(&"SURFACE_PROTECTED_CAPABILITIES_KHR"),
            1000240000 => Some(&"PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"),
            1000244000 => Some(&"PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"),
            1000244002 => Some(&"BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"),
            1000245000 => Some(&"PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT"),
            1000247000 => Some(&"VALIDATION_FEATURES_EXT"),
            1000248000 => Some(&"PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"),
            1000249000 => Some(&"PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"),
            1000249001 => Some(&"COOPERATIVE_MATRIX_PROPERTIES_NV"),
            1000249002 => Some(&"PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
            1000250000 => Some(&"PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"),
            1000250001 => Some(&"PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"),
            1000250002 => Some(&"FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"),
            1000251000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"),
            1000252000 => Some(&"PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"),
            1000254000 => Some(&"PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"),
            1000254001 => Some(&"PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"),
            1000254002 => Some(&"PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"),
            1000255000 => Some(&"SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"),
            1000255002 => Some(&"SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"),
            1000255001 => Some(&"SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"),
            1000256000 => Some(&"HEADLESS_SURFACE_CREATE_INFO_EXT"),
            1000259000 => Some(&"PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT"),
            1000259001 => Some(&"PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT"),
            1000259002 => Some(&"PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT"),
            1000260000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"),
            1000265000 => Some(&"PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"),
            1000267000 => Some(&"PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"),
            1000269000 => Some(&"PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"),
            1000269001 => Some(&"PIPELINE_INFO_KHR"),
            1000269002 => Some(&"PIPELINE_EXECUTABLE_PROPERTIES_KHR"),
            1000269003 => Some(&"PIPELINE_EXECUTABLE_INFO_KHR"),
            1000269004 => Some(&"PIPELINE_EXECUTABLE_STATISTIC_KHR"),
            1000269005 => Some(&"PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"),
            1000273000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"),
            1000276000 => Some(&"PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"),
            1000277000 => Some(&"PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"),
            1000277001 => Some(&"GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"),
            1000277002 => Some(&"GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"),
            1000277003 => Some(&"INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"),
            1000277004 => Some(&"INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"),
            1000277005 => Some(&"GENERATED_COMMANDS_INFO_NV"),
            1000277006 => Some(&"GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"),
            1000277007 => Some(&"PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"),
            1000278000 => Some(&"PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"),
            1000278001 => Some(&"COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"),
            1000280000 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR"),
            1000280001 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR"),
            1000281000 => Some(&"PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"),
            1000281001 => Some(&"PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"),
            1000282000 => Some(&"COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"),
            1000282001 => Some(&"RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"),
            1000284000 => Some(&"PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"),
            1000284001 => Some(&"DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"),
            1000284002 => Some(&"DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"),
            1000286000 => Some(&"PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"),
            1000286001 => Some(&"PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"),
            1000287000 => Some(&"SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"),
            1000287001 => Some(&"PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"),
            1000287002 => Some(&"PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"),
            1000290000 => Some(&"PIPELINE_LIBRARY_CREATE_INFO_KHR"),
            1000294000 => Some(&"PRESENT_ID_KHR"),
            1000294001 => Some(&"PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"),
            1000295000 => Some(&"PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT"),
            1000295001 => Some(&"DEVICE_PRIVATE_DATA_CREATE_INFO_EXT"),
            1000295002 => Some(&"PRIVATE_DATA_SLOT_CREATE_INFO_EXT"),
            1000297000 => Some(&"PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT"),
            1000300000 => Some(&"PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"),
            1000300001 => Some(&"DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"),
            1000314000 => Some(&"MEMORY_BARRIER_2_KHR"),
            1000314001 => Some(&"BUFFER_MEMORY_BARRIER_2_KHR"),
            1000314002 => Some(&"IMAGE_MEMORY_BARRIER_2_KHR"),
            1000314003 => Some(&"DEPENDENCY_INFO_KHR"),
            1000314004 => Some(&"SUBMIT_INFO_2_KHR"),
            1000314005 => Some(&"SEMAPHORE_SUBMIT_INFO_KHR"),
            1000314006 => Some(&"COMMAND_BUFFER_SUBMIT_INFO_KHR"),
            1000314007 => Some(&"PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR"),
            1000314008 => Some(&"QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"),
            1000314009 => Some(&"CHECKPOINT_DATA_2_NV"),
            1000323000 => Some(&"PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"),
            1000325000 => Some(&"PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR"),
            1000326000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"),
            1000326001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"),
            1000326002 => Some(&"PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"),
            1000327000 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"),
            1000327001 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"),
            1000327002 => Some(&"ACCELERATION_STRUCTURE_MOTION_INFO_NV"),
            1000330000 => Some(&"PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"),
            1000332000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"),
            1000332001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"),
            1000333000 => Some(&"COPY_COMMAND_TRANSFORM_INFO_QCOM"),
            1000335000 => Some(&"PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT"),
            1000336000 => Some(&"PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"),
            1000337000 => Some(&"COPY_BUFFER_INFO_2_KHR"),
            1000337001 => Some(&"COPY_IMAGE_INFO_2_KHR"),
            1000337002 => Some(&"COPY_BUFFER_TO_IMAGE_INFO_2_KHR"),
            1000337003 => Some(&"COPY_IMAGE_TO_BUFFER_INFO_2_KHR"),
            1000337004 => Some(&"BLIT_IMAGE_INFO_2_KHR"),
            1000337005 => Some(&"RESOLVE_IMAGE_INFO_2_KHR"),
            1000337006 => Some(&"BUFFER_COPY_2_KHR"),
            1000337007 => Some(&"IMAGE_COPY_2_KHR"),
            1000337008 => Some(&"IMAGE_BLIT_2_KHR"),
            1000337009 => Some(&"BUFFER_IMAGE_COPY_2_KHR"),
            1000337010 => Some(&"IMAGE_RESOLVE_2_KHR"),
            1000340000 => Some(&"PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"),
            1000342000 => Some(&"PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM"),
            1000344000 => Some(&"PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"),
            1000346000 => Some(&"DIRECTFB_SURFACE_CREATE_INFO_EXT"),
            1000351000 => Some(&"PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE"),
            1000351002 => Some(&"MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE"),
            1000352000 => Some(&"PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"),
            1000352001 => Some(&"VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"),
            1000352002 => Some(&"VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"),
            1000353000 => Some(&"PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"),
            1000355000 => Some(&"PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"),
            1000355001 => Some(&"PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"),
            1000356000 => Some(&"PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"),
            1000360000 => Some(&"FORMAT_PROPERTIES_3_KHR"),
            1000364000 => Some(&"IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000364001 => Some(&"MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"),
            1000364002 => Some(&"MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000365000 => Some(&"IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000365001 => Some(&"SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000366000 => Some(&"BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"),
            1000366001 => Some(&"IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"),
            1000366002 => Some(&"BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"),
            1000366003 => Some(&"BUFFER_COLLECTION_PROPERTIES_FUCHSIA"),
            1000366004 => Some(&"BUFFER_CONSTRAINTS_INFO_FUCHSIA"),
            1000366005 => Some(&"BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"),
            1000366006 => Some(&"IMAGE_CONSTRAINTS_INFO_FUCHSIA"),
            1000366007 => Some(&"IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"),
            1000366008 => Some(&"SYSMEM_COLOR_SPACE_FUCHSIA"),
            1000366009 => Some(&"BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"),
            1000369000 => Some(&"SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"),
            1000369001 => Some(&"PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"),
            1000369002 => Some(&"PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"),
            1000370000 => Some(&"PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"),
            1000371000 => Some(&"MEMORY_GET_REMOTE_ADDRESS_INFO_NV"),
            1000371001 => Some(&"PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"),
            1000377000 => Some(&"PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"),
            1000381000 => Some(&"PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"),
            1000381001 => Some(&"PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"),
            1000388000 => Some(&"PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT"),
            1000388001 => Some(&"QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT"),
            1000391000 => Some(&"PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"),
            1000391001 => Some(&"IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"),
            1000392000 => Some(&"PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"),
            1000392001 => Some(&"PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"),
            1000411000 => Some(&"PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"),
            1000411001 => Some(&"SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"),
            1000412000 => Some(&"PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"),
            1000413000 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR"),
            1000413001 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR"),
            1000413002 => Some(&"DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR"),
            1000413003 => Some(&"DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SystemAllocationScope(i32);
impl SystemAllocationScope {
    pub const COMMAND: Self = Self(0);
    pub const OBJECT: Self = Self(1);
    pub const CACHE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const INSTANCE: Self = Self(4);
}
impl default::Default for SystemAllocationScope {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SystemAllocationScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND"),
            1 => Some(&"OBJECT"),
            2 => Some(&"CACHE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"INSTANCE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct InternalAllocationType(i32);
impl InternalAllocationType {
    pub const EXECUTABLE: Self = Self(0);
}
impl default::Default for InternalAllocationType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for InternalAllocationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"EXECUTABLE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerAddressMode(i32);
impl SamplerAddressMode {
    pub const REPEAT: Self = Self(0);
    pub const MIRRORED_REPEAT: Self = Self(1);
    pub const CLAMP_TO_EDGE: Self = Self(2);
    pub const CLAMP_TO_BORDER: Self = Self(3);
    /// No need to add an extnumber attribute, since this uses a core enum value
    /// Added by extension VK_KHR_sampler_mirror_clamp_to_edge.
    pub const MIRROR_CLAMP_TO_EDGE: Self = Self(4);
    pub const MIRROR_CLAMP_TO_EDGE_KHR: Self = Self::MIRROR_CLAMP_TO_EDGE;
}
impl default::Default for SamplerAddressMode {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SamplerAddressMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"REPEAT"),
            1 => Some(&"MIRRORED_REPEAT"),
            2 => Some(&"CLAMP_TO_EDGE"),
            3 => Some(&"CLAMP_TO_BORDER"),
            4 => Some(&"MIRROR_CLAMP_TO_EDGE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Filter(i32);
impl Filter {
    pub const NEAREST: Self = Self(0);
    pub const LINEAR: Self = Self(1);
    /// Added by extension VK_IMG_filter_cubic.
    pub const CUBIC_IMG: Self = Self(1000015000);
    pub const CUBIC_EXT: Self = Self::CUBIC_IMG;
}
impl default::Default for Filter {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for Filter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEAREST"),
            1 => Some(&"LINEAR"),
            1000015000 => Some(&"CUBIC_IMG"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerMipmapMode(i32);
impl SamplerMipmapMode {
    /// Choose nearest mip level
    pub const NEAREST: Self = Self(0);
    /// Linear filter between mip levels
    pub const LINEAR: Self = Self(1);
}
impl default::Default for SamplerMipmapMode {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SamplerMipmapMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEAREST"),
            1 => Some(&"LINEAR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct VertexInputRate(i32);
impl VertexInputRate {
    pub const VERTEX: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
}
impl default::Default for VertexInputRate {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for VertexInputRate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"VERTEX"),
            1 => Some(&"INSTANCE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ObjectType(i32);
impl ObjectType {
    pub const UNKNOWN: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
    pub const PHYSICAL_DEVICE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const QUEUE: Self = Self(4);
    pub const SEMAPHORE: Self = Self(5);
    pub const COMMAND_BUFFER: Self = Self(6);
    pub const FENCE: Self = Self(7);
    pub const DEVICE_MEMORY: Self = Self(8);
    pub const BUFFER: Self = Self(9);
    pub const IMAGE: Self = Self(10);
    pub const EVENT: Self = Self(11);
    pub const QUERY_POOL: Self = Self(12);
    pub const BUFFER_VIEW: Self = Self(13);
    pub const IMAGE_VIEW: Self = Self(14);
    pub const SHADER_MODULE: Self = Self(15);
    pub const PIPELINE_CACHE: Self = Self(16);
    pub const PIPELINE_LAYOUT: Self = Self(17);
    pub const RENDER_PASS: Self = Self(18);
    pub const PIPELINE: Self = Self(19);
    pub const DESCRIPTOR_SET_LAYOUT: Self = Self(20);
    pub const SAMPLER: Self = Self(21);
    pub const DESCRIPTOR_POOL: Self = Self(22);
    pub const DESCRIPTOR_SET: Self = Self(23);
    pub const FRAMEBUFFER: Self = Self(24);
    pub const COMMAND_POOL: Self = Self(25);
    pub const SAMPLER_YCBCR_CONVERSION: Self = Self(1000156000);
    pub const DESCRIPTOR_UPDATE_TEMPLATE: Self = Self(1000085000);
    /// Added by extension VK_KHR_surface.
    pub const SURFACE_KHR: Self = Self(1000000000);
    /// Added by extension VK_KHR_swapchain.
    pub const SWAPCHAIN_KHR: Self = Self(1000001000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_KHR: Self = Self(1000002000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_MODE_KHR: Self = Self(1000002001);
    /// Added by extension VK_EXT_debug_report.
    pub const DEBUG_REPORT_CALLBACK_EXT: Self = Self(1000011000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_NVX: Self = Self(1000029001);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE;
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_EXT: Self = Self(1000128000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    pub const SAMPLER_YCBCR_CONVERSION_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION;
    /// Added by extension VK_EXT_validation_cache.
    pub const VALIDATION_CACHE_EXT: Self = Self(1000160000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_CONFIGURATION_INTEL: Self = Self(1000210000);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const DEFERRED_OPERATION_KHR: Self = Self(1000268000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_NV: Self = Self(1000277000);
    /// Added by extension VK_EXT_private_data.
    pub const PRIVATE_DATA_SLOT_EXT: Self = Self(1000295000);
    /// VkBufferCollectionFUCHSIA
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366000);
}
impl default::Default for ObjectType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ObjectType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNKNOWN"),
            1 => Some(&"INSTANCE"),
            2 => Some(&"PHYSICAL_DEVICE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"QUEUE"),
            5 => Some(&"SEMAPHORE"),
            6 => Some(&"COMMAND_BUFFER"),
            7 => Some(&"FENCE"),
            8 => Some(&"DEVICE_MEMORY"),
            9 => Some(&"BUFFER"),
            10 => Some(&"IMAGE"),
            11 => Some(&"EVENT"),
            12 => Some(&"QUERY_POOL"),
            13 => Some(&"BUFFER_VIEW"),
            14 => Some(&"IMAGE_VIEW"),
            15 => Some(&"SHADER_MODULE"),
            16 => Some(&"PIPELINE_CACHE"),
            17 => Some(&"PIPELINE_LAYOUT"),
            18 => Some(&"RENDER_PASS"),
            19 => Some(&"PIPELINE"),
            20 => Some(&"DESCRIPTOR_SET_LAYOUT"),
            21 => Some(&"SAMPLER"),
            22 => Some(&"DESCRIPTOR_POOL"),
            23 => Some(&"DESCRIPTOR_SET"),
            24 => Some(&"FRAMEBUFFER"),
            25 => Some(&"COMMAND_POOL"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE"),
            1000000000 => Some(&"SURFACE_KHR"),
            1000001000 => Some(&"SWAPCHAIN_KHR"),
            1000002000 => Some(&"DISPLAY_KHR"),
            1000002001 => Some(&"DISPLAY_MODE_KHR"),
            1000011000 => Some(&"DEBUG_REPORT_CALLBACK_EXT"),
            1000029000 => Some(&"CU_MODULE_NVX"),
            1000029001 => Some(&"CU_FUNCTION_NVX"),
            1000128000 => Some(&"DEBUG_UTILS_MESSENGER_EXT"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000160000 => Some(&"VALIDATION_CACHE_EXT"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000210000 => Some(&"PERFORMANCE_CONFIGURATION_INTEL"),
            1000268000 => Some(&"DEFERRED_OPERATION_KHR"),
            1000277000 => Some(&"INDIRECT_COMMANDS_LAYOUT_NV"),
            1000295000 => Some(&"PRIVATE_DATA_SLOT_EXT"),
            1000366000 => Some(&"BUFFER_COLLECTION_FUCHSIA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct IndirectCommandsTokenTypeNV(i32);
impl IndirectCommandsTokenTypeNV {
    pub const SHADER_GROUP: Self = Self(0);
    pub const STATE_FLAGS: Self = Self(1);
    pub const INDEX_BUFFER: Self = Self(2);
    pub const VERTEX_BUFFER: Self = Self(3);
    pub const PUSH_CONSTANT: Self = Self(4);
    pub const DRAW_INDEXED: Self = Self(5);
    pub const DRAW: Self = Self(6);
    pub const DRAW_TASKS: Self = Self(7);
}
impl default::Default for IndirectCommandsTokenTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for IndirectCommandsTokenTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SHADER_GROUP"),
            1 => Some(&"STATE_FLAGS"),
            2 => Some(&"INDEX_BUFFER"),
            3 => Some(&"VERTEX_BUFFER"),
            4 => Some(&"PUSH_CONSTANT"),
            5 => Some(&"DRAW_INDEXED"),
            6 => Some(&"DRAW"),
            7 => Some(&"DRAW_TASKS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateType(i32);
impl DescriptorUpdateTemplateType {
    /// Create descriptor update template for descriptor set updates
    pub const DESCRIPTOR_SET: Self = Self(0);
    /// Create descriptor update template for pushed descriptor updates
    /// Added by extension VK_KHR_descriptor_update_template.
    pub const PUSH_DESCRIPTORS_KHR: Self = Self(1);
    pub const DESCRIPTOR_SET_KHR: Self = Self::DESCRIPTOR_SET;
}
impl default::Default for DescriptorUpdateTemplateType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DescriptorUpdateTemplateType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DESCRIPTOR_SET"),
            1 => Some(&"PUSH_DESCRIPTORS_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ViewportCoordinateSwizzleNV(i32);
impl ViewportCoordinateSwizzleNV {
    pub const POSITIVE_X: Self = Self(0);
    pub const NEGATIVE_X: Self = Self(1);
    pub const POSITIVE_Y: Self = Self(2);
    pub const NEGATIVE_Y: Self = Self(3);
    pub const POSITIVE_Z: Self = Self(4);
    pub const NEGATIVE_Z: Self = Self(5);
    pub const POSITIVE_W: Self = Self(6);
    pub const NEGATIVE_W: Self = Self(7);
}
impl default::Default for ViewportCoordinateSwizzleNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ViewportCoordinateSwizzleNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"POSITIVE_X"),
            1 => Some(&"NEGATIVE_X"),
            2 => Some(&"POSITIVE_Y"),
            3 => Some(&"NEGATIVE_Y"),
            4 => Some(&"POSITIVE_Z"),
            5 => Some(&"NEGATIVE_Z"),
            6 => Some(&"POSITIVE_W"),
            7 => Some(&"NEGATIVE_W"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DiscardRectangleModeEXT(i32);
impl DiscardRectangleModeEXT {
    pub const INCLUSIVE: Self = Self(0);
    pub const EXCLUSIVE: Self = Self(1);
}
impl default::Default for DiscardRectangleModeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DiscardRectangleModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INCLUSIVE"),
            1 => Some(&"EXCLUSIVE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PointClippingBehavior(i32);
impl PointClippingBehavior {
    pub const ALL_CLIP_PLANES: Self = Self(0);
    pub const USER_CLIP_PLANES_ONLY: Self = Self(1);
    pub const ALL_CLIP_PLANES_KHR: Self = Self::ALL_CLIP_PLANES;
    pub const USER_CLIP_PLANES_ONLY_KHR: Self = Self::USER_CLIP_PLANES_ONLY;
}
impl default::Default for PointClippingBehavior {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PointClippingBehavior {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL_CLIP_PLANES"),
            1 => Some(&"USER_CLIP_PLANES_ONLY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type PointClippingBehaviorKHR = PointClippingBehavior;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoverageModulationModeNV(i32);
impl CoverageModulationModeNV {
    pub const NONE: Self = Self(0);
    pub const RGB: Self = Self(1);
    pub const ALPHA: Self = Self(2);
    pub const RGBA: Self = Self(3);
}
impl default::Default for CoverageModulationModeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CoverageModulationModeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NONE"),
            1 => Some(&"RGB"),
            2 => Some(&"ALPHA"),
            3 => Some(&"RGBA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoverageReductionModeNV(i32);
impl CoverageReductionModeNV {
    pub const MERGE: Self = Self(0);
    pub const TRUNCATE: Self = Self(1);
}
impl default::Default for CoverageReductionModeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CoverageReductionModeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"MERGE"),
            1 => Some(&"TRUNCATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationCacheHeaderVersionEXT(i32);
impl ValidationCacheHeaderVersionEXT {
    pub const ONE: Self = Self(1);
}
impl default::Default for ValidationCacheHeaderVersionEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ValidationCacheHeaderVersionEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"ONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderInfoTypeAMD(i32);
impl ShaderInfoTypeAMD {
    pub const STATISTICS: Self = Self(0);
    pub const BINARY: Self = Self(1);
    pub const DISASSEMBLY: Self = Self(2);
}
impl default::Default for ShaderInfoTypeAMD {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ShaderInfoTypeAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STATISTICS"),
            1 => Some(&"BINARY"),
            2 => Some(&"DISASSEMBLY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueueGlobalPriorityEXT(i32);
impl QueueGlobalPriorityEXT {
    pub const LOW: Self = Self(128);
    pub const MEDIUM: Self = Self(256);
    pub const HIGH: Self = Self(512);
    pub const REALTIME: Self = Self(1024);
}
impl default::Default for QueueGlobalPriorityEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for QueueGlobalPriorityEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            128 => Some(&"LOW"),
            256 => Some(&"MEDIUM"),
            512 => Some(&"HIGH"),
            1024 => Some(&"REALTIME"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct TimeDomainEXT(i32);
impl TimeDomainEXT {
    pub const DEVICE: Self = Self(0);
    pub const CLOCK_MONOTONIC: Self = Self(1);
    pub const CLOCK_MONOTONIC_RAW: Self = Self(2);
    pub const QUERY_PERFORMANCE_COUNTER: Self = Self(3);
}
impl default::Default for TimeDomainEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for TimeDomainEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEVICE"),
            1 => Some(&"CLOCK_MONOTONIC"),
            2 => Some(&"CLOCK_MONOTONIC_RAW"),
            3 => Some(&"QUERY_PERFORMANCE_COUNTER"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ConservativeRasterizationModeEXT(i32);
impl ConservativeRasterizationModeEXT {
    pub const DISABLED: Self = Self(0);
    pub const OVERESTIMATE: Self = Self(1);
    pub const UNDERESTIMATE: Self = Self(2);
}
impl default::Default for ConservativeRasterizationModeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ConservativeRasterizationModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DISABLED"),
            1 => Some(&"OVERESTIMATE"),
            2 => Some(&"UNDERESTIMATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SemaphoreType(i32);
impl SemaphoreType {
    pub const BINARY: Self = Self(0);
    pub const TIMELINE: Self = Self(1);
    pub const BINARY_KHR: Self = Self::BINARY;
    pub const TIMELINE_KHR: Self = Self::TIMELINE;
}
impl default::Default for SemaphoreType {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SemaphoreType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BINARY"),
            1 => Some(&"TIMELINE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SemaphoreTypeKHR = SemaphoreType;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BuildAccelerationStructureModeKHR(i32);
impl BuildAccelerationStructureModeKHR {
    pub const BUILD: Self = Self(0);
    pub const UPDATE: Self = Self(1);
}
impl default::Default for BuildAccelerationStructureModeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for BuildAccelerationStructureModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BUILD"),
            1 => Some(&"UPDATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CopyAccelerationStructureModeKHR(i32);
impl CopyAccelerationStructureModeKHR {
    pub const CLONE: Self = Self(0);
    pub const COMPACT: Self = Self(1);
    pub const SERIALIZE: Self = Self(2);
    pub const DESERIALIZE: Self = Self(3);
    pub const CLONE_NV: Self = Self::CLONE;
    pub const COMPACT_NV: Self = Self::COMPACT;
}
impl default::Default for CopyAccelerationStructureModeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CopyAccelerationStructureModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"CLONE"),
            1 => Some(&"COMPACT"),
            2 => Some(&"SERIALIZE"),
            3 => Some(&"DESERIALIZE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureTypeKHR(i32);
impl AccelerationStructureTypeKHR {
    pub const TOP_LEVEL: Self = Self(0);
    pub const BOTTOM_LEVEL: Self = Self(1);
    pub const GENERIC: Self = Self(2);
    pub const TOP_LEVEL_NV: Self = Self::TOP_LEVEL;
    pub const BOTTOM_LEVEL_NV: Self = Self::BOTTOM_LEVEL;
}
impl default::Default for AccelerationStructureTypeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AccelerationStructureTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"TOP_LEVEL"),
            1 => Some(&"BOTTOM_LEVEL"),
            2 => Some(&"GENERIC"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type AccelerationStructureTypeNV = AccelerationStructureTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct GeometryTypeKHR(i32);
impl GeometryTypeKHR {
    pub const TRIANGLES: Self = Self(0);
    pub const AABBS: Self = Self(1);
    pub const INSTANCES: Self = Self(2);
    pub const TRIANGLES_NV: Self = Self::TRIANGLES;
    pub const AABBS_NV: Self = Self::AABBS;
}
impl default::Default for GeometryTypeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for GeometryTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"TRIANGLES"),
            1 => Some(&"AABBS"),
            2 => Some(&"INSTANCES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type GeometryTypeNV = GeometryTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct RayTracingShaderGroupTypeKHR(i32);
impl RayTracingShaderGroupTypeKHR {
    pub const GENERAL: Self = Self(0);
    pub const TRIANGLES_HIT_GROUP: Self = Self(1);
    pub const PROCEDURAL_HIT_GROUP: Self = Self(2);
    pub const GENERAL_NV: Self = Self::GENERAL;
    pub const TRIANGLES_HIT_GROUP_NV: Self = Self::TRIANGLES_HIT_GROUP;
    pub const PROCEDURAL_HIT_GROUP_NV: Self = Self::PROCEDURAL_HIT_GROUP;
}
impl default::Default for RayTracingShaderGroupTypeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for RayTracingShaderGroupTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERAL"),
            1 => Some(&"TRIANGLES_HIT_GROUP"),
            2 => Some(&"PROCEDURAL_HIT_GROUP"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMemoryRequirementsTypeNV(i32);
impl AccelerationStructureMemoryRequirementsTypeNV {
    pub const OBJECT: Self = Self(0);
    pub const BUILD_SCRATCH: Self = Self(1);
    pub const UPDATE_SCRATCH: Self = Self(2);
}
impl default::Default for AccelerationStructureMemoryRequirementsTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AccelerationStructureMemoryRequirementsTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OBJECT"),
            1 => Some(&"BUILD_SCRATCH"),
            2 => Some(&"UPDATE_SCRATCH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureBuildTypeKHR(i32);
impl AccelerationStructureBuildTypeKHR {
    pub const HOST: Self = Self(0);
    pub const DEVICE: Self = Self(1);
    pub const HOST_OR_DEVICE: Self = Self(2);
}
impl default::Default for AccelerationStructureBuildTypeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AccelerationStructureBuildTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"HOST"),
            1 => Some(&"DEVICE"),
            2 => Some(&"HOST_OR_DEVICE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureCompatibilityKHR(i32);
impl AccelerationStructureCompatibilityKHR {
    pub const COMPATIBLE: Self = Self(0);
    pub const INCOMPATIBLE: Self = Self(1);
}
impl default::Default for AccelerationStructureCompatibilityKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AccelerationStructureCompatibilityKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMPATIBLE"),
            1 => Some(&"INCOMPATIBLE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderGroupShaderKHR(i32);
impl ShaderGroupShaderKHR {
    pub const GENERAL: Self = Self(0);
    pub const CLOSEST_HIT: Self = Self(1);
    pub const ANY_HIT: Self = Self(2);
    pub const INTERSECTION: Self = Self(3);
}
impl default::Default for ShaderGroupShaderKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ShaderGroupShaderKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERAL"),
            1 => Some(&"CLOSEST_HIT"),
            2 => Some(&"ANY_HIT"),
            3 => Some(&"INTERSECTION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct MemoryOverallocationBehaviorAMD(i32);
impl MemoryOverallocationBehaviorAMD {
    pub const DEFAULT: Self = Self(0);
    pub const ALLOWED: Self = Self(1);
    pub const DISALLOWED: Self = Self(2);
}
impl default::Default for MemoryOverallocationBehaviorAMD {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for MemoryOverallocationBehaviorAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"ALLOWED"),
            2 => Some(&"DISALLOWED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ScopeNV(i32);
impl ScopeNV {
    pub const DEVICE: Self = Self(1);
    pub const WORKGROUP: Self = Self(2);
    pub const SUBGROUP: Self = Self(3);
    pub const QUEUE_FAMILY: Self = Self(5);
}
impl default::Default for ScopeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ScopeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"DEVICE"),
            2 => Some(&"WORKGROUP"),
            3 => Some(&"SUBGROUP"),
            5 => Some(&"QUEUE_FAMILY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ComponentTypeNV(i32);
impl ComponentTypeNV {
    pub const FLOAT16: Self = Self(0);
    pub const FLOAT32: Self = Self(1);
    pub const FLOAT64: Self = Self(2);
    pub const SINT8: Self = Self(3);
    pub const SINT16: Self = Self(4);
    pub const SINT32: Self = Self(5);
    pub const SINT64: Self = Self(6);
    pub const UINT8: Self = Self(7);
    pub const UINT16: Self = Self(8);
    pub const UINT32: Self = Self(9);
    pub const UINT64: Self = Self(10);
}
impl default::Default for ComponentTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ComponentTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FLOAT16"),
            1 => Some(&"FLOAT32"),
            2 => Some(&"FLOAT64"),
            3 => Some(&"SINT8"),
            4 => Some(&"SINT16"),
            5 => Some(&"SINT32"),
            6 => Some(&"SINT64"),
            7 => Some(&"UINT8"),
            8 => Some(&"UINT16"),
            9 => Some(&"UINT32"),
            10 => Some(&"UINT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterScopeKHR(i32);
impl PerformanceCounterScopeKHR {
    pub const COMMAND_BUFFER: Self = Self(0);
    pub const RENDER_PASS: Self = Self(1);
    pub const COMMAND: Self = Self(2);
    pub const QUERY_SCOPE_COMMAND_BUFFER: Self = Self::COMMAND_BUFFER;
    pub const QUERY_SCOPE_RENDER_PASS: Self = Self::RENDER_PASS;
    pub const QUERY_SCOPE_COMMAND: Self = Self::COMMAND;
}
impl default::Default for PerformanceCounterScopeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceCounterScopeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND_BUFFER"),
            1 => Some(&"RENDER_PASS"),
            2 => Some(&"COMMAND"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterUnitKHR(i32);
impl PerformanceCounterUnitKHR {
    pub const GENERIC: Self = Self(0);
    pub const PERCENTAGE: Self = Self(1);
    pub const NANOSECONDS: Self = Self(2);
    pub const BYTES: Self = Self(3);
    pub const BYTES_PER_SECOND: Self = Self(4);
    pub const KELVIN: Self = Self(5);
    pub const WATTS: Self = Self(6);
    pub const VOLTS: Self = Self(7);
    pub const AMPS: Self = Self(8);
    pub const HERTZ: Self = Self(9);
    pub const CYCLES: Self = Self(10);
}
impl default::Default for PerformanceCounterUnitKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceCounterUnitKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERIC"),
            1 => Some(&"PERCENTAGE"),
            2 => Some(&"NANOSECONDS"),
            3 => Some(&"BYTES"),
            4 => Some(&"BYTES_PER_SECOND"),
            5 => Some(&"KELVIN"),
            6 => Some(&"WATTS"),
            7 => Some(&"VOLTS"),
            8 => Some(&"AMPS"),
            9 => Some(&"HERTZ"),
            10 => Some(&"CYCLES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterStorageKHR(i32);
impl PerformanceCounterStorageKHR {
    pub const INT32: Self = Self(0);
    pub const INT64: Self = Self(1);
    pub const UINT32: Self = Self(2);
    pub const UINT64: Self = Self(3);
    pub const FLOAT32: Self = Self(4);
    pub const FLOAT64: Self = Self(5);
}
impl default::Default for PerformanceCounterStorageKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceCounterStorageKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INT32"),
            1 => Some(&"INT64"),
            2 => Some(&"UINT32"),
            3 => Some(&"UINT64"),
            4 => Some(&"FLOAT32"),
            5 => Some(&"FLOAT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceConfigurationTypeINTEL(i32);
impl PerformanceConfigurationTypeINTEL {
    pub const COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED: Self = Self(0);
}
impl default::Default for PerformanceConfigurationTypeINTEL {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceConfigurationTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueryPoolSamplingModeINTEL(i32);
impl QueryPoolSamplingModeINTEL {
    pub const MANUAL: Self = Self(0);
}
impl default::Default for QueryPoolSamplingModeINTEL {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for QueryPoolSamplingModeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"MANUAL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceOverrideTypeINTEL(i32);
impl PerformanceOverrideTypeINTEL {
    pub const NULL_HARDWARE: Self = Self(0);
    pub const FLUSH_GPU_CACHES: Self = Self(1);
}
impl default::Default for PerformanceOverrideTypeINTEL {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceOverrideTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NULL_HARDWARE"),
            1 => Some(&"FLUSH_GPU_CACHES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceParameterTypeINTEL(i32);
impl PerformanceParameterTypeINTEL {
    pub const HW_COUNTERS_SUPPORTED: Self = Self(0);
    pub const STREAM_MARKER_VALID_BITS: Self = Self(1);
}
impl default::Default for PerformanceParameterTypeINTEL {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceParameterTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"HW_COUNTERS_SUPPORTED"),
            1 => Some(&"STREAM_MARKER_VALID_BITS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceValueTypeINTEL(i32);
impl PerformanceValueTypeINTEL {
    pub const UINT32: Self = Self(0);
    pub const UINT64: Self = Self(1);
    pub const FLOAT: Self = Self(2);
    pub const BOOL: Self = Self(3);
    pub const STRING: Self = Self(4);
}
impl default::Default for PerformanceValueTypeINTEL {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PerformanceValueTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UINT32"),
            1 => Some(&"UINT64"),
            2 => Some(&"FLOAT"),
            3 => Some(&"BOOL"),
            4 => Some(&"STRING"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct LineRasterizationModeEXT(i32);
impl LineRasterizationModeEXT {
    pub const DEFAULT: Self = Self(0);
    pub const RECTANGULAR: Self = Self(1);
    pub const BRESENHAM: Self = Self(2);
    pub const RECTANGULAR_SMOOTH: Self = Self(3);
}
impl default::Default for LineRasterizationModeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for LineRasterizationModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"RECTANGULAR"),
            2 => Some(&"BRESENHAM"),
            3 => Some(&"RECTANGULAR_SMOOTH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateNV(i32);
impl FragmentShadingRateNV {
    pub const N1_INVOCATION_PER_PIXEL: Self = Self(0);
    pub const N1_INVOCATION_PER_1X2_PIXELS: Self = Self(1);
    pub const N1_INVOCATION_PER_2X1_PIXELS: Self = Self(4);
    pub const N1_INVOCATION_PER_2X2_PIXELS: Self = Self(5);
    pub const N1_INVOCATION_PER_2X4_PIXELS: Self = Self(6);
    pub const N1_INVOCATION_PER_4X2_PIXELS: Self = Self(9);
    pub const N1_INVOCATION_PER_4X4_PIXELS: Self = Self(10);
    pub const N2_INVOCATIONS_PER_PIXEL: Self = Self(11);
    pub const N4_INVOCATIONS_PER_PIXEL: Self = Self(12);
    pub const N8_INVOCATIONS_PER_PIXEL: Self = Self(13);
    pub const N16_INVOCATIONS_PER_PIXEL: Self = Self(14);
    pub const NO_INVOCATIONS: Self = Self(15);
}
impl default::Default for FragmentShadingRateNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for FragmentShadingRateNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1_INVOCATION_PER_PIXEL"),
            1 => Some(&"N1_INVOCATION_PER_1X2_PIXELS"),
            4 => Some(&"N1_INVOCATION_PER_2X1_PIXELS"),
            5 => Some(&"N1_INVOCATION_PER_2X2_PIXELS"),
            6 => Some(&"N1_INVOCATION_PER_2X4_PIXELS"),
            9 => Some(&"N1_INVOCATION_PER_4X2_PIXELS"),
            10 => Some(&"N1_INVOCATION_PER_4X4_PIXELS"),
            11 => Some(&"N2_INVOCATIONS_PER_PIXEL"),
            12 => Some(&"N4_INVOCATIONS_PER_PIXEL"),
            13 => Some(&"N8_INVOCATIONS_PER_PIXEL"),
            14 => Some(&"N16_INVOCATIONS_PER_PIXEL"),
            15 => Some(&"NO_INVOCATIONS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateTypeNV(i32);
impl FragmentShadingRateTypeNV {
    pub const FRAGMENT_SIZE: Self = Self(0);
    pub const ENUMS: Self = Self(1);
}
impl default::Default for FragmentShadingRateTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for FragmentShadingRateTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FRAGMENT_SIZE"),
            1 => Some(&"ENUMS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ProvokingVertexModeEXT(i32);
impl ProvokingVertexModeEXT {
    pub const FIRST_VERTEX: Self = Self(0);
    pub const LAST_VERTEX: Self = Self(1);
}
impl default::Default for ProvokingVertexModeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ProvokingVertexModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FIRST_VERTEX"),
            1 => Some(&"LAST_VERTEX"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ColorSpaceKHR(i32);
impl ColorSpaceKHR {
    pub const SRGB_NONLINEAR: Self = Self(0);
    pub const COLORSPACE_SRGB_NONLINEAR: Self = Self::SRGB_NONLINEAR;
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DISPLAY_P3_NONLINEAR_EXT: Self = Self(1000104001);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const EXTENDED_SRGB_LINEAR_EXT: Self = Self(1000104002);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DISPLAY_P3_LINEAR_EXT: Self = Self(1000104003);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DCI_P3_NONLINEAR_EXT: Self = Self(1000104004);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT709_LINEAR_EXT: Self = Self(1000104005);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT709_NONLINEAR_EXT: Self = Self(1000104006);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT2020_LINEAR_EXT: Self = Self(1000104007);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const HDR10_ST2084_EXT: Self = Self(1000104008);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DOLBYVISION_EXT: Self = Self(1000104009);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const HDR10_HLG_EXT: Self = Self(1000104010);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const ADOBERGB_LINEAR_EXT: Self = Self(1000104011);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const ADOBERGB_NONLINEAR_EXT: Self = Self(1000104012);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const PASS_THROUGH_EXT: Self = Self(1000104013);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const EXTENDED_SRGB_NONLINEAR_EXT: Self = Self(1000104014);
    pub const DCI_P3_LINEAR_EXT: Self = Self::DISPLAY_P3_LINEAR_EXT;
    /// Added by extension VK_AMD_display_native_hdr.
    pub const DISPLAY_NATIVE_AMD: Self = Self(1000213000);
}
impl default::Default for ColorSpaceKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ColorSpaceKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SRGB_NONLINEAR"),
            1000104001 => Some(&"DISPLAY_P3_NONLINEAR_EXT"),
            1000104002 => Some(&"EXTENDED_SRGB_LINEAR_EXT"),
            1000104003 => Some(&"DISPLAY_P3_LINEAR_EXT"),
            1000104004 => Some(&"DCI_P3_NONLINEAR_EXT"),
            1000104005 => Some(&"BT709_LINEAR_EXT"),
            1000104006 => Some(&"BT709_NONLINEAR_EXT"),
            1000104007 => Some(&"BT2020_LINEAR_EXT"),
            1000104008 => Some(&"HDR10_ST2084_EXT"),
            1000104009 => Some(&"DOLBYVISION_EXT"),
            1000104010 => Some(&"HDR10_HLG_EXT"),
            1000104011 => Some(&"ADOBERGB_LINEAR_EXT"),
            1000104012 => Some(&"ADOBERGB_NONLINEAR_EXT"),
            1000104013 => Some(&"PASS_THROUGH_EXT"),
            1000104014 => Some(&"EXTENDED_SRGB_NONLINEAR_EXT"),
            1000213000 => Some(&"DISPLAY_NATIVE_AMD"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PresentModeKHR(i32);
impl PresentModeKHR {
    pub const IMMEDIATE: Self = Self(0);
    pub const MAILBOX: Self = Self(1);
    pub const FIFO: Self = Self(2);
    pub const FIFO_RELAXED: Self = Self(3);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_DEMAND_REFRESH: Self = Self(1000111000);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_CONTINUOUS_REFRESH: Self = Self(1000111001);
}
impl default::Default for PresentModeKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PresentModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"IMMEDIATE"),
            1 => Some(&"MAILBOX"),
            2 => Some(&"FIFO"),
            3 => Some(&"FIFO_RELAXED"),
            1000111000 => Some(&"SHARED_DEMAND_REFRESH"),
            1000111001 => Some(&"SHARED_CONTINUOUS_REFRESH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DebugReportObjectTypeEXT(i32);
impl DebugReportObjectTypeEXT {
    pub const UNKNOWN: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
    pub const PHYSICAL_DEVICE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const QUEUE: Self = Self(4);
    pub const SEMAPHORE: Self = Self(5);
    pub const COMMAND_BUFFER: Self = Self(6);
    pub const FENCE: Self = Self(7);
    pub const DEVICE_MEMORY: Self = Self(8);
    pub const BUFFER: Self = Self(9);
    pub const IMAGE: Self = Self(10);
    pub const EVENT: Self = Self(11);
    pub const QUERY_POOL: Self = Self(12);
    pub const BUFFER_VIEW: Self = Self(13);
    pub const IMAGE_VIEW: Self = Self(14);
    pub const SHADER_MODULE: Self = Self(15);
    pub const PIPELINE_CACHE: Self = Self(16);
    pub const PIPELINE_LAYOUT: Self = Self(17);
    pub const RENDER_PASS: Self = Self(18);
    pub const PIPELINE: Self = Self(19);
    pub const DESCRIPTOR_SET_LAYOUT: Self = Self(20);
    pub const SAMPLER: Self = Self(21);
    pub const DESCRIPTOR_POOL: Self = Self(22);
    pub const DESCRIPTOR_SET: Self = Self(23);
    pub const FRAMEBUFFER: Self = Self(24);
    pub const COMMAND_POOL: Self = Self(25);
    pub const SURFACE_KHR: Self = Self(26);
    pub const SWAPCHAIN_KHR: Self = Self(27);
    pub const DEBUG_REPORT_CALLBACK_EXT: Self = Self(28);
    pub const DEBUG_REPORT: Self = Self::DEBUG_REPORT_CALLBACK_EXT;
    pub const DISPLAY_KHR: Self = Self(29);
    pub const DISPLAY_MODE_KHR: Self = Self(30);
    pub const VALIDATION_CACHE_EXT: Self = Self(33);
    pub const VALIDATION_CACHE: Self = Self::VALIDATION_CACHE_EXT;
    /// Added by extension VK_KHR_sampler_ycbcr_conversion.
    pub const SAMPLER_YCBCR_CONVERSION: Self = Self(1000156000);
    /// Added by extension VK_EXT_debug_report.
    pub const DESCRIPTOR_UPDATE_TEMPLATE: Self = Self(1000085000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_NVX: Self = Self(1000029001);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    pub const SAMPLER_YCBCR_CONVERSION_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION;
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366000);
}
impl default::Default for DebugReportObjectTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DebugReportObjectTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNKNOWN"),
            1 => Some(&"INSTANCE"),
            2 => Some(&"PHYSICAL_DEVICE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"QUEUE"),
            5 => Some(&"SEMAPHORE"),
            6 => Some(&"COMMAND_BUFFER"),
            7 => Some(&"FENCE"),
            8 => Some(&"DEVICE_MEMORY"),
            9 => Some(&"BUFFER"),
            10 => Some(&"IMAGE"),
            11 => Some(&"EVENT"),
            12 => Some(&"QUERY_POOL"),
            13 => Some(&"BUFFER_VIEW"),
            14 => Some(&"IMAGE_VIEW"),
            15 => Some(&"SHADER_MODULE"),
            16 => Some(&"PIPELINE_CACHE"),
            17 => Some(&"PIPELINE_LAYOUT"),
            18 => Some(&"RENDER_PASS"),
            19 => Some(&"PIPELINE"),
            20 => Some(&"DESCRIPTOR_SET_LAYOUT"),
            21 => Some(&"SAMPLER"),
            22 => Some(&"DESCRIPTOR_POOL"),
            23 => Some(&"DESCRIPTOR_SET"),
            24 => Some(&"FRAMEBUFFER"),
            25 => Some(&"COMMAND_POOL"),
            26 => Some(&"SURFACE_KHR"),
            27 => Some(&"SWAPCHAIN_KHR"),
            28 => Some(&"DEBUG_REPORT_CALLBACK_EXT"),
            29 => Some(&"DISPLAY_KHR"),
            30 => Some(&"DISPLAY_MODE_KHR"),
            33 => Some(&"VALIDATION_CACHE_EXT"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE"),
            1000029000 => Some(&"CU_MODULE_NVX"),
            1000029001 => Some(&"CU_FUNCTION_NVX"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000366000 => Some(&"BUFFER_COLLECTION_FUCHSIA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DeviceMemoryReportEventTypeEXT(i32);
impl DeviceMemoryReportEventTypeEXT {
    pub const ALLOCATE: Self = Self(0);
    pub const FREE: Self = Self(1);
    pub const IMPORT: Self = Self(2);
    pub const UNIMPORT: Self = Self(3);
    pub const ALLOCATION_FAILED: Self = Self(4);
}
impl default::Default for DeviceMemoryReportEventTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DeviceMemoryReportEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALLOCATE"),
            1 => Some(&"FREE"),
            2 => Some(&"IMPORT"),
            3 => Some(&"UNIMPORT"),
            4 => Some(&"ALLOCATION_FAILED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct RasterizationOrderAMD(i32);
impl RasterizationOrderAMD {
    pub const STRICT: Self = Self(0);
    pub const RELAXED: Self = Self(1);
}
impl default::Default for RasterizationOrderAMD {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for RasterizationOrderAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STRICT"),
            1 => Some(&"RELAXED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationCheckEXT(i32);
impl ValidationCheckEXT {
    pub const ALL: Self = Self(0);
    pub const SHADERS: Self = Self(1);
}
impl default::Default for ValidationCheckEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ValidationCheckEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL"),
            1 => Some(&"SHADERS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationFeatureEnableEXT(i32);
impl ValidationFeatureEnableEXT {
    pub const GPU_ASSISTED: Self = Self(0);
    pub const GPU_ASSISTED_RESERVE_BINDING_SLOT: Self = Self(1);
    pub const BEST_PRACTICES: Self = Self(2);
    pub const DEBUG_PRINTF: Self = Self(3);
    pub const SYNCHRONIZATION_VALIDATION: Self = Self(4);
}
impl default::Default for ValidationFeatureEnableEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ValidationFeatureEnableEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GPU_ASSISTED"),
            1 => Some(&"GPU_ASSISTED_RESERVE_BINDING_SLOT"),
            2 => Some(&"BEST_PRACTICES"),
            3 => Some(&"DEBUG_PRINTF"),
            4 => Some(&"SYNCHRONIZATION_VALIDATION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationFeatureDisableEXT(i32);
impl ValidationFeatureDisableEXT {
    pub const ALL: Self = Self(0);
    pub const SHADERS: Self = Self(1);
    pub const THREAD_SAFETY: Self = Self(2);
    pub const API_PARAMETERS: Self = Self(3);
    pub const OBJECT_LIFETIMES: Self = Self(4);
    pub const CORE_CHECKS: Self = Self(5);
    pub const UNIQUE_HANDLES: Self = Self(6);
    pub const SHADER_VALIDATION_CACHE: Self = Self(7);
}
impl default::Default for ValidationFeatureDisableEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ValidationFeatureDisableEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL"),
            1 => Some(&"SHADERS"),
            2 => Some(&"THREAD_SAFETY"),
            3 => Some(&"API_PARAMETERS"),
            4 => Some(&"OBJECT_LIFETIMES"),
            5 => Some(&"CORE_CHECKS"),
            6 => Some(&"UNIQUE_HANDLES"),
            7 => Some(&"SHADER_VALIDATION_CACHE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DisplayPowerStateEXT(i32);
impl DisplayPowerStateEXT {
    pub const OFF: Self = Self(0);
    pub const SUSPEND: Self = Self(1);
    pub const ON: Self = Self(2);
}
impl default::Default for DisplayPowerStateEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DisplayPowerStateEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OFF"),
            1 => Some(&"SUSPEND"),
            2 => Some(&"ON"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DeviceEventTypeEXT(i32);
impl DeviceEventTypeEXT {
    pub const DISPLAY_HOTPLUG: Self = Self(0);
}
impl default::Default for DeviceEventTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DeviceEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DISPLAY_HOTPLUG"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DisplayEventTypeEXT(i32);
impl DisplayEventTypeEXT {
    pub const FIRST_PIXEL_OUT: Self = Self(0);
}
impl default::Default for DisplayEventTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DisplayEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FIRST_PIXEL_OUT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct TessellationDomainOrigin(i32);
impl TessellationDomainOrigin {
    pub const UPPER_LEFT: Self = Self(0);
    pub const LOWER_LEFT: Self = Self(1);
    pub const UPPER_LEFT_KHR: Self = Self::UPPER_LEFT;
    pub const LOWER_LEFT_KHR: Self = Self::LOWER_LEFT;
}
impl default::Default for TessellationDomainOrigin {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for TessellationDomainOrigin {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UPPER_LEFT"),
            1 => Some(&"LOWER_LEFT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type TessellationDomainOriginKHR = TessellationDomainOrigin;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrModelConversion(i32);
impl SamplerYcbcrModelConversion {
    pub const RGB_IDENTITY: Self = Self(0);
    /// just range expansion
    pub const YCBCR_IDENTITY: Self = Self(1);
    /// aka HD YUV
    pub const YCBCR_709: Self = Self(2);
    /// aka SD YUV
    pub const YCBCR_601: Self = Self(3);
    /// aka UHD YUV
    pub const YCBCR_2020: Self = Self(4);
    pub const RGB_IDENTITY_KHR: Self = Self::RGB_IDENTITY;
    pub const YCBCR_IDENTITY_KHR: Self = Self::YCBCR_IDENTITY;
    pub const YCBCR_709_KHR: Self = Self::YCBCR_709;
    pub const YCBCR_601_KHR: Self = Self::YCBCR_601;
    pub const YCBCR_2020_KHR: Self = Self::YCBCR_2020;
}
impl default::Default for SamplerYcbcrModelConversion {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SamplerYcbcrModelConversion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"RGB_IDENTITY"),
            1 => Some(&"YCBCR_IDENTITY"),
            2 => Some(&"YCBCR_709"),
            3 => Some(&"YCBCR_601"),
            4 => Some(&"YCBCR_2020"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrRange(i32);
impl SamplerYcbcrRange {
    /// Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
    pub const ITU_FULL: Self = Self(0);
    /// Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
    pub const ITU_NARROW: Self = Self(1);
    pub const ITU_FULL_KHR: Self = Self::ITU_FULL;
    pub const ITU_NARROW_KHR: Self = Self::ITU_NARROW;
}
impl default::Default for SamplerYcbcrRange {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SamplerYcbcrRange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ITU_FULL"),
            1 => Some(&"ITU_NARROW"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerYcbcrRangeKHR = SamplerYcbcrRange;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ChromaLocation(i32);
impl ChromaLocation {
    pub const COSITED_EVEN: Self = Self(0);
    pub const MIDPOINT: Self = Self(1);
    pub const COSITED_EVEN_KHR: Self = Self::COSITED_EVEN;
    pub const MIDPOINT_KHR: Self = Self::MIDPOINT;
}
impl default::Default for ChromaLocation {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ChromaLocation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COSITED_EVEN"),
            1 => Some(&"MIDPOINT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type ChromaLocationKHR = ChromaLocation;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerReductionMode(i32);
impl SamplerReductionMode {
    pub const WEIGHTED_AVERAGE: Self = Self(0);
    pub const MIN: Self = Self(1);
    pub const MAX: Self = Self(2);
    pub const WEIGHTED_AVERAGE_EXT: Self = Self::WEIGHTED_AVERAGE;
    pub const MIN_EXT: Self = Self::MIN;
    pub const MAX_EXT: Self = Self::MAX;
}
impl default::Default for SamplerReductionMode {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for SamplerReductionMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"WEIGHTED_AVERAGE"),
            1 => Some(&"MIN"),
            2 => Some(&"MAX"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerReductionModeEXT = SamplerReductionMode;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendOverlapEXT(i32);
impl BlendOverlapEXT {
    pub const UNCORRELATED: Self = Self(0);
    pub const DISJOINT: Self = Self(1);
    pub const CONJOINT: Self = Self(2);
}
impl default::Default for BlendOverlapEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for BlendOverlapEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNCORRELATED"),
            1 => Some(&"DISJOINT"),
            2 => Some(&"CONJOINT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FullScreenExclusiveEXT(i32);
impl FullScreenExclusiveEXT {
    pub const DEFAULT: Self = Self(0);
    pub const ALLOWED: Self = Self(1);
    pub const DISALLOWED: Self = Self(2);
    pub const APPLICATION_CONTROLLED: Self = Self(3);
}
impl default::Default for FullScreenExclusiveEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for FullScreenExclusiveEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"ALLOWED"),
            2 => Some(&"DISALLOWED"),
            3 => Some(&"APPLICATION_CONTROLLED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderFloatControlsIndependence(i32);
impl ShaderFloatControlsIndependence {
    pub const N32_BIT_ONLY: Self = Self(0);
    pub const ALL: Self = Self(1);
    pub const NONE: Self = Self(2);
    pub const N32_BIT_ONLY_KHR: Self = Self::N32_BIT_ONLY;
    pub const ALL_KHR: Self = Self::ALL;
    pub const NONE_KHR: Self = Self::NONE;
}
impl default::Default for ShaderFloatControlsIndependence {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ShaderFloatControlsIndependence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N32_BIT_ONLY"),
            1 => Some(&"ALL"),
            2 => Some(&"NONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateCombinerOpKHR(i32);
impl FragmentShadingRateCombinerOpKHR {
    pub const KEEP: Self = Self(0);
    pub const REPLACE: Self = Self(1);
    pub const MIN: Self = Self(2);
    pub const MAX: Self = Self(3);
    pub const MUL: Self = Self(4);
}
impl default::Default for FragmentShadingRateCombinerOpKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for FragmentShadingRateCombinerOpKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"KEEP"),
            1 => Some(&"REPLACE"),
            2 => Some(&"MIN"),
            3 => Some(&"MAX"),
            4 => Some(&"MUL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct VendorId(i32);
impl VendorId {
    /// Vivante vendor ID
    pub const VIV: Self = Self(65537);
    /// VeriSilicon vendor ID
    pub const VSI: Self = Self(65538);
    /// Kazan Software Renderer
    pub const KAZAN: Self = Self(65539);
    /// Codeplay Software Ltd. vendor ID
    pub const CODEPLAY: Self = Self(65540);
    /// Mesa vendor ID
    pub const MESA: Self = Self(65541);
    /// PoCL vendor ID
    pub const POCL: Self = Self(65542);
}
impl default::Default for VendorId {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for VendorId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            65537 => Some(&"VIV"),
            65538 => Some(&"VSI"),
            65539 => Some(&"KAZAN"),
            65540 => Some(&"CODEPLAY"),
            65541 => Some(&"MESA"),
            65542 => Some(&"POCL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DriverId(i32);
impl DriverId {
    /// Advanced Micro Devices, Inc.
    pub const AMD_PROPRIETARY: Self = Self(1);
    /// Advanced Micro Devices, Inc.
    pub const AMD_OPEN_SOURCE: Self = Self(2);
    /// Mesa open source project
    pub const MESA_RADV: Self = Self(3);
    /// NVIDIA Corporation
    pub const NVIDIA_PROPRIETARY: Self = Self(4);
    /// Intel Corporation
    pub const INTEL_PROPRIETARY_WINDOWS: Self = Self(5);
    /// Intel Corporation
    pub const INTEL_OPEN_SOURCE_MESA: Self = Self(6);
    /// Imagination Technologies
    pub const IMAGINATION_PROPRIETARY: Self = Self(7);
    /// Qualcomm Technologies, Inc.
    pub const QUALCOMM_PROPRIETARY: Self = Self(8);
    /// Arm Limited
    pub const ARM_PROPRIETARY: Self = Self(9);
    /// Google LLC
    pub const GOOGLE_SWIFTSHADER: Self = Self(10);
    /// Google LLC
    pub const GGP_PROPRIETARY: Self = Self(11);
    /// Broadcom Inc.
    pub const BROADCOM_PROPRIETARY: Self = Self(12);
    /// Mesa
    pub const MESA_LLVMPIPE: Self = Self(13);
    /// MoltenVK
    pub const MOLTENVK: Self = Self(14);
    /// Core Avionics & Industrial Inc.
    pub const COREAVI_PROPRIETARY: Self = Self(15);
    /// Juice Technologies, Inc.
    pub const JUICE_PROPRIETARY: Self = Self(16);
    /// Verisilicon, Inc.
    pub const VERISILICON_PROPRIETARY: Self = Self(17);
    /// Mesa open source project
    pub const MESA_TURNIP: Self = Self(18);
    /// Mesa open source project
    pub const MESA_V3DV: Self = Self(19);
    /// Mesa open source project
    pub const MESA_PANVK: Self = Self(20);
    /// Samsung Electronics Co., Ltd.
    pub const SAMSUNG_PROPRIETARY: Self = Self(21);
    pub const AMD_PROPRIETARY_KHR: Self = Self::AMD_PROPRIETARY;
    pub const AMD_OPEN_SOURCE_KHR: Self = Self::AMD_OPEN_SOURCE;
    pub const MESA_RADV_KHR: Self = Self::MESA_RADV;
    pub const NVIDIA_PROPRIETARY_KHR: Self = Self::NVIDIA_PROPRIETARY;
    pub const INTEL_PROPRIETARY_WINDOWS_KHR: Self = Self::INTEL_PROPRIETARY_WINDOWS;
    pub const INTEL_OPEN_SOURCE_MESA_KHR: Self = Self::INTEL_OPEN_SOURCE_MESA;
    pub const IMAGINATION_PROPRIETARY_KHR: Self = Self::IMAGINATION_PROPRIETARY;
    pub const QUALCOMM_PROPRIETARY_KHR: Self = Self::QUALCOMM_PROPRIETARY;
    pub const ARM_PROPRIETARY_KHR: Self = Self::ARM_PROPRIETARY;
    pub const GOOGLE_SWIFTSHADER_KHR: Self = Self::GOOGLE_SWIFTSHADER;
    pub const GGP_PROPRIETARY_KHR: Self = Self::GGP_PROPRIETARY;
    pub const BROADCOM_PROPRIETARY_KHR: Self = Self::BROADCOM_PROPRIETARY;
}
impl default::Default for DriverId {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for DriverId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"AMD_PROPRIETARY"),
            2 => Some(&"AMD_OPEN_SOURCE"),
            3 => Some(&"MESA_RADV"),
            4 => Some(&"NVIDIA_PROPRIETARY"),
            5 => Some(&"INTEL_PROPRIETARY_WINDOWS"),
            6 => Some(&"INTEL_OPEN_SOURCE_MESA"),
            7 => Some(&"IMAGINATION_PROPRIETARY"),
            8 => Some(&"QUALCOMM_PROPRIETARY"),
            9 => Some(&"ARM_PROPRIETARY"),
            10 => Some(&"GOOGLE_SWIFTSHADER"),
            11 => Some(&"GGP_PROPRIETARY"),
            12 => Some(&"BROADCOM_PROPRIETARY"),
            13 => Some(&"MESA_LLVMPIPE"),
            14 => Some(&"MOLTENVK"),
            15 => Some(&"COREAVI_PROPRIETARY"),
            16 => Some(&"JUICE_PROPRIETARY"),
            17 => Some(&"VERISILICON_PROPRIETARY"),
            18 => Some(&"MESA_TURNIP"),
            19 => Some(&"MESA_V3DV"),
            20 => Some(&"MESA_PANVK"),
            21 => Some(&"SAMSUNG_PROPRIETARY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type DriverIdKHR = DriverId;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShadingRatePaletteEntryNV(i32);
impl ShadingRatePaletteEntryNV {
    pub const NO_INVOCATIONS: Self = Self(0);
    pub const N16_INVOCATIONS_PER_PIXEL: Self = Self(1);
    pub const N8_INVOCATIONS_PER_PIXEL: Self = Self(2);
    pub const N4_INVOCATIONS_PER_PIXEL: Self = Self(3);
    pub const N2_INVOCATIONS_PER_PIXEL: Self = Self(4);
    pub const N1_INVOCATION_PER_PIXEL: Self = Self(5);
    pub const N1_INVOCATION_PER_2X1_PIXELS: Self = Self(6);
    pub const N1_INVOCATION_PER_1X2_PIXELS: Self = Self(7);
    pub const N1_INVOCATION_PER_2X2_PIXELS: Self = Self(8);
    pub const N1_INVOCATION_PER_4X2_PIXELS: Self = Self(9);
    pub const N1_INVOCATION_PER_2X4_PIXELS: Self = Self(10);
    pub const N1_INVOCATION_PER_4X4_PIXELS: Self = Self(11);
}
impl default::Default for ShadingRatePaletteEntryNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for ShadingRatePaletteEntryNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NO_INVOCATIONS"),
            1 => Some(&"N16_INVOCATIONS_PER_PIXEL"),
            2 => Some(&"N8_INVOCATIONS_PER_PIXEL"),
            3 => Some(&"N4_INVOCATIONS_PER_PIXEL"),
            4 => Some(&"N2_INVOCATIONS_PER_PIXEL"),
            5 => Some(&"N1_INVOCATION_PER_PIXEL"),
            6 => Some(&"N1_INVOCATION_PER_2X1_PIXELS"),
            7 => Some(&"N1_INVOCATION_PER_1X2_PIXELS"),
            8 => Some(&"N1_INVOCATION_PER_2X2_PIXELS"),
            9 => Some(&"N1_INVOCATION_PER_4X2_PIXELS"),
            10 => Some(&"N1_INVOCATION_PER_2X4_PIXELS"),
            11 => Some(&"N1_INVOCATION_PER_4X4_PIXELS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoarseSampleOrderTypeNV(i32);
impl CoarseSampleOrderTypeNV {
    pub const DEFAULT: Self = Self(0);
    pub const CUSTOM: Self = Self(1);
    pub const PIXEL_MAJOR: Self = Self(2);
    pub const SAMPLE_MAJOR: Self = Self(3);
}
impl default::Default for CoarseSampleOrderTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for CoarseSampleOrderTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"CUSTOM"),
            2 => Some(&"PIXEL_MAJOR"),
            3 => Some(&"SAMPLE_MAJOR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineExecutableStatisticFormatKHR(i32);
impl PipelineExecutableStatisticFormatKHR {
    pub const BOOL32: Self = Self(0);
    pub const INT64: Self = Self(1);
    pub const UINT64: Self = Self(2);
    pub const FLOAT64: Self = Self(3);
}
impl default::Default for PipelineExecutableStatisticFormatKHR {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for PipelineExecutableStatisticFormatKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BOOL32"),
            1 => Some(&"INT64"),
            2 => Some(&"UINT64"),
            3 => Some(&"FLOAT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type FnInternalAllocationNotification = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
pub type FnInternalFreeNotification = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
pub type FnReallocationFunction = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    p_original: *mut c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut c_void;
pub type FnAllocationFunction = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut c_void;
pub type FnFreeFunction = unsafe extern "system" fn(p_user_data: *mut c_void, p_memory: *mut c_void);
pub type FnVoidFunction = unsafe extern "system" fn();
pub type FnDebugReportCallbackEXT = unsafe extern "system" fn(
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: *const c_char,
    p_message: *const c_char,
    p_user_data: *mut c_void,
) -> Bool32;
pub type FnDebugUtilsMessengerCallbackEXT = unsafe extern "system" fn(
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
    p_user_data: *mut c_void,
) -> Bool32;
pub type FnDeviceMemoryReportCallbackEXT =
    unsafe extern "system" fn(p_callback_data: *const DeviceMemoryReportCallbackDataEXT, p_user_data: *mut c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseOutStructure {
    pub s_type: StructureType,
    pub p_next: *mut BaseOutStructure,
}
unsafe impl Send for BaseOutStructure {}
unsafe impl Sync for BaseOutStructure {}
impl default::Default for BaseOutStructure {
    fn default() -> Self {
        Self {
            s_type: StructureType::default(),
            p_next: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for BaseOutStructure {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BaseOutStructure")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseInStructure {
    pub s_type: StructureType,
    pub p_next: *const BaseInStructure,
}
unsafe impl Send for BaseInStructure {}
unsafe impl Sync for BaseInStructure {}
impl default::Default for BaseInStructure {
    fn default() -> Self {
        Self {
            s_type: StructureType::default(),
            p_next: ptr::null(),
        }
    }
}
impl fmt::Debug for BaseInStructure {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BaseInStructure")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
impl default::Default for Offset2D {
    fn default() -> Self {
        Self {
            x: i32::default(),
            y: i32::default(),
        }
    }
}
impl fmt::Debug for Offset2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Offset2D")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl default::Default for Offset3D {
    fn default() -> Self {
        Self {
            x: i32::default(),
            y: i32::default(),
            z: i32::default(),
        }
    }
}
impl fmt::Debug for Offset3D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Offset3D")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
impl default::Default for Extent2D {
    fn default() -> Self {
        Self {
            width: u32::default(),
            height: u32::default(),
        }
    }
}
impl fmt::Debug for Extent2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Extent2D")
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl default::Default for Extent3D {
    fn default() -> Self {
        Self {
            width: u32::default(),
            height: u32::default(),
            depth: u32::default(),
        }
    }
}
impl fmt::Debug for Extent3D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Extent3D")
            .field("width", &self.width)
            .field("height", &self.height)
            .field("depth", &self.depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub min_depth: f32,
    pub max_depth: f32,
}
impl default::Default for Viewport {
    fn default() -> Self {
        Self {
            x: f32::default(),
            y: f32::default(),
            width: f32::default(),
            height: f32::default(),
            min_depth: f32::default(),
            max_depth: f32::default(),
        }
    }
}
impl fmt::Debug for Viewport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Viewport")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("min_depth", &self.min_depth)
            .field("max_depth", &self.max_depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
impl default::Default for Rect2D {
    fn default() -> Self {
        Self {
            offset: Offset2D::default(),
            extent: Extent2D::default(),
        }
    }
}
impl fmt::Debug for Rect2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Rect2D")
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ClearRect {
    pub rect: Rect2D,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl default::Default for ClearRect {
    fn default() -> Self {
        Self {
            rect: Rect2D::default(),
            base_array_layer: u32::default(),
            layer_count: u32::default(),
        }
    }
}
impl fmt::Debug for ClearRect {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearRect")
            .field("rect", &self.rect)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
impl default::Default for ComponentMapping {
    fn default() -> Self {
        Self {
            r: ComponentSwizzle::default(),
            g: ComponentSwizzle::default(),
            b: ComponentSwizzle::default(),
            a: ComponentSwizzle::default(),
        }
    }
}
impl fmt::Debug for ComponentMapping {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ComponentMapping")
            .field("r", &self.r)
            .field("g", &self.g)
            .field("b", &self.b)
            .field("a", &self.a)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties {
    pub api_version: Version,
    pub driver_version: u32,
    pub vendor_id: u32,
    pub device_id: u32,
    pub device_type: PhysicalDeviceType,
    pub device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE],
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
    pub limits: PhysicalDeviceLimits,
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
impl default::Default for PhysicalDeviceProperties {
    fn default() -> Self {
        Self {
            api_version: Version::default(),
            driver_version: u32::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            device_type: PhysicalDeviceType::default(),
            device_name: [c_char::default(); MAX_PHYSICAL_DEVICE_NAME_SIZE],
            pipeline_cache_uuid: [u8::default(); UUID_SIZE],
            limits: PhysicalDeviceLimits::default(),
            sparse_properties: PhysicalDeviceSparseProperties::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties")
            .field("api_version", &self.api_version)
            .field("driver_version", &self.driver_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("device_type", &self.device_type)
            .field("device_name", &unsafe { CStr::from_ptr(self.device_name.as_ptr()) })
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .field("limits", &self.limits)
            .field("sparse_properties", &self.sparse_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtensionProperties {
    /// extension name
    pub extension_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    /// version of the extension specification implemented
    pub spec_version: u32,
}
impl default::Default for ExtensionProperties {
    fn default() -> Self {
        Self {
            extension_name: [c_char::default(); MAX_EXTENSION_NAME_SIZE],
            spec_version: u32::default(),
        }
    }
}
impl fmt::Debug for ExtensionProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExtensionProperties")
            .field("extension_name", &unsafe {
                CStr::from_ptr(self.extension_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LayerProperties {
    /// layer name
    pub layer_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    /// version of the layer specification implemented
    pub spec_version: Version,
    /// build or release version of the layer's library
    pub implementation_version: u32,
    /// Free-form description of the layer
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
impl default::Default for LayerProperties {
    fn default() -> Self {
        Self {
            layer_name: [c_char::default(); MAX_EXTENSION_NAME_SIZE],
            spec_version: Version::default(),
            implementation_version: u32::default(),
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
        }
    }
}
impl fmt::Debug for LayerProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("LayerProperties")
            .field("layer_name", &unsafe { CStr::from_ptr(self.layer_name.as_ptr()) })
            .field("spec_version", &self.spec_version)
            .field("implementation_version", &self.implementation_version)
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ApplicationInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_application_name: *const c_char,
    pub application_version: u32,
    pub p_engine_name: *const c_char,
    pub engine_version: u32,
    pub api_version: Version,
}
unsafe impl Send for ApplicationInfo {}
unsafe impl Sync for ApplicationInfo {}
impl default::Default for ApplicationInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::APPLICATION_INFO,
            p_next: ptr::null(),
            p_application_name: ptr::null(),
            application_version: u32::default(),
            p_engine_name: ptr::null(),
            engine_version: u32::default(),
            api_version: Version::default(),
        }
    }
}
impl fmt::Debug for ApplicationInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ApplicationInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_application_name", &self.p_application_name)
            .field("application_version", &self.application_version)
            .field("p_engine_name", &self.p_engine_name)
            .field("engine_version", &self.engine_version)
            .field("api_version", &self.api_version)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AllocationCallbacks {
    pub p_user_data: *mut c_void,
    pub pfn_allocation: Option<FnAllocationFunction>,
    pub pfn_reallocation: Option<FnReallocationFunction>,
    pub pfn_free: Option<FnFreeFunction>,
    pub pfn_internal_allocation: Option<FnInternalAllocationNotification>,
    pub pfn_internal_free: Option<FnInternalFreeNotification>,
}
unsafe impl Send for AllocationCallbacks {}
unsafe impl Sync for AllocationCallbacks {}
impl default::Default for AllocationCallbacks {
    fn default() -> Self {
        Self {
            p_user_data: ptr::null_mut(),
            pfn_allocation: None,
            pfn_reallocation: None,
            pfn_free: None,
            pfn_internal_allocation: None,
            pfn_internal_free: None,
        }
    }
}
impl fmt::Debug for AllocationCallbacks {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AllocationCallbacks")
            .field("p_user_data", &self.p_user_data)
            .field(
                "pfn_allocation",
                if self.pfn_allocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field(
                "pfn_reallocation",
                if self.pfn_reallocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("pfn_free", if self.pfn_free.is_some() { &"Some" } else { &"None" })
            .field(
                "pfn_internal_allocation",
                if self.pfn_internal_allocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field(
                "pfn_internal_free",
                if self.pfn_internal_free.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_count: u32,
    pub p_queue_priorities: *const f32,
}
unsafe impl Send for DeviceQueueCreateInfo {}
unsafe impl Sync for DeviceQueueCreateInfo {}
impl default::Default for DeviceQueueCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_CREATE_INFO,
            p_next: ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_count: u32::default(),
            p_queue_priorities: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceQueueCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .field("queue_count", &self.queue_count)
            .field("p_queue_priorities", &self.p_queue_priorities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceCreateFlags,
    pub queue_create_info_count: u32,
    pub p_queue_create_infos: *const DeviceQueueCreateInfo,
    pub enabled_layer_count: u32,
    /// Ordered list of layer names to be enabled
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
    pub p_enabled_features: *const PhysicalDeviceFeatures,
}
unsafe impl Send for DeviceCreateInfo {}
unsafe impl Sync for DeviceCreateInfo {}
impl default::Default for DeviceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_CREATE_INFO,
            p_next: ptr::null(),
            flags: DeviceCreateFlags::default(),
            queue_create_info_count: u32::default(),
            p_queue_create_infos: ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ptr::null(),
            p_enabled_features: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_create_info_count", &self.queue_create_info_count)
            .field("p_queue_create_infos", &self.p_queue_create_infos)
            .field("enabled_layer_count", &self.enabled_layer_count)
            .field("pp_enabled_layer_names", &self.pp_enabled_layer_names)
            .field("enabled_extension_count", &self.enabled_extension_count)
            .field("pp_enabled_extension_names", &self.pp_enabled_extension_names)
            .field("p_enabled_features", &self.p_enabled_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InstanceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: InstanceCreateFlags,
    pub p_application_info: *const ApplicationInfo,
    pub enabled_layer_count: u32,
    /// Ordered list of layer names to be enabled
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    /// Extension names to be enabled
    pub pp_enabled_extension_names: *const *const c_char,
}
unsafe impl Send for InstanceCreateInfo {}
unsafe impl Sync for InstanceCreateInfo {}
impl default::Default for InstanceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::INSTANCE_CREATE_INFO,
            p_next: ptr::null(),
            flags: InstanceCreateFlags::default(),
            p_application_info: ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ptr::null(),
        }
    }
}
impl fmt::Debug for InstanceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InstanceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_application_info", &self.p_application_info)
            .field("enabled_layer_count", &self.enabled_layer_count)
            .field("pp_enabled_layer_names", &self.pp_enabled_layer_names)
            .field("enabled_extension_count", &self.enabled_extension_count)
            .field("pp_enabled_extension_names", &self.pp_enabled_extension_names)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueueFamilyProperties {
    /// Queue flags
    pub queue_flags: QueueFlags,
    pub queue_count: u32,
    pub timestamp_valid_bits: u32,
    /// Minimum alignment requirement for image transfers
    pub min_image_transfer_granularity: Extent3D,
}
impl default::Default for QueueFamilyProperties {
    fn default() -> Self {
        Self {
            queue_flags: QueueFlags::default(),
            queue_count: u32::default(),
            timestamp_valid_bits: u32::default(),
            min_image_transfer_granularity: Extent3D::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyProperties")
            .field("queue_flags", &self.queue_flags)
            .field("queue_count", &self.queue_count)
            .field("timestamp_valid_bits", &self.timestamp_valid_bits)
            .field("min_image_transfer_granularity", &self.min_image_transfer_granularity)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties {
    pub memory_type_count: u32,
    pub memory_types: [MemoryType; MAX_MEMORY_TYPES],
    pub memory_heap_count: u32,
    pub memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
}
impl default::Default for PhysicalDeviceMemoryProperties {
    fn default() -> Self {
        Self {
            memory_type_count: u32::default(),
            memory_types: [MemoryType::default(); MAX_MEMORY_TYPES],
            memory_heap_count: u32::default(),
            memory_heaps: [MemoryHeap::default(); MAX_MEMORY_HEAPS],
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryProperties")
            .field("memory_type_count", &self.memory_type_count)
            .field("memory_types", &self.memory_types)
            .field("memory_heap_count", &self.memory_heap_count)
            .field("memory_heaps", &self.memory_heaps)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Size of memory allocation
    pub allocation_size: DeviceSize,
    /// Index of the of the memory type to allocate from
    pub memory_type_index: u32,
}
unsafe impl Send for MemoryAllocateInfo {}
unsafe impl Sync for MemoryAllocateInfo {}
impl default::Default for MemoryAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ALLOCATE_INFO,
            p_next: ptr::null(),
            allocation_size: DeviceSize::default(),
            memory_type_index: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("allocation_size", &self.allocation_size)
            .field("memory_type_index", &self.memory_type_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryRequirements {
    /// Specified in bytes
    pub size: DeviceSize,
    /// Specified in bytes
    pub alignment: DeviceSize,
    /// Bitmask of the allowed memory type indices into memoryTypes[] for this object
    pub memory_type_bits: u32,
}
impl default::Default for MemoryRequirements {
    fn default() -> Self {
        Self {
            size: DeviceSize::default(),
            alignment: DeviceSize::default(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryRequirements")
            .field("size", &self.size)
            .field("alignment", &self.alignment)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SparseImageFormatProperties {
    pub aspect_mask: ImageAspectFlags,
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
impl default::Default for SparseImageFormatProperties {
    fn default() -> Self {
        Self {
            aspect_mask: ImageAspectFlags::default(),
            image_granularity: Extent3D::default(),
            flags: SparseImageFormatFlags::default(),
        }
    }
}
impl fmt::Debug for SparseImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageFormatProperties")
            .field("aspect_mask", &self.aspect_mask)
            .field("image_granularity", &self.image_granularity)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SparseImageMemoryRequirements {
    pub format_properties: SparseImageFormatProperties,
    pub image_mip_tail_first_lod: u32,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_size: DeviceSize,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_offset: DeviceSize,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_stride: DeviceSize,
}
impl default::Default for SparseImageMemoryRequirements {
    fn default() -> Self {
        Self {
            format_properties: SparseImageFormatProperties::default(),
            image_mip_tail_first_lod: u32::default(),
            image_mip_tail_size: DeviceSize::default(),
            image_mip_tail_offset: DeviceSize::default(),
            image_mip_tail_stride: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryRequirements")
            .field("format_properties", &self.format_properties)
            .field("image_mip_tail_first_lod", &self.image_mip_tail_first_lod)
            .field("image_mip_tail_size", &self.image_mip_tail_size)
            .field("image_mip_tail_offset", &self.image_mip_tail_offset)
            .field("image_mip_tail_stride", &self.image_mip_tail_stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryType {
    /// Memory properties of this memory type
    pub property_flags: MemoryPropertyFlags,
    /// Index of the memory heap allocations of this memory type are taken from
    pub heap_index: u32,
}
impl default::Default for MemoryType {
    fn default() -> Self {
        Self {
            property_flags: MemoryPropertyFlags::default(),
            heap_index: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryType {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryType")
            .field("property_flags", &self.property_flags)
            .field("heap_index", &self.heap_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct MemoryHeap {
    /// Available memory in the heap
    pub size: DeviceSize,
    /// Flags for the heap
    pub flags: MemoryHeapFlags,
}
impl default::Default for MemoryHeap {
    fn default() -> Self {
        Self {
            size: DeviceSize::default(),
            flags: MemoryHeapFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryHeap {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryHeap")
            .field("size", &self.size)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MappedMemoryRange {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Mapped memory object
    pub memory: Option<DeviceMemory>,
    /// Offset within the memory object where the range starts
    pub offset: DeviceSize,
    /// Size of the range within the memory object
    pub size: DeviceSize,
}
unsafe impl Send for MappedMemoryRange {}
unsafe impl Sync for MappedMemoryRange {}
impl default::Default for MappedMemoryRange {
    fn default() -> Self {
        Self {
            s_type: StructureType::MAPPED_MEMORY_RANGE,
            p_next: ptr::null(),
            memory: None,
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for MappedMemoryRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MappedMemoryRange")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct FormatProperties {
    /// Format features in case of linear tiling
    pub linear_tiling_features: FormatFeatureFlags,
    /// Format features in case of optimal tiling
    pub optimal_tiling_features: FormatFeatureFlags,
    /// Format features supported by buffers
    pub buffer_features: FormatFeatureFlags,
}
impl default::Default for FormatProperties {
    fn default() -> Self {
        Self {
            linear_tiling_features: FormatFeatureFlags::default(),
            optimal_tiling_features: FormatFeatureFlags::default(),
            buffer_features: FormatFeatureFlags::default(),
        }
    }
}
impl fmt::Debug for FormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties")
            .field("linear_tiling_features", &self.linear_tiling_features)
            .field("optimal_tiling_features", &self.optimal_tiling_features)
            .field("buffer_features", &self.buffer_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageFormatProperties {
    /// max image dimensions for this resource type
    pub max_extent: Extent3D,
    /// max number of mipmap levels for this resource type
    pub max_mip_levels: u32,
    /// max array size for this resource type
    pub max_array_layers: u32,
    /// supported sample counts for this resource type
    pub sample_counts: SampleCountFlags,
    /// max size (in bytes) of this resource type
    pub max_resource_size: DeviceSize,
}
impl default::Default for ImageFormatProperties {
    fn default() -> Self {
        Self {
            max_extent: Extent3D::default(),
            max_mip_levels: u32::default(),
            max_array_layers: u32::default(),
            sample_counts: SampleCountFlags::default(),
            max_resource_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for ImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatProperties")
            .field("max_extent", &self.max_extent)
            .field("max_mip_levels", &self.max_mip_levels)
            .field("max_array_layers", &self.max_array_layers)
            .field("sample_counts", &self.sample_counts)
            .field("max_resource_size", &self.max_resource_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorBufferInfo {
    /// Buffer used for this descriptor slot.
    pub buffer: Option<Buffer>,
    /// Base offset from buffer start in bytes to update in the descriptor set.
    pub offset: DeviceSize,
    /// Size in bytes of the buffer resource for this descriptor update.
    pub range: DeviceSize,
}
impl default::Default for DescriptorBufferInfo {
    fn default() -> Self {
        Self {
            buffer: None,
            offset: DeviceSize::default(),
            range: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for DescriptorBufferInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorBufferInfo")
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("range", &self.range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorImageInfo {
    /// Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    pub sampler: Option<Sampler>,
    /// Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    pub image_view: Option<ImageView>,
    /// Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
    pub image_layout: ImageLayout,
}
impl default::Default for DescriptorImageInfo {
    fn default() -> Self {
        Self {
            sampler: None,
            image_view: None,
            image_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for DescriptorImageInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorImageInfo")
            .field("sampler", &self.sampler)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Destination descriptor set
    pub dst_set: Option<DescriptorSet>,
    /// Binding within the destination descriptor set to write
    pub dst_binding: u32,
    /// Array element within the destination binding to write
    pub dst_array_element: u32,
    /// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    pub descriptor_count: u32,
    /// Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    pub descriptor_type: DescriptorType,
    /// Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pub p_image_info: *const DescriptorImageInfo,
    /// Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pub p_buffer_info: *const DescriptorBufferInfo,
    /// Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
    pub p_texel_buffer_view: *const BufferView,
}
unsafe impl Send for WriteDescriptorSet {}
unsafe impl Sync for WriteDescriptorSet {}
impl default::Default for WriteDescriptorSet {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET,
            p_next: ptr::null(),
            dst_set: None,
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
            descriptor_type: DescriptorType::default(),
            p_image_info: ptr::null(),
            p_buffer_info: ptr::null(),
            p_texel_buffer_view: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSet {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSet")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dst_set", &self.dst_set)
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .field("descriptor_type", &self.descriptor_type)
            .field("p_image_info", &self.p_image_info)
            .field("p_buffer_info", &self.p_buffer_info)
            .field("p_texel_buffer_view", &self.p_texel_buffer_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Source descriptor set
    pub src_set: Option<DescriptorSet>,
    /// Binding within the source descriptor set to copy from
    pub src_binding: u32,
    /// Array element within the source binding to copy from
    pub src_array_element: u32,
    /// Destination descriptor set
    pub dst_set: Option<DescriptorSet>,
    /// Binding within the destination descriptor set to copy to
    pub dst_binding: u32,
    /// Array element within the destination binding to copy to
    pub dst_array_element: u32,
    /// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    pub descriptor_count: u32,
}
unsafe impl Send for CopyDescriptorSet {}
unsafe impl Sync for CopyDescriptorSet {}
impl default::Default for CopyDescriptorSet {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_DESCRIPTOR_SET,
            p_next: ptr::null(),
            src_set: None,
            src_binding: u32::default(),
            src_array_element: u32::default(),
            dst_set: None,
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
        }
    }
}
impl fmt::Debug for CopyDescriptorSet {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyDescriptorSet")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_set", &self.src_set)
            .field("src_binding", &self.src_binding)
            .field("src_array_element", &self.src_array_element)
            .field("dst_set", &self.dst_set)
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Buffer creation flags
    pub flags: BufferCreateFlags,
    /// Specified in bytes
    pub size: DeviceSize,
    /// Buffer usage flags
    pub usage: BufferUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
unsafe impl Send for BufferCreateInfo {}
unsafe impl Sync for BufferCreateInfo {}
impl default::Default for BufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_CREATE_INFO,
            p_next: ptr::null(),
            flags: BufferCreateFlags::default(),
            size: DeviceSize::default(),
            usage: BufferUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("size", &self.size)
            .field("usage", &self.usage)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferViewCreateFlags,
    pub buffer: Option<Buffer>,
    /// Optionally specifies format of elements
    pub format: Format,
    /// Specified in bytes
    pub offset: DeviceSize,
    /// View size specified in bytes
    pub range: DeviceSize,
}
unsafe impl Send for BufferViewCreateInfo {}
unsafe impl Sync for BufferViewCreateInfo {}
impl default::Default for BufferViewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_VIEW_CREATE_INFO,
            p_next: ptr::null(),
            flags: BufferViewCreateFlags::default(),
            buffer: None,
            format: Format::default(),
            offset: DeviceSize::default(),
            range: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BufferViewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferViewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("buffer", &self.buffer)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .field("range", &self.range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageSubresource {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub array_layer: u32,
}
impl default::Default for ImageSubresource {
    fn default() -> Self {
        Self {
            aspect_mask: ImageAspectFlags::default(),
            mip_level: u32::default(),
            array_layer: u32::default(),
        }
    }
}
impl fmt::Debug for ImageSubresource {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresource")
            .field("aspect_mask", &self.aspect_mask)
            .field("mip_level", &self.mip_level)
            .field("array_layer", &self.array_layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageSubresourceLayers {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl default::Default for ImageSubresourceLayers {
    fn default() -> Self {
        Self {
            aspect_mask: ImageAspectFlags::default(),
            mip_level: u32::default(),
            base_array_layer: u32::default(),
            layer_count: u32::default(),
        }
    }
}
impl fmt::Debug for ImageSubresourceLayers {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresourceLayers")
            .field("aspect_mask", &self.aspect_mask)
            .field("mip_level", &self.mip_level)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageSubresourceRange {
    pub aspect_mask: ImageAspectFlags,
    pub base_mip_level: u32,
    pub level_count: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl default::Default for ImageSubresourceRange {
    fn default() -> Self {
        Self {
            aspect_mask: ImageAspectFlags::default(),
            base_mip_level: u32::default(),
            level_count: u32::default(),
            base_array_layer: u32::default(),
            layer_count: u32::default(),
        }
    }
}
impl fmt::Debug for ImageSubresourceRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresourceRange")
            .field("aspect_mask", &self.aspect_mask)
            .field("base_mip_level", &self.base_mip_level)
            .field("level_count", &self.level_count)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
}
unsafe impl Send for MemoryBarrier {}
unsafe impl Sync for MemoryBarrier {}
impl default::Default for MemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    /// Queue family to transition ownership from
    pub src_queue_family_index: u32,
    /// Queue family to transition ownership to
    pub dst_queue_family_index: u32,
    /// Buffer to sync
    pub buffer: Option<Buffer>,
    /// Offset within the buffer to sync
    pub offset: DeviceSize,
    /// Amount of bytes to sync
    pub size: DeviceSize,
}
unsafe impl Send for BufferMemoryBarrier {}
unsafe impl Sync for BufferMemoryBarrier {}
impl default::Default for BufferMemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: None,
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BufferMemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    /// Current layout of the image
    pub old_layout: ImageLayout,
    /// New layout to transition the image to
    pub new_layout: ImageLayout,
    /// Queue family to transition ownership from
    pub src_queue_family_index: u32,
    /// Queue family to transition ownership to
    pub dst_queue_family_index: u32,
    /// Image to sync
    pub image: Option<Image>,
    /// Subresource range to sync
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageMemoryBarrier {}
unsafe impl Sync for ImageMemoryBarrier {}
impl default::Default for ImageMemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: None,
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
impl fmt::Debug for ImageMemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("old_layout", &self.old_layout)
            .field("new_layout", &self.new_layout)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("image", &self.image)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image creation flags
    pub flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub samples: SampleCountFlags,
    pub tiling: ImageTiling,
    /// Image usage flags
    pub usage: ImageUsageFlags,
    /// Cross-queue-family sharing mode
    pub sharing_mode: SharingMode,
    /// Number of queue families to share across
    pub queue_family_index_count: u32,
    /// Array of queue family indices to share across
    pub p_queue_family_indices: *const u32,
    /// Initial image layout for all subresources
    pub initial_layout: ImageLayout,
}
unsafe impl Send for ImageCreateInfo {}
unsafe impl Sync for ImageCreateInfo {}
impl default::Default for ImageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_CREATE_INFO,
            p_next: ptr::null(),
            flags: ImageCreateFlags::default(),
            image_type: ImageType::default(),
            format: Format::default(),
            extent: Extent3D::default(),
            mip_levels: u32::default(),
            array_layers: u32::default(),
            samples: SampleCountFlags::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ptr::null(),
            initial_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for ImageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image_type", &self.image_type)
            .field("format", &self.format)
            .field("extent", &self.extent)
            .field("mip_levels", &self.mip_levels)
            .field("array_layers", &self.array_layers)
            .field("samples", &self.samples)
            .field("tiling", &self.tiling)
            .field("usage", &self.usage)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .field("initial_layout", &self.initial_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SubresourceLayout {
    /// Specified in bytes
    pub offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
    /// Specified in bytes
    pub row_pitch: DeviceSize,
    /// Specified in bytes
    pub array_pitch: DeviceSize,
    /// Specified in bytes
    pub depth_pitch: DeviceSize,
}
impl default::Default for SubresourceLayout {
    fn default() -> Self {
        Self {
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            row_pitch: DeviceSize::default(),
            array_pitch: DeviceSize::default(),
            depth_pitch: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for SubresourceLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubresourceLayout")
            .field("offset", &self.offset)
            .field("size", &self.size)
            .field("row_pitch", &self.row_pitch)
            .field("array_pitch", &self.array_pitch)
            .field("depth_pitch", &self.depth_pitch)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageViewCreateFlags,
    pub image: Option<Image>,
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageViewCreateInfo {}
unsafe impl Sync for ImageViewCreateInfo {}
impl default::Default for ImageViewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_CREATE_INFO,
            p_next: ptr::null(),
            flags: ImageViewCreateFlags::default(),
            image: None,
            view_type: ImageViewType::default(),
            format: Format::default(),
            components: ComponentMapping::default(),
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
impl fmt::Debug for ImageViewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image", &self.image)
            .field("view_type", &self.view_type)
            .field("format", &self.format)
            .field("components", &self.components)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferCopy {
    /// Specified in bytes
    pub src_offset: DeviceSize,
    /// Specified in bytes
    pub dst_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
}
impl default::Default for BufferCopy {
    fn default() -> Self {
        Self {
            src_offset: DeviceSize::default(),
            dst_offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BufferCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCopy")
            .field("src_offset", &self.src_offset)
            .field("dst_offset", &self.dst_offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseMemoryBind {
    /// Specified in bytes
    pub resource_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
    pub memory: Option<DeviceMemory>,
    /// Specified in bytes
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl default::Default for SparseMemoryBind {
    fn default() -> Self {
        Self {
            resource_offset: DeviceSize::default(),
            size: DeviceSize::default(),
            memory: None,
            memory_offset: DeviceSize::default(),
            flags: SparseMemoryBindFlags::default(),
        }
    }
}
impl fmt::Debug for SparseMemoryBind {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseMemoryBind")
            .field("resource_offset", &self.resource_offset)
            .field("size", &self.size)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageMemoryBind {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: Option<DeviceMemory>,
    /// Specified in bytes
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl default::Default for SparseImageMemoryBind {
    fn default() -> Self {
        Self {
            subresource: ImageSubresource::default(),
            offset: Offset3D::default(),
            extent: Extent3D::default(),
            memory: None,
            memory_offset: DeviceSize::default(),
            flags: SparseMemoryBindFlags::default(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryBind {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryBind")
            .field("subresource", &self.subresource)
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseBufferMemoryBindInfo {
    pub buffer: Option<Buffer>,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
unsafe impl Send for SparseBufferMemoryBindInfo {}
unsafe impl Sync for SparseBufferMemoryBindInfo {}
impl default::Default for SparseBufferMemoryBindInfo {
    fn default() -> Self {
        Self {
            buffer: None,
            bind_count: u32::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseBufferMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseBufferMemoryBindInfo")
            .field("buffer", &self.buffer)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageOpaqueMemoryBindInfo {
    pub image: Option<Image>,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
unsafe impl Send for SparseImageOpaqueMemoryBindInfo {}
unsafe impl Sync for SparseImageOpaqueMemoryBindInfo {}
impl default::Default for SparseImageOpaqueMemoryBindInfo {
    fn default() -> Self {
        Self {
            image: None,
            bind_count: u32::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseImageOpaqueMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageOpaqueMemoryBindInfo")
            .field("image", &self.image)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageMemoryBindInfo {
    pub image: Option<Image>,
    pub bind_count: u32,
    pub p_binds: *const SparseImageMemoryBind,
}
unsafe impl Send for SparseImageMemoryBindInfo {}
unsafe impl Sync for SparseImageMemoryBindInfo {}
impl default::Default for SparseImageMemoryBindInfo {
    fn default() -> Self {
        Self {
            image: None,
            bind_count: u32::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryBindInfo")
            .field("image", &self.image)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub buffer_bind_count: u32,
    pub p_buffer_binds: *const SparseBufferMemoryBindInfo,
    pub image_opaque_bind_count: u32,
    pub p_image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo,
    pub image_bind_count: u32,
    pub p_image_binds: *const SparseImageMemoryBindInfo,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
unsafe impl Send for BindSparseInfo {}
unsafe impl Sync for BindSparseInfo {}
impl default::Default for BindSparseInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_SPARSE_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ptr::null(),
            buffer_bind_count: u32::default(),
            p_buffer_binds: ptr::null(),
            image_opaque_bind_count: u32::default(),
            p_image_opaque_binds: ptr::null(),
            image_bind_count: u32::default(),
            p_image_binds: ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ptr::null(),
        }
    }
}
impl fmt::Debug for BindSparseInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindSparseInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("buffer_bind_count", &self.buffer_bind_count)
            .field("p_buffer_binds", &self.p_buffer_binds)
            .field("image_opaque_bind_count", &self.image_opaque_bind_count)
            .field("p_image_opaque_binds", &self.p_image_opaque_binds)
            .field("image_bind_count", &self.image_bind_count)
            .field("p_image_binds", &self.p_image_binds)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field("p_signal_semaphores", &self.p_signal_semaphores)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageCopy {
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub extent: Extent3D,
}
impl default::Default for ImageCopy {
    fn default() -> Self {
        Self {
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for ImageCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCopy")
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageBlit {
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offsets: [Offset3D; 2],
}
impl default::Default for ImageBlit {
    fn default() -> Self {
        Self {
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: [Offset3D::default(); 2],
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: [Offset3D::default(); 2],
        }
    }
}
impl fmt::Debug for ImageBlit {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageBlit")
            .field("src_subresource", &self.src_subresource)
            .field("src_offsets", &self.src_offsets)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offsets", &self.dst_offsets)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferImageCopy {
    /// Specified in bytes
    pub buffer_offset: DeviceSize,
    /// Specified in texels
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_extent: Extent3D,
}
impl default::Default for BufferImageCopy {
    fn default() -> Self {
        Self {
            buffer_offset: DeviceSize::default(),
            buffer_row_length: u32::default(),
            buffer_image_height: u32::default(),
            image_subresource: ImageSubresourceLayers::default(),
            image_offset: Offset3D::default(),
            image_extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for BufferImageCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferImageCopy")
            .field("buffer_offset", &self.buffer_offset)
            .field("buffer_row_length", &self.buffer_row_length)
            .field("buffer_image_height", &self.buffer_image_height)
            .field("image_subresource", &self.image_subresource)
            .field("image_offset", &self.image_offset)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageResolve {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl default::Default for ImageResolve {
    fn default() -> Self {
        Self {
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for ImageResolve {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageResolve")
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderModuleCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ShaderModuleCreateFlags,
    /// Specified in bytes
    pub code_size: usize,
    /// Binary code of size codeSize
    pub p_code: *const u32,
}
unsafe impl Send for ShaderModuleCreateInfo {}
unsafe impl Sync for ShaderModuleCreateInfo {}
impl default::Default for ShaderModuleCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHADER_MODULE_CREATE_INFO,
            p_next: ptr::null(),
            flags: ShaderModuleCreateFlags::default(),
            code_size: usize::default(),
            p_code: ptr::null(),
        }
    }
}
impl fmt::Debug for ShaderModuleCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderModuleCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("code_size", &self.code_size)
            .field("p_code", &self.p_code)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutBinding {
    /// Binding number for this entry
    pub binding: u32,
    /// Type of the descriptors in this binding
    pub descriptor_type: DescriptorType,
    /// Number of descriptors in this binding
    pub descriptor_count: u32,
    /// Shader stages this binding is visible to
    pub stage_flags: ShaderStageFlags,
    /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
    pub p_immutable_samplers: *const Sampler,
}
unsafe impl Send for DescriptorSetLayoutBinding {}
unsafe impl Sync for DescriptorSetLayoutBinding {}
impl default::Default for DescriptorSetLayoutBinding {
    fn default() -> Self {
        Self {
            binding: u32::default(),
            descriptor_type: DescriptorType::default(),
            descriptor_count: u32::default(),
            stage_flags: ShaderStageFlags::default(),
            p_immutable_samplers: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutBinding {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutBinding")
            .field("binding", &self.binding)
            .field("descriptor_type", &self.descriptor_type)
            .field("descriptor_count", &self.descriptor_count)
            .field("stage_flags", &self.stage_flags)
            .field("p_immutable_samplers", &self.p_immutable_samplers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorSetLayoutCreateFlags,
    /// Number of bindings in the descriptor set layout
    pub binding_count: u32,
    /// Array of descriptor set layout bindings
    pub p_bindings: *const DescriptorSetLayoutBinding,
}
unsafe impl Send for DescriptorSetLayoutCreateInfo {}
unsafe impl Sync for DescriptorSetLayoutCreateInfo {}
impl default::Default for DescriptorSetLayoutCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            p_next: ptr::null(),
            flags: DescriptorSetLayoutCreateFlags::default(),
            binding_count: u32::default(),
            p_bindings: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("binding_count", &self.binding_count)
            .field("p_bindings", &self.p_bindings)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorPoolSize {
    pub ty: DescriptorType,
    pub descriptor_count: u32,
}
impl default::Default for DescriptorPoolSize {
    fn default() -> Self {
        Self {
            ty: DescriptorType::default(),
            descriptor_count: u32::default(),
        }
    }
}
impl fmt::Debug for DescriptorPoolSize {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolSize")
            .field("ty", &self.ty)
            .field("descriptor_count", &self.descriptor_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorPoolCreateFlags,
    pub max_sets: u32,
    pub pool_size_count: u32,
    pub p_pool_sizes: *const DescriptorPoolSize,
}
unsafe impl Send for DescriptorPoolCreateInfo {}
unsafe impl Sync for DescriptorPoolCreateInfo {}
impl default::Default for DescriptorPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: DescriptorPoolCreateFlags::default(),
            max_sets: u32::default(),
            pool_size_count: u32::default(),
            p_pool_sizes: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("max_sets", &self.max_sets)
            .field("pool_size_count", &self.pool_size_count)
            .field("p_pool_sizes", &self.p_pool_sizes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_pool: Option<DescriptorPool>,
    pub descriptor_set_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
}
unsafe impl Send for DescriptorSetAllocateInfo {}
unsafe impl Sync for DescriptorSetAllocateInfo {}
impl default::Default for DescriptorSetAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_ALLOCATE_INFO,
            p_next: ptr::null(),
            descriptor_pool: None,
            descriptor_set_count: u32::default(),
            p_set_layouts: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_pool", &self.descriptor_pool)
            .field("descriptor_set_count", &self.descriptor_set_count)
            .field("p_set_layouts", &self.p_set_layouts)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SpecializationMapEntry {
    /// The SpecConstant ID specified in the BIL
    pub constant_id: u32,
    /// Offset of the value in the data block
    pub offset: u32,
    /// Size in bytes of the SpecConstant
    pub size: usize,
}
impl default::Default for SpecializationMapEntry {
    fn default() -> Self {
        Self {
            constant_id: u32::default(),
            offset: u32::default(),
            size: usize::default(),
        }
    }
}
impl fmt::Debug for SpecializationMapEntry {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SpecializationMapEntry")
            .field("constant_id", &self.constant_id)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpecializationInfo {
    /// Number of entries in the map
    pub map_entry_count: u32,
    /// Array of map entries
    pub p_map_entries: *const SpecializationMapEntry,
    /// Size in bytes of pData
    pub data_size: usize,
    /// Pointer to SpecConstant data
    pub p_data: *const c_void,
}
unsafe impl Send for SpecializationInfo {}
unsafe impl Sync for SpecializationInfo {}
impl default::Default for SpecializationInfo {
    fn default() -> Self {
        Self {
            map_entry_count: u32::default(),
            p_map_entries: ptr::null(),
            data_size: usize::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for SpecializationInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SpecializationInfo")
            .field("map_entry_count", &self.map_entry_count)
            .field("p_map_entries", &self.p_map_entries)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineShaderStageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineShaderStageCreateFlags,
    /// Shader stage
    pub stage: ShaderStageFlags,
    /// Module containing entry point
    pub module: Option<ShaderModule>,
    /// Null-terminated entry point name
    pub p_name: *const c_char,
    pub p_specialization_info: *const SpecializationInfo,
}
unsafe impl Send for PipelineShaderStageCreateInfo {}
unsafe impl Sync for PipelineShaderStageCreateInfo {}
impl default::Default for PipelineShaderStageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineShaderStageCreateFlags::default(),
            stage: ShaderStageFlags::default(),
            module: None,
            p_name: ptr::null(),
            p_specialization_info: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineShaderStageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineShaderStageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage", &self.stage)
            .field("module", &self.module)
            .field("p_name", &self.p_name)
            .field("p_specialization_info", &self.p_specialization_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ComputePipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for ComputePipelineCreateInfo {}
unsafe impl Sync for ComputePipelineCreateInfo {}
impl default::Default for ComputePipelineCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMPUTE_PIPELINE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage: PipelineShaderStageCreateInfo::default(),
            layout: None,
            base_pipeline_handle: None,
            base_pipeline_index: i32::default(),
        }
    }
}
impl fmt::Debug for ComputePipelineCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ComputePipelineCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage", &self.stage)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct VertexInputBindingDescription {
    /// Vertex buffer binding id
    pub binding: u32,
    /// Distance between vertices in bytes (0 = no advancement)
    pub stride: u32,
    /// The rate at which the vertex data is consumed
    pub input_rate: VertexInputRate,
}
impl default::Default for VertexInputBindingDescription {
    fn default() -> Self {
        Self {
            binding: u32::default(),
            stride: u32::default(),
            input_rate: VertexInputRate::default(),
        }
    }
}
impl fmt::Debug for VertexInputBindingDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDescription")
            .field("binding", &self.binding)
            .field("stride", &self.stride)
            .field("input_rate", &self.input_rate)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct VertexInputAttributeDescription {
    /// location of the shader vertex attrib
    pub location: u32,
    /// Vertex buffer binding id
    pub binding: u32,
    /// format of source data
    pub format: Format,
    /// Offset of first element in bytes from base of vertex
    pub offset: u32,
}
impl default::Default for VertexInputAttributeDescription {
    fn default() -> Self {
        Self {
            location: u32::default(),
            binding: u32::default(),
            format: Format::default(),
            offset: u32::default(),
        }
    }
}
impl fmt::Debug for VertexInputAttributeDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputAttributeDescription")
            .field("location", &self.location)
            .field("binding", &self.binding)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineVertexInputStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineVertexInputStateCreateFlags,
    /// number of bindings
    pub vertex_binding_description_count: u32,
    pub p_vertex_binding_descriptions: *const VertexInputBindingDescription,
    /// number of attributes
    pub vertex_attribute_description_count: u32,
    pub p_vertex_attribute_descriptions: *const VertexInputAttributeDescription,
}
unsafe impl Send for PipelineVertexInputStateCreateInfo {}
unsafe impl Sync for PipelineVertexInputStateCreateInfo {}
impl default::Default for PipelineVertexInputStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineVertexInputStateCreateFlags::default(),
            vertex_binding_description_count: u32::default(),
            p_vertex_binding_descriptions: ptr::null(),
            vertex_attribute_description_count: u32::default(),
            p_vertex_attribute_descriptions: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineVertexInputStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineVertexInputStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "vertex_binding_description_count",
                &self.vertex_binding_description_count,
            )
            .field("p_vertex_binding_descriptions", &self.p_vertex_binding_descriptions)
            .field(
                "vertex_attribute_description_count",
                &self.vertex_attribute_description_count,
            )
            .field("p_vertex_attribute_descriptions", &self.p_vertex_attribute_descriptions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineInputAssemblyStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineInputAssemblyStateCreateFlags,
    pub topology: PrimitiveTopology,
    pub primitive_restart_enable: Bool32,
}
unsafe impl Send for PipelineInputAssemblyStateCreateInfo {}
unsafe impl Sync for PipelineInputAssemblyStateCreateInfo {}
impl default::Default for PipelineInputAssemblyStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineInputAssemblyStateCreateFlags::default(),
            topology: PrimitiveTopology::default(),
            primitive_restart_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PipelineInputAssemblyStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineInputAssemblyStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("topology", &self.topology)
            .field("primitive_restart_enable", &self.primitive_restart_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineTessellationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineTessellationStateCreateFlags,
    pub patch_control_points: u32,
}
unsafe impl Send for PipelineTessellationStateCreateInfo {}
unsafe impl Sync for PipelineTessellationStateCreateInfo {}
impl default::Default for PipelineTessellationStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineTessellationStateCreateFlags::default(),
            patch_control_points: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineTessellationStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineTessellationStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("patch_control_points", &self.patch_control_points)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportStateCreateFlags,
    pub viewport_count: u32,
    pub p_viewports: *const Viewport,
    pub scissor_count: u32,
    pub p_scissors: *const Rect2D,
}
unsafe impl Send for PipelineViewportStateCreateInfo {}
unsafe impl Sync for PipelineViewportStateCreateInfo {}
impl default::Default for PipelineViewportStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineViewportStateCreateFlags::default(),
            viewport_count: u32::default(),
            p_viewports: ptr::null(),
            scissor_count: u32::default(),
            p_scissors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewports", &self.p_viewports)
            .field("scissor_count", &self.scissor_count)
            .field("p_scissors", &self.p_scissors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateCreateFlags,
    pub depth_clamp_enable: Bool32,
    pub rasterizer_discard_enable: Bool32,
    /// optional (GL45)
    pub polygon_mode: PolygonMode,
    pub cull_mode: CullModeFlags,
    pub front_face: FrontFace,
    pub depth_bias_enable: Bool32,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    pub line_width: f32,
}
unsafe impl Send for PipelineRasterizationStateCreateInfo {}
unsafe impl Sync for PipelineRasterizationStateCreateInfo {}
impl default::Default for PipelineRasterizationStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineRasterizationStateCreateFlags::default(),
            depth_clamp_enable: Bool32::default(),
            rasterizer_discard_enable: Bool32::default(),
            polygon_mode: PolygonMode::default(),
            cull_mode: CullModeFlags::default(),
            front_face: FrontFace::default(),
            depth_bias_enable: Bool32::default(),
            depth_bias_constant_factor: f32::default(),
            depth_bias_clamp: f32::default(),
            depth_bias_slope_factor: f32::default(),
            line_width: f32::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_clamp_enable", &self.depth_clamp_enable)
            .field("rasterizer_discard_enable", &self.rasterizer_discard_enable)
            .field("polygon_mode", &self.polygon_mode)
            .field("cull_mode", &self.cull_mode)
            .field("front_face", &self.front_face)
            .field("depth_bias_enable", &self.depth_bias_enable)
            .field("depth_bias_constant_factor", &self.depth_bias_constant_factor)
            .field("depth_bias_clamp", &self.depth_bias_clamp)
            .field("depth_bias_slope_factor", &self.depth_bias_slope_factor)
            .field("line_width", &self.line_width)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineMultisampleStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineMultisampleStateCreateFlags,
    /// Number of samples used for rasterization
    pub rasterization_samples: SampleCountFlags,
    /// optional (GL45)
    pub sample_shading_enable: Bool32,
    /// optional (GL45)
    pub min_sample_shading: f32,
    /// Array of sampleMask words
    pub p_sample_mask: *const SampleMask,
    pub alpha_to_coverage_enable: Bool32,
    pub alpha_to_one_enable: Bool32,
}
unsafe impl Send for PipelineMultisampleStateCreateInfo {}
unsafe impl Sync for PipelineMultisampleStateCreateInfo {}
impl default::Default for PipelineMultisampleStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineMultisampleStateCreateFlags::default(),
            rasterization_samples: SampleCountFlags::default(),
            sample_shading_enable: Bool32::default(),
            min_sample_shading: f32::default(),
            p_sample_mask: ptr::null(),
            alpha_to_coverage_enable: Bool32::default(),
            alpha_to_one_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PipelineMultisampleStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineMultisampleStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("rasterization_samples", &self.rasterization_samples)
            .field("sample_shading_enable", &self.sample_shading_enable)
            .field("min_sample_shading", &self.min_sample_shading)
            .field("p_sample_mask", &self.p_sample_mask)
            .field("alpha_to_coverage_enable", &self.alpha_to_coverage_enable)
            .field("alpha_to_one_enable", &self.alpha_to_one_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineColorBlendAttachmentState {
    pub blend_enable: Bool32,
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
    pub color_write_mask: ColorComponentFlags,
}
impl default::Default for PipelineColorBlendAttachmentState {
    fn default() -> Self {
        Self {
            blend_enable: Bool32::default(),
            src_color_blend_factor: BlendFactor::default(),
            dst_color_blend_factor: BlendFactor::default(),
            color_blend_op: BlendOp::default(),
            src_alpha_blend_factor: BlendFactor::default(),
            dst_alpha_blend_factor: BlendFactor::default(),
            alpha_blend_op: BlendOp::default(),
            color_write_mask: ColorComponentFlags::default(),
        }
    }
}
impl fmt::Debug for PipelineColorBlendAttachmentState {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendAttachmentState")
            .field("blend_enable", &self.blend_enable)
            .field("src_color_blend_factor", &self.src_color_blend_factor)
            .field("dst_color_blend_factor", &self.dst_color_blend_factor)
            .field("color_blend_op", &self.color_blend_op)
            .field("src_alpha_blend_factor", &self.src_alpha_blend_factor)
            .field("dst_alpha_blend_factor", &self.dst_alpha_blend_factor)
            .field("alpha_blend_op", &self.alpha_blend_op)
            .field("color_write_mask", &self.color_write_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorBlendStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineColorBlendStateCreateFlags,
    pub logic_op_enable: Bool32,
    pub logic_op: LogicOp,
    /// # of pAttachments
    pub attachment_count: u32,
    pub p_attachments: *const PipelineColorBlendAttachmentState,
    pub blend_constants: [f32; 4],
}
unsafe impl Send for PipelineColorBlendStateCreateInfo {}
unsafe impl Sync for PipelineColorBlendStateCreateInfo {}
impl default::Default for PipelineColorBlendStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineColorBlendStateCreateFlags::default(),
            logic_op_enable: Bool32::default(),
            logic_op: LogicOp::default(),
            attachment_count: u32::default(),
            p_attachments: ptr::null(),
            blend_constants: [f32::default(); 4],
        }
    }
}
impl fmt::Debug for PipelineColorBlendStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("logic_op_enable", &self.logic_op_enable)
            .field("logic_op", &self.logic_op)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("blend_constants", &self.blend_constants)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDynamicStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDynamicStateCreateFlags,
    pub dynamic_state_count: u32,
    pub p_dynamic_states: *const DynamicState,
}
unsafe impl Send for PipelineDynamicStateCreateInfo {}
unsafe impl Sync for PipelineDynamicStateCreateInfo {}
impl default::Default for PipelineDynamicStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineDynamicStateCreateFlags::default(),
            dynamic_state_count: u32::default(),
            p_dynamic_states: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineDynamicStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDynamicStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dynamic_state_count", &self.dynamic_state_count)
            .field("p_dynamic_states", &self.p_dynamic_states)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct StencilOpState {
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
    pub compare_op: CompareOp,
    pub compare_mask: u32,
    pub write_mask: u32,
    pub reference: u32,
}
impl default::Default for StencilOpState {
    fn default() -> Self {
        Self {
            fail_op: StencilOp::default(),
            pass_op: StencilOp::default(),
            depth_fail_op: StencilOp::default(),
            compare_op: CompareOp::default(),
            compare_mask: u32::default(),
            write_mask: u32::default(),
            reference: u32::default(),
        }
    }
}
impl fmt::Debug for StencilOpState {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("StencilOpState")
            .field("fail_op", &self.fail_op)
            .field("pass_op", &self.pass_op)
            .field("depth_fail_op", &self.depth_fail_op)
            .field("compare_op", &self.compare_op)
            .field("compare_mask", &self.compare_mask)
            .field("write_mask", &self.write_mask)
            .field("reference", &self.reference)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDepthStencilStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDepthStencilStateCreateFlags,
    pub depth_test_enable: Bool32,
    pub depth_write_enable: Bool32,
    pub depth_compare_op: CompareOp,
    /// optional (depth_bounds_test)
    pub depth_bounds_test_enable: Bool32,
    pub stencil_test_enable: Bool32,
    pub front: StencilOpState,
    pub back: StencilOpState,
    pub min_depth_bounds: f32,
    pub max_depth_bounds: f32,
}
unsafe impl Send for PipelineDepthStencilStateCreateInfo {}
unsafe impl Sync for PipelineDepthStencilStateCreateInfo {}
impl default::Default for PipelineDepthStencilStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineDepthStencilStateCreateFlags::default(),
            depth_test_enable: Bool32::default(),
            depth_write_enable: Bool32::default(),
            depth_compare_op: CompareOp::default(),
            depth_bounds_test_enable: Bool32::default(),
            stencil_test_enable: Bool32::default(),
            front: StencilOpState::default(),
            back: StencilOpState::default(),
            min_depth_bounds: f32::default(),
            max_depth_bounds: f32::default(),
        }
    }
}
impl fmt::Debug for PipelineDepthStencilStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDepthStencilStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_test_enable", &self.depth_test_enable)
            .field("depth_write_enable", &self.depth_write_enable)
            .field("depth_compare_op", &self.depth_compare_op)
            .field("depth_bounds_test_enable", &self.depth_bounds_test_enable)
            .field("stencil_test_enable", &self.stencil_test_enable)
            .field("front", &self.front)
            .field("back", &self.back)
            .field("min_depth_bounds", &self.min_depth_bounds)
            .field("max_depth_bounds", &self.max_depth_bounds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_input_assembly_state: *const PipelineInputAssemblyStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
    pub p_viewport_state: *const PipelineViewportStateCreateInfo,
    pub p_rasterization_state: *const PipelineRasterizationStateCreateInfo,
    pub p_multisample_state: *const PipelineMultisampleStateCreateInfo,
    pub p_depth_stencil_state: *const PipelineDepthStencilStateCreateInfo,
    pub p_color_blend_state: *const PipelineColorBlendStateCreateInfo,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for GraphicsPipelineCreateInfo {}
unsafe impl Sync for GraphicsPipelineCreateInfo {}
impl default::Default for GraphicsPipelineCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_PIPELINE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_input_assembly_state: ptr::null(),
            p_tessellation_state: ptr::null(),
            p_viewport_state: ptr::null(),
            p_rasterization_state: ptr::null(),
            p_multisample_state: ptr::null(),
            p_depth_stencil_state: ptr::null(),
            p_color_blend_state: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: None,
            render_pass: None,
            subpass: u32::default(),
            base_pipeline_handle: None,
            base_pipeline_index: i32::default(),
        }
    }
}
impl fmt::Debug for GraphicsPipelineCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsPipelineCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("p_vertex_input_state", &self.p_vertex_input_state)
            .field("p_input_assembly_state", &self.p_input_assembly_state)
            .field("p_tessellation_state", &self.p_tessellation_state)
            .field("p_viewport_state", &self.p_viewport_state)
            .field("p_rasterization_state", &self.p_rasterization_state)
            .field("p_multisample_state", &self.p_multisample_state)
            .field("p_depth_stencil_state", &self.p_depth_stencil_state)
            .field("p_color_blend_state", &self.p_color_blend_state)
            .field("p_dynamic_state", &self.p_dynamic_state)
            .field("layout", &self.layout)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCacheCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCacheCreateFlags,
    /// Size of initial data to populate cache, in bytes
    pub initial_data_size: usize,
    /// Initial data to populate cache
    pub p_initial_data: *const c_void,
}
unsafe impl Send for PipelineCacheCreateInfo {}
unsafe impl Sync for PipelineCacheCreateInfo {}
impl default::Default for PipelineCacheCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_CACHE_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineCacheCreateFlags::default(),
            initial_data_size: usize::default(),
            p_initial_data: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineCacheCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCacheCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("initial_data_size", &self.initial_data_size)
            .field("p_initial_data", &self.p_initial_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCacheHeaderVersionOne {
    pub header_size: u32,
    pub header_version: PipelineCacheHeaderVersion,
    pub vendor_id: u32,
    pub device_id: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
}
impl default::Default for PipelineCacheHeaderVersionOne {
    fn default() -> Self {
        Self {
            header_size: u32::default(),
            header_version: PipelineCacheHeaderVersion::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            pipeline_cache_uuid: [u8::default(); UUID_SIZE],
        }
    }
}
impl fmt::Debug for PipelineCacheHeaderVersionOne {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCacheHeaderVersionOne")
            .field("header_size", &self.header_size)
            .field("header_version", &self.header_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PushConstantRange {
    /// Which stages use the range
    pub stage_flags: ShaderStageFlags,
    /// Start of the range, in bytes
    pub offset: u32,
    /// Size of the range, in bytes
    pub size: u32,
}
impl default::Default for PushConstantRange {
    fn default() -> Self {
        Self {
            stage_flags: ShaderStageFlags::default(),
            offset: u32::default(),
            size: u32::default(),
        }
    }
}
impl fmt::Debug for PushConstantRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PushConstantRange")
            .field("stage_flags", &self.stage_flags)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineLayoutCreateFlags,
    /// Number of descriptor sets interfaced by the pipeline
    pub set_layout_count: u32,
    /// Array of setCount number of descriptor set layout objects defining the layout of the
    pub p_set_layouts: *const DescriptorSetLayout,
    /// Number of push-constant ranges used by the pipeline
    pub push_constant_range_count: u32,
    /// Array of pushConstantRangeCount number of ranges used by various shader stages
    pub p_push_constant_ranges: *const PushConstantRange,
}
unsafe impl Send for PipelineLayoutCreateInfo {}
unsafe impl Sync for PipelineLayoutCreateInfo {}
impl default::Default for PipelineLayoutCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_LAYOUT_CREATE_INFO,
            p_next: ptr::null(),
            flags: PipelineLayoutCreateFlags::default(),
            set_layout_count: u32::default(),
            p_set_layouts: ptr::null(),
            push_constant_range_count: u32::default(),
            p_push_constant_ranges: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineLayoutCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineLayoutCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("set_layout_count", &self.set_layout_count)
            .field("p_set_layouts", &self.p_set_layouts)
            .field("push_constant_range_count", &self.push_constant_range_count)
            .field("p_push_constant_ranges", &self.p_push_constant_ranges)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SamplerCreateFlags,
    /// Filter mode for magnification
    pub mag_filter: Filter,
    /// Filter mode for minifiation
    pub min_filter: Filter,
    /// Mipmap selection mode
    pub mipmap_mode: SamplerMipmapMode,
    pub address_mode_u: SamplerAddressMode,
    pub address_mode_v: SamplerAddressMode,
    pub address_mode_w: SamplerAddressMode,
    pub mip_lod_bias: f32,
    pub anisotropy_enable: Bool32,
    pub max_anisotropy: f32,
    pub compare_enable: Bool32,
    pub compare_op: CompareOp,
    pub min_lod: f32,
    pub max_lod: f32,
    pub border_color: BorderColor,
    pub unnormalized_coordinates: Bool32,
}
unsafe impl Send for SamplerCreateInfo {}
unsafe impl Sync for SamplerCreateInfo {}
impl default::Default for SamplerCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_CREATE_INFO,
            p_next: ptr::null(),
            flags: SamplerCreateFlags::default(),
            mag_filter: Filter::default(),
            min_filter: Filter::default(),
            mipmap_mode: SamplerMipmapMode::default(),
            address_mode_u: SamplerAddressMode::default(),
            address_mode_v: SamplerAddressMode::default(),
            address_mode_w: SamplerAddressMode::default(),
            mip_lod_bias: f32::default(),
            anisotropy_enable: Bool32::default(),
            max_anisotropy: f32::default(),
            compare_enable: Bool32::default(),
            compare_op: CompareOp::default(),
            min_lod: f32::default(),
            max_lod: f32::default(),
            border_color: BorderColor::default(),
            unnormalized_coordinates: Bool32::default(),
        }
    }
}
impl fmt::Debug for SamplerCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("mag_filter", &self.mag_filter)
            .field("min_filter", &self.min_filter)
            .field("mipmap_mode", &self.mipmap_mode)
            .field("address_mode_u", &self.address_mode_u)
            .field("address_mode_v", &self.address_mode_v)
            .field("address_mode_w", &self.address_mode_w)
            .field("mip_lod_bias", &self.mip_lod_bias)
            .field("anisotropy_enable", &self.anisotropy_enable)
            .field("max_anisotropy", &self.max_anisotropy)
            .field("compare_enable", &self.compare_enable)
            .field("compare_op", &self.compare_op)
            .field("min_lod", &self.min_lod)
            .field("max_lod", &self.max_lod)
            .field("border_color", &self.border_color)
            .field("unnormalized_coordinates", &self.unnormalized_coordinates)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Command pool creation flags
    pub flags: CommandPoolCreateFlags,
    pub queue_family_index: u32,
}
unsafe impl Send for CommandPoolCreateInfo {}
unsafe impl Sync for CommandPoolCreateInfo {}
impl default::Default for CommandPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: CommandPoolCreateFlags::default(),
            queue_family_index: u32::default(),
        }
    }
}
impl fmt::Debug for CommandPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_pool: Option<CommandPool>,
    pub level: CommandBufferLevel,
    pub command_buffer_count: u32,
}
unsafe impl Send for CommandBufferAllocateInfo {}
unsafe impl Sync for CommandBufferAllocateInfo {}
impl default::Default for CommandBufferAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
            p_next: ptr::null(),
            command_pool: None,
            level: CommandBufferLevel::default(),
            command_buffer_count: u32::default(),
        }
    }
}
impl fmt::Debug for CommandBufferAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("command_pool", &self.command_pool)
            .field("level", &self.level)
            .field("command_buffer_count", &self.command_buffer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Render pass for secondary command buffers
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    /// Framebuffer for secondary command buffers
    pub framebuffer: Option<Framebuffer>,
    /// Whether this secondary command buffer may be executed during an occlusion query
    pub occlusion_query_enable: Bool32,
    /// Query flags used by this secondary command buffer, if executed during an occlusion query
    pub query_flags: QueryControlFlags,
    /// Pipeline statistics that may be counted for this secondary command buffer
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
unsafe impl Send for CommandBufferInheritanceInfo {}
unsafe impl Sync for CommandBufferInheritanceInfo {}
impl default::Default for CommandBufferInheritanceInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_INFO,
            p_next: ptr::null(),
            render_pass: None,
            subpass: u32::default(),
            framebuffer: None,
            occlusion_query_enable: Bool32::default(),
            query_flags: QueryControlFlags::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .field("framebuffer", &self.framebuffer)
            .field("occlusion_query_enable", &self.occlusion_query_enable)
            .field("query_flags", &self.query_flags)
            .field("pipeline_statistics", &self.pipeline_statistics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Command buffer usage flags
    pub flags: CommandBufferUsageFlags,
    /// Pointer to inheritance info for secondary command buffers
    pub p_inheritance_info: *const CommandBufferInheritanceInfo,
}
unsafe impl Send for CommandBufferBeginInfo {}
unsafe impl Sync for CommandBufferBeginInfo {}
impl default::Default for CommandBufferBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_BEGIN_INFO,
            p_next: ptr::null(),
            flags: CommandBufferUsageFlags::default(),
            p_inheritance_info: ptr::null(),
        }
    }
}
impl fmt::Debug for CommandBufferBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_inheritance_info", &self.p_inheritance_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: Option<RenderPass>,
    pub framebuffer: Option<Framebuffer>,
    pub render_area: Rect2D,
    pub clear_value_count: u32,
    pub p_clear_values: *const ClearValue,
}
unsafe impl Send for RenderPassBeginInfo {}
unsafe impl Sync for RenderPassBeginInfo {}
impl default::Default for RenderPassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_BEGIN_INFO,
            p_next: ptr::null(),
            render_pass: None,
            framebuffer: None,
            render_area: Rect2D::default(),
            clear_value_count: u32::default(),
            p_clear_values: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("framebuffer", &self.framebuffer)
            .field("render_area", &self.render_area)
            .field("clear_value_count", &self.clear_value_count)
            .field("p_clear_values", &self.p_clear_values)
            .finish()
    }
}
///  Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearColorValue {
    pub float32: [f32; 4],
    pub int32: [i32; 4],
    pub uint32: [u32; 4],
}
impl default::Default for ClearColorValue {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for ClearColorValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearColorValue")
            .field("float32", unsafe { &self.float32 })
            .field("int32", unsafe { &self.int32 })
            .field("uint32", unsafe { &self.uint32 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
impl default::Default for ClearDepthStencilValue {
    fn default() -> Self {
        Self {
            depth: f32::default(),
            stencil: u32::default(),
        }
    }
}
impl fmt::Debug for ClearDepthStencilValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearDepthStencilValue")
            .field("depth", &self.depth)
            .field("stencil", &self.stencil)
            .finish()
    }
}
///  Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearValue {
    pub color: ClearColorValue,
    pub depth_stencil: ClearDepthStencilValue,
}
impl default::Default for ClearValue {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for ClearValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearValue")
            .field("color", unsafe { &self.color })
            .field("depth_stencil", unsafe { &self.depth_stencil })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClearAttachment {
    pub aspect_mask: ImageAspectFlags,
    pub color_attachment: u32,
    pub clear_value: ClearValue,
}
impl default::Default for ClearAttachment {
    fn default() -> Self {
        Self {
            aspect_mask: ImageAspectFlags::default(),
            color_attachment: u32::default(),
            clear_value: ClearValue::default(),
        }
    }
}
impl fmt::Debug for ClearAttachment {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearAttachment")
            .field("aspect_mask", &self.aspect_mask)
            .field("color_attachment", &self.color_attachment)
            .field("clear_value", &self.clear_value)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    /// Load operation for color or depth data
    pub load_op: AttachmentLoadOp,
    /// Store operation for color or depth data
    pub store_op: AttachmentStoreOp,
    /// Load operation for stencil data
    pub stencil_load_op: AttachmentLoadOp,
    /// Store operation for stencil data
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
impl default::Default for AttachmentDescription {
    fn default() -> Self {
        Self {
            flags: AttachmentDescriptionFlags::default(),
            format: Format::default(),
            samples: SampleCountFlags::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            stencil_load_op: AttachmentLoadOp::default(),
            stencil_store_op: AttachmentStoreOp::default(),
            initial_layout: ImageLayout::default(),
            final_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for AttachmentDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescription")
            .field("flags", &self.flags)
            .field("format", &self.format)
            .field("samples", &self.samples)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("stencil_load_op", &self.stencil_load_op)
            .field("stencil_store_op", &self.stencil_store_op)
            .field("initial_layout", &self.initial_layout)
            .field("final_layout", &self.final_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
impl default::Default for AttachmentReference {
    fn default() -> Self {
        Self {
            attachment: u32::default(),
            layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for AttachmentReference {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReference")
            .field("attachment", &self.attachment)
            .field("layout", &self.layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescription {
    pub flags: SubpassDescriptionFlags,
    /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    pub pipeline_bind_point: PipelineBindPoint,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference,
    pub p_resolve_attachments: *const AttachmentReference,
    pub p_depth_stencil_attachment: *const AttachmentReference,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
unsafe impl Send for SubpassDescription {}
unsafe impl Sync for SubpassDescription {}
impl default::Default for SubpassDescription {
    fn default() -> Self {
        Self {
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescription")
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("input_attachment_count", &self.input_attachment_count)
            .field("p_input_attachments", &self.p_input_attachments)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_resolve_attachments", &self.p_resolve_attachments)
            .field("p_depth_stencil_attachment", &self.p_depth_stencil_attachment)
            .field("preserve_attachment_count", &self.preserve_attachment_count)
            .field("p_preserve_attachments", &self.p_preserve_attachments)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SubpassDependency {
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
}
impl default::Default for SubpassDependency {
    fn default() -> Self {
        Self {
            src_subpass: u32::default(),
            dst_subpass: u32::default(),
            src_stage_mask: PipelineStageFlags::default(),
            dst_stage_mask: PipelineStageFlags::default(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            dependency_flags: DependencyFlags::default(),
        }
    }
}
impl fmt::Debug for SubpassDependency {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDependency")
            .field("src_subpass", &self.src_subpass)
            .field("dst_subpass", &self.dst_subpass)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("dependency_flags", &self.dependency_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency,
}
unsafe impl Send for RenderPassCreateInfo {}
unsafe impl Sync for RenderPassCreateInfo {}
impl default::Default for RenderPassCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATE_INFO,
            p_next: ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("subpass_count", &self.subpass_count)
            .field("p_subpasses", &self.p_subpasses)
            .field("dependency_count", &self.dependency_count)
            .field("p_dependencies", &self.p_dependencies)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EventCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Event creation flags
    pub flags: EventCreateFlags,
}
unsafe impl Send for EventCreateInfo {}
unsafe impl Sync for EventCreateInfo {}
impl default::Default for EventCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EVENT_CREATE_INFO,
            p_next: ptr::null(),
            flags: EventCreateFlags::default(),
        }
    }
}
impl fmt::Debug for EventCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("EventCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Fence creation flags
    pub flags: FenceCreateFlags,
}
unsafe impl Send for FenceCreateInfo {}
unsafe impl Sync for FenceCreateInfo {}
impl default::Default for FenceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_CREATE_INFO,
            p_next: ptr::null(),
            flags: FenceCreateFlags::default(),
        }
    }
}
impl fmt::Debug for FenceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceFeatures {
    /// out of bounds buffer accesses are well defined
    pub robust_buffer_access: Bool32,
    /// full 32-bit range of indices for indexed draw calls
    pub full_draw_index_uint32: Bool32,
    /// image views which are arrays of cube maps
    pub image_cube_array: Bool32,
    /// blending operations are controlled per-attachment
    pub independent_blend: Bool32,
    /// geometry stage
    pub geometry_shader: Bool32,
    /// tessellation control and evaluation stage
    pub tessellation_shader: Bool32,
    /// per-sample shading and interpolation
    pub sample_rate_shading: Bool32,
    /// blend operations which take two sources
    pub dual_src_blend: Bool32,
    /// logic operations
    pub logic_op: Bool32,
    /// multi draw indirect
    pub multi_draw_indirect: Bool32,
    /// indirect drawing can use non-zero firstInstance
    pub draw_indirect_first_instance: Bool32,
    /// depth clamping
    pub depth_clamp: Bool32,
    /// depth bias clamping
    pub depth_bias_clamp: Bool32,
    /// point and wireframe fill modes
    pub fill_mode_non_solid: Bool32,
    /// depth bounds test
    pub depth_bounds: Bool32,
    /// lines with width greater than 1
    pub wide_lines: Bool32,
    /// points with size greater than 1
    pub large_points: Bool32,
    /// the fragment alpha component can be forced to maximum representable alpha value
    pub alpha_to_one: Bool32,
    /// viewport arrays
    pub multi_viewport: Bool32,
    /// anisotropic sampler filtering
    pub sampler_anisotropy: Bool32,
    /// ETC texture compression formats
    pub texture_compression_etc2: Bool32,
    /// ASTC LDR texture compression formats
    pub texture_compression_astc_ldr: Bool32,
    /// BC1-7 texture compressed formats
    pub texture_compression_bc: Bool32,
    /// precise occlusion queries returning actual sample counts
    pub occlusion_query_precise: Bool32,
    /// pipeline statistics query
    pub pipeline_statistics_query: Bool32,
    /// stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    pub vertex_pipeline_stores_and_atomics: Bool32,
    /// stores and atomic ops on storage buffers and images are supported in the fragment stage
    pub fragment_stores_and_atomics: Bool32,
    /// tessellation and geometry stages can export point size
    pub shader_tessellation_and_geometry_point_size: Bool32,
    /// image gather with run-time values and independent offsets
    pub shader_image_gather_extended: Bool32,
    /// the extended set of formats can be used for storage images
    pub shader_storage_image_extended_formats: Bool32,
    /// multisample images can be used for storage images
    pub shader_storage_image_multisample: Bool32,
    /// read from storage image does not require format qualifier
    pub shader_storage_image_read_without_format: Bool32,
    /// write to storage image does not require format qualifier
    pub shader_storage_image_write_without_format: Bool32,
    /// arrays of uniform buffers can be accessed with dynamically uniform indices
    pub shader_uniform_buffer_array_dynamic_indexing: Bool32,
    /// arrays of sampled images can be accessed with dynamically uniform indices
    pub shader_sampled_image_array_dynamic_indexing: Bool32,
    /// arrays of storage buffers can be accessed with dynamically uniform indices
    pub shader_storage_buffer_array_dynamic_indexing: Bool32,
    /// arrays of storage images can be accessed with dynamically uniform indices
    pub shader_storage_image_array_dynamic_indexing: Bool32,
    /// clip distance in shaders
    pub shader_clip_distance: Bool32,
    /// cull distance in shaders
    pub shader_cull_distance: Bool32,
    /// 64-bit floats (doubles) in shaders
    pub shader_float64: Bool32,
    /// 64-bit integers in shaders
    pub shader_int64: Bool32,
    /// 16-bit integers in shaders
    pub shader_int16: Bool32,
    /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
    pub shader_resource_residency: Bool32,
    /// shader can use texture operations that specify minimum resource LOD
    pub shader_resource_min_lod: Bool32,
    /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    pub sparse_binding: Bool32,
    /// Sparse resources support: GPU can access partially resident buffers
    pub sparse_residency_buffer: Bool32,
    /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images
    pub sparse_residency_image2_d: Bool32,
    /// Sparse resources support: GPU can access partially resident 3D images
    pub sparse_residency_image3_d: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    pub sparse_residency2_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    pub sparse_residency4_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    pub sparse_residency8_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    pub sparse_residency16_samples: Bool32,
    /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    pub sparse_residency_aliased: Bool32,
    /// multisample rate must be the same for all pipelines in a subpass
    pub variable_multisample_rate: Bool32,
    /// Queries may be inherited from primary to secondary command buffers
    pub inherited_queries: Bool32,
}
impl default::Default for PhysicalDeviceFeatures {
    fn default() -> Self {
        Self {
            robust_buffer_access: Bool32::default(),
            full_draw_index_uint32: Bool32::default(),
            image_cube_array: Bool32::default(),
            independent_blend: Bool32::default(),
            geometry_shader: Bool32::default(),
            tessellation_shader: Bool32::default(),
            sample_rate_shading: Bool32::default(),
            dual_src_blend: Bool32::default(),
            logic_op: Bool32::default(),
            multi_draw_indirect: Bool32::default(),
            draw_indirect_first_instance: Bool32::default(),
            depth_clamp: Bool32::default(),
            depth_bias_clamp: Bool32::default(),
            fill_mode_non_solid: Bool32::default(),
            depth_bounds: Bool32::default(),
            wide_lines: Bool32::default(),
            large_points: Bool32::default(),
            alpha_to_one: Bool32::default(),
            multi_viewport: Bool32::default(),
            sampler_anisotropy: Bool32::default(),
            texture_compression_etc2: Bool32::default(),
            texture_compression_astc_ldr: Bool32::default(),
            texture_compression_bc: Bool32::default(),
            occlusion_query_precise: Bool32::default(),
            pipeline_statistics_query: Bool32::default(),
            vertex_pipeline_stores_and_atomics: Bool32::default(),
            fragment_stores_and_atomics: Bool32::default(),
            shader_tessellation_and_geometry_point_size: Bool32::default(),
            shader_image_gather_extended: Bool32::default(),
            shader_storage_image_extended_formats: Bool32::default(),
            shader_storage_image_multisample: Bool32::default(),
            shader_storage_image_read_without_format: Bool32::default(),
            shader_storage_image_write_without_format: Bool32::default(),
            shader_uniform_buffer_array_dynamic_indexing: Bool32::default(),
            shader_sampled_image_array_dynamic_indexing: Bool32::default(),
            shader_storage_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_image_array_dynamic_indexing: Bool32::default(),
            shader_clip_distance: Bool32::default(),
            shader_cull_distance: Bool32::default(),
            shader_float64: Bool32::default(),
            shader_int64: Bool32::default(),
            shader_int16: Bool32::default(),
            shader_resource_residency: Bool32::default(),
            shader_resource_min_lod: Bool32::default(),
            sparse_binding: Bool32::default(),
            sparse_residency_buffer: Bool32::default(),
            sparse_residency_image2_d: Bool32::default(),
            sparse_residency_image3_d: Bool32::default(),
            sparse_residency2_samples: Bool32::default(),
            sparse_residency4_samples: Bool32::default(),
            sparse_residency8_samples: Bool32::default(),
            sparse_residency16_samples: Bool32::default(),
            sparse_residency_aliased: Bool32::default(),
            variable_multisample_rate: Bool32::default(),
            inherited_queries: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFeatures")
            .field("robust_buffer_access", &self.robust_buffer_access)
            .field("full_draw_index_uint32", &self.full_draw_index_uint32)
            .field("image_cube_array", &self.image_cube_array)
            .field("independent_blend", &self.independent_blend)
            .field("geometry_shader", &self.geometry_shader)
            .field("tessellation_shader", &self.tessellation_shader)
            .field("sample_rate_shading", &self.sample_rate_shading)
            .field("dual_src_blend", &self.dual_src_blend)
            .field("logic_op", &self.logic_op)
            .field("multi_draw_indirect", &self.multi_draw_indirect)
            .field("draw_indirect_first_instance", &self.draw_indirect_first_instance)
            .field("depth_clamp", &self.depth_clamp)
            .field("depth_bias_clamp", &self.depth_bias_clamp)
            .field("fill_mode_non_solid", &self.fill_mode_non_solid)
            .field("depth_bounds", &self.depth_bounds)
            .field("wide_lines", &self.wide_lines)
            .field("large_points", &self.large_points)
            .field("alpha_to_one", &self.alpha_to_one)
            .field("multi_viewport", &self.multi_viewport)
            .field("sampler_anisotropy", &self.sampler_anisotropy)
            .field("texture_compression_etc2", &self.texture_compression_etc2)
            .field("texture_compression_astc_ldr", &self.texture_compression_astc_ldr)
            .field("texture_compression_bc", &self.texture_compression_bc)
            .field("occlusion_query_precise", &self.occlusion_query_precise)
            .field("pipeline_statistics_query", &self.pipeline_statistics_query)
            .field(
                "vertex_pipeline_stores_and_atomics",
                &self.vertex_pipeline_stores_and_atomics,
            )
            .field("fragment_stores_and_atomics", &self.fragment_stores_and_atomics)
            .field(
                "shader_tessellation_and_geometry_point_size",
                &self.shader_tessellation_and_geometry_point_size,
            )
            .field("shader_image_gather_extended", &self.shader_image_gather_extended)
            .field(
                "shader_storage_image_extended_formats",
                &self.shader_storage_image_extended_formats,
            )
            .field(
                "shader_storage_image_multisample",
                &self.shader_storage_image_multisample,
            )
            .field(
                "shader_storage_image_read_without_format",
                &self.shader_storage_image_read_without_format,
            )
            .field(
                "shader_storage_image_write_without_format",
                &self.shader_storage_image_write_without_format,
            )
            .field(
                "shader_uniform_buffer_array_dynamic_indexing",
                &self.shader_uniform_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_sampled_image_array_dynamic_indexing",
                &self.shader_sampled_image_array_dynamic_indexing,
            )
            .field(
                "shader_storage_buffer_array_dynamic_indexing",
                &self.shader_storage_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_image_array_dynamic_indexing",
                &self.shader_storage_image_array_dynamic_indexing,
            )
            .field("shader_clip_distance", &self.shader_clip_distance)
            .field("shader_cull_distance", &self.shader_cull_distance)
            .field("shader_float64", &self.shader_float64)
            .field("shader_int64", &self.shader_int64)
            .field("shader_int16", &self.shader_int16)
            .field("shader_resource_residency", &self.shader_resource_residency)
            .field("shader_resource_min_lod", &self.shader_resource_min_lod)
            .field("sparse_binding", &self.sparse_binding)
            .field("sparse_residency_buffer", &self.sparse_residency_buffer)
            .field("sparse_residency_image2_d", &self.sparse_residency_image2_d)
            .field("sparse_residency_image3_d", &self.sparse_residency_image3_d)
            .field("sparse_residency2_samples", &self.sparse_residency2_samples)
            .field("sparse_residency4_samples", &self.sparse_residency4_samples)
            .field("sparse_residency8_samples", &self.sparse_residency8_samples)
            .field("sparse_residency16_samples", &self.sparse_residency16_samples)
            .field("sparse_residency_aliased", &self.sparse_residency_aliased)
            .field("variable_multisample_rate", &self.variable_multisample_rate)
            .field("inherited_queries", &self.inherited_queries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceSparseProperties {
    /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard2_d_block_shape: Bool32,
    /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard2_d_multisample_block_shape: Bool32,
    /// Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard3_d_block_shape: Bool32,
    /// Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    pub residency_aligned_mip_size: Bool32,
    /// Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
    pub residency_non_resident_strict: Bool32,
}
impl default::Default for PhysicalDeviceSparseProperties {
    fn default() -> Self {
        Self {
            residency_standard2_d_block_shape: Bool32::default(),
            residency_standard2_d_multisample_block_shape: Bool32::default(),
            residency_standard3_d_block_shape: Bool32::default(),
            residency_aligned_mip_size: Bool32::default(),
            residency_non_resident_strict: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSparseProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSparseProperties")
            .field(
                "residency_standard2_d_block_shape",
                &self.residency_standard2_d_block_shape,
            )
            .field(
                "residency_standard2_d_multisample_block_shape",
                &self.residency_standard2_d_multisample_block_shape,
            )
            .field(
                "residency_standard3_d_block_shape",
                &self.residency_standard3_d_block_shape,
            )
            .field("residency_aligned_mip_size", &self.residency_aligned_mip_size)
            .field("residency_non_resident_strict", &self.residency_non_resident_strict)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLimits {
    /// max 1D image dimension
    pub max_image_dimension1_d: u32,
    /// max 2D image dimension
    pub max_image_dimension2_d: u32,
    /// max 3D image dimension
    pub max_image_dimension3_d: u32,
    /// max cubemap image dimension
    pub max_image_dimension_cube: u32,
    /// max layers for image arrays
    pub max_image_array_layers: u32,
    /// max texel buffer size (fstexels)
    pub max_texel_buffer_elements: u32,
    /// max uniform buffer range (bytes)
    pub max_uniform_buffer_range: u32,
    /// max storage buffer range (bytes)
    pub max_storage_buffer_range: u32,
    /// max size of the push constants pool (bytes)
    pub max_push_constants_size: u32,
    /// max number of device memory allocations supported
    pub max_memory_allocation_count: u32,
    /// max number of samplers that can be allocated on a device
    pub max_sampler_allocation_count: u32,
    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    pub buffer_image_granularity: DeviceSize,
    /// Total address space available for sparse allocations (bytes)
    pub sparse_address_space_size: DeviceSize,
    /// max number of descriptors sets that can be bound to a pipeline
    pub max_bound_descriptor_sets: u32,
    /// max number of samplers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_samplers: u32,
    /// max number of uniform buffers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_uniform_buffers: u32,
    /// max number of storage buffers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_storage_buffers: u32,
    /// max number of sampled images allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_sampled_images: u32,
    /// max number of storage images allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_storage_images: u32,
    /// max number of input attachments allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_input_attachments: u32,
    /// max number of resources allowed by a single stage
    pub max_per_stage_resources: u32,
    /// max number of samplers allowed in all stages in a descriptor set
    pub max_descriptor_set_samplers: u32,
    /// max number of uniform buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_uniform_buffers: u32,
    /// max number of dynamic uniform buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    /// max number of storage buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_buffers: u32,
    /// max number of dynamic storage buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    /// max number of sampled images allowed in all stages in a descriptor set
    pub max_descriptor_set_sampled_images: u32,
    /// max number of storage images allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_images: u32,
    /// max number of input attachments allowed in all stages in a descriptor set
    pub max_descriptor_set_input_attachments: u32,
    /// max number of vertex input attribute slots
    pub max_vertex_input_attributes: u32,
    /// max number of vertex input binding slots
    pub max_vertex_input_bindings: u32,
    /// max vertex input attribute offset added to vertex buffer offset
    pub max_vertex_input_attribute_offset: u32,
    /// max vertex input binding stride
    pub max_vertex_input_binding_stride: u32,
    /// max number of output components written by vertex shader
    pub max_vertex_output_components: u32,
    /// max level supported by tessellation primitive generator
    pub max_tessellation_generation_level: u32,
    /// max patch size (vertices)
    pub max_tessellation_patch_size: u32,
    /// max number of input components per-vertex in TCS
    pub max_tessellation_control_per_vertex_input_components: u32,
    /// max number of output components per-vertex in TCS
    pub max_tessellation_control_per_vertex_output_components: u32,
    /// max number of output components per-patch in TCS
    pub max_tessellation_control_per_patch_output_components: u32,
    /// max total number of per-vertex and per-patch output components in TCS
    pub max_tessellation_control_total_output_components: u32,
    /// max number of input components per vertex in TES
    pub max_tessellation_evaluation_input_components: u32,
    /// max number of output components per vertex in TES
    pub max_tessellation_evaluation_output_components: u32,
    /// max invocation count supported in geometry shader
    pub max_geometry_shader_invocations: u32,
    /// max number of input components read in geometry stage
    pub max_geometry_input_components: u32,
    /// max number of output components written in geometry stage
    pub max_geometry_output_components: u32,
    /// max number of vertices that can be emitted in geometry stage
    pub max_geometry_output_vertices: u32,
    /// max total number of components (all vertices) written in geometry stage
    pub max_geometry_total_output_components: u32,
    /// max number of input components read in fragment stage
    pub max_fragment_input_components: u32,
    /// max number of output attachments written in fragment stage
    pub max_fragment_output_attachments: u32,
    /// max number of output attachments written when using dual source blending
    pub max_fragment_dual_src_attachments: u32,
    /// max total number of storage buffers, storage images and output buffers
    pub max_fragment_combined_output_resources: u32,
    /// max total storage size of work group local storage (bytes)
    pub max_compute_shared_memory_size: u32,
    /// max num of compute work groups that may be dispatched by a single command (x,y,z)
    pub max_compute_work_group_count: [u32; 3],
    /// max total compute invocations in a single local work group
    pub max_compute_work_group_invocations: u32,
    /// max local size of a compute work group (x,y,z)
    pub max_compute_work_group_size: [u32; 3],
    /// number bits of subpixel precision in screen x and y
    pub sub_pixel_precision_bits: u32,
    /// number bits of precision for selecting texel weights
    pub sub_texel_precision_bits: u32,
    /// number bits of precision for selecting mipmap weights
    pub mipmap_precision_bits: u32,
    /// max index value for indexed draw calls (for 32-bit indices)
    pub max_draw_indexed_index_value: u32,
    /// max draw count for indirect drawing calls
    pub max_draw_indirect_count: u32,
    /// max absolute sampler LOD bias
    pub max_sampler_lod_bias: f32,
    /// max degree of sampler anisotropy
    pub max_sampler_anisotropy: f32,
    /// max number of active viewports
    pub max_viewports: u32,
    /// max viewport dimensions (x,y)
    pub max_viewport_dimensions: [u32; 2],
    /// viewport bounds range (min,max)
    pub viewport_bounds_range: [f32; 2],
    /// number bits of subpixel precision for viewport
    pub viewport_sub_pixel_bits: u32,
    /// min required alignment of pointers returned by MapMemory (bytes)
    pub min_memory_map_alignment: usize,
    /// min required alignment for texel buffer offsets (bytes)
    pub min_texel_buffer_offset_alignment: DeviceSize,
    /// min required alignment for uniform buffer sizes and offsets (bytes)
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    /// min required alignment for storage buffer offsets (bytes)
    pub min_storage_buffer_offset_alignment: DeviceSize,
    /// min texel offset for OpTextureSampleOffset
    pub min_texel_offset: i32,
    /// max texel offset for OpTextureSampleOffset
    pub max_texel_offset: u32,
    /// min texel offset for OpTextureGatherOffset
    pub min_texel_gather_offset: i32,
    /// max texel offset for OpTextureGatherOffset
    pub max_texel_gather_offset: u32,
    /// furthest negative offset for interpolateAtOffset
    pub min_interpolation_offset: f32,
    /// furthest positive offset for interpolateAtOffset
    pub max_interpolation_offset: f32,
    /// number of subpixel bits for interpolateAtOffset
    pub sub_pixel_interpolation_offset_bits: u32,
    /// max width for a framebuffer
    pub max_framebuffer_width: u32,
    /// max height for a framebuffer
    pub max_framebuffer_height: u32,
    /// max layer count for a layered framebuffer
    pub max_framebuffer_layers: u32,
    /// supported color sample counts for a framebuffer
    pub framebuffer_color_sample_counts: SampleCountFlags,
    /// supported depth sample counts for a framebuffer
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    /// supported stencil sample counts for a framebuffer
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    /// supported sample counts for a subpass which uses no attachments
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    /// max number of color attachments per subpass
    pub max_color_attachments: u32,
    /// supported color sample counts for a non-integer sampled image
    pub sampled_image_color_sample_counts: SampleCountFlags,
    /// supported sample counts for an integer image
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    /// supported depth sample counts for a sampled image
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    /// supported stencil sample counts for a sampled image
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    /// supported sample counts for a storage image
    pub storage_image_sample_counts: SampleCountFlags,
    /// max number of sample mask words
    pub max_sample_mask_words: u32,
    /// timestamps on graphics and compute queues
    pub timestamp_compute_and_graphics: Bool32,
    /// number of nanoseconds it takes for timestamp query value to increment by 1
    pub timestamp_period: f32,
    /// max number of clip distances
    pub max_clip_distances: u32,
    /// max number of cull distances
    pub max_cull_distances: u32,
    /// max combined number of user clipping
    pub max_combined_clip_and_cull_distances: u32,
    /// distinct queue priorities available
    pub discrete_queue_priorities: u32,
    /// range (min,max) of supported point sizes
    pub point_size_range: [f32; 2],
    /// range (min,max) of supported line widths
    pub line_width_range: [f32; 2],
    /// granularity of supported point sizes
    pub point_size_granularity: f32,
    /// granularity of supported line widths
    pub line_width_granularity: f32,
    /// line rasterization follows preferred rules
    pub strict_lines: Bool32,
    /// supports standard sample locations for all supported sample counts
    pub standard_sample_locations: Bool32,
    /// optimal offset of buffer copies
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    /// optimal pitch of buffer copies
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    /// minimum size and alignment for non-coherent host-mapped device memory access
    pub non_coherent_atom_size: DeviceSize,
}
impl default::Default for PhysicalDeviceLimits {
    fn default() -> Self {
        Self {
            max_image_dimension1_d: u32::default(),
            max_image_dimension2_d: u32::default(),
            max_image_dimension3_d: u32::default(),
            max_image_dimension_cube: u32::default(),
            max_image_array_layers: u32::default(),
            max_texel_buffer_elements: u32::default(),
            max_uniform_buffer_range: u32::default(),
            max_storage_buffer_range: u32::default(),
            max_push_constants_size: u32::default(),
            max_memory_allocation_count: u32::default(),
            max_sampler_allocation_count: u32::default(),
            buffer_image_granularity: DeviceSize::default(),
            sparse_address_space_size: DeviceSize::default(),
            max_bound_descriptor_sets: u32::default(),
            max_per_stage_descriptor_samplers: u32::default(),
            max_per_stage_descriptor_uniform_buffers: u32::default(),
            max_per_stage_descriptor_storage_buffers: u32::default(),
            max_per_stage_descriptor_sampled_images: u32::default(),
            max_per_stage_descriptor_storage_images: u32::default(),
            max_per_stage_descriptor_input_attachments: u32::default(),
            max_per_stage_resources: u32::default(),
            max_descriptor_set_samplers: u32::default(),
            max_descriptor_set_uniform_buffers: u32::default(),
            max_descriptor_set_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_storage_buffers: u32::default(),
            max_descriptor_set_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_sampled_images: u32::default(),
            max_descriptor_set_storage_images: u32::default(),
            max_descriptor_set_input_attachments: u32::default(),
            max_vertex_input_attributes: u32::default(),
            max_vertex_input_bindings: u32::default(),
            max_vertex_input_attribute_offset: u32::default(),
            max_vertex_input_binding_stride: u32::default(),
            max_vertex_output_components: u32::default(),
            max_tessellation_generation_level: u32::default(),
            max_tessellation_patch_size: u32::default(),
            max_tessellation_control_per_vertex_input_components: u32::default(),
            max_tessellation_control_per_vertex_output_components: u32::default(),
            max_tessellation_control_per_patch_output_components: u32::default(),
            max_tessellation_control_total_output_components: u32::default(),
            max_tessellation_evaluation_input_components: u32::default(),
            max_tessellation_evaluation_output_components: u32::default(),
            max_geometry_shader_invocations: u32::default(),
            max_geometry_input_components: u32::default(),
            max_geometry_output_components: u32::default(),
            max_geometry_output_vertices: u32::default(),
            max_geometry_total_output_components: u32::default(),
            max_fragment_input_components: u32::default(),
            max_fragment_output_attachments: u32::default(),
            max_fragment_dual_src_attachments: u32::default(),
            max_fragment_combined_output_resources: u32::default(),
            max_compute_shared_memory_size: u32::default(),
            max_compute_work_group_count: [u32::default(); 3],
            max_compute_work_group_invocations: u32::default(),
            max_compute_work_group_size: [u32::default(); 3],
            sub_pixel_precision_bits: u32::default(),
            sub_texel_precision_bits: u32::default(),
            mipmap_precision_bits: u32::default(),
            max_draw_indexed_index_value: u32::default(),
            max_draw_indirect_count: u32::default(),
            max_sampler_lod_bias: f32::default(),
            max_sampler_anisotropy: f32::default(),
            max_viewports: u32::default(),
            max_viewport_dimensions: [u32::default(); 2],
            viewport_bounds_range: [f32::default(); 2],
            viewport_sub_pixel_bits: u32::default(),
            min_memory_map_alignment: usize::default(),
            min_texel_buffer_offset_alignment: DeviceSize::default(),
            min_uniform_buffer_offset_alignment: DeviceSize::default(),
            min_storage_buffer_offset_alignment: DeviceSize::default(),
            min_texel_offset: i32::default(),
            max_texel_offset: u32::default(),
            min_texel_gather_offset: i32::default(),
            max_texel_gather_offset: u32::default(),
            min_interpolation_offset: f32::default(),
            max_interpolation_offset: f32::default(),
            sub_pixel_interpolation_offset_bits: u32::default(),
            max_framebuffer_width: u32::default(),
            max_framebuffer_height: u32::default(),
            max_framebuffer_layers: u32::default(),
            framebuffer_color_sample_counts: SampleCountFlags::default(),
            framebuffer_depth_sample_counts: SampleCountFlags::default(),
            framebuffer_stencil_sample_counts: SampleCountFlags::default(),
            framebuffer_no_attachments_sample_counts: SampleCountFlags::default(),
            max_color_attachments: u32::default(),
            sampled_image_color_sample_counts: SampleCountFlags::default(),
            sampled_image_integer_sample_counts: SampleCountFlags::default(),
            sampled_image_depth_sample_counts: SampleCountFlags::default(),
            sampled_image_stencil_sample_counts: SampleCountFlags::default(),
            storage_image_sample_counts: SampleCountFlags::default(),
            max_sample_mask_words: u32::default(),
            timestamp_compute_and_graphics: Bool32::default(),
            timestamp_period: f32::default(),
            max_clip_distances: u32::default(),
            max_cull_distances: u32::default(),
            max_combined_clip_and_cull_distances: u32::default(),
            discrete_queue_priorities: u32::default(),
            point_size_range: [f32::default(); 2],
            line_width_range: [f32::default(); 2],
            point_size_granularity: f32::default(),
            line_width_granularity: f32::default(),
            strict_lines: Bool32::default(),
            standard_sample_locations: Bool32::default(),
            optimal_buffer_copy_offset_alignment: DeviceSize::default(),
            optimal_buffer_copy_row_pitch_alignment: DeviceSize::default(),
            non_coherent_atom_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLimits {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLimits")
            .field("max_image_dimension1_d", &self.max_image_dimension1_d)
            .field("max_image_dimension2_d", &self.max_image_dimension2_d)
            .field("max_image_dimension3_d", &self.max_image_dimension3_d)
            .field("max_image_dimension_cube", &self.max_image_dimension_cube)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("max_texel_buffer_elements", &self.max_texel_buffer_elements)
            .field("max_uniform_buffer_range", &self.max_uniform_buffer_range)
            .field("max_storage_buffer_range", &self.max_storage_buffer_range)
            .field("max_push_constants_size", &self.max_push_constants_size)
            .field("max_memory_allocation_count", &self.max_memory_allocation_count)
            .field("max_sampler_allocation_count", &self.max_sampler_allocation_count)
            .field("buffer_image_granularity", &self.buffer_image_granularity)
            .field("sparse_address_space_size", &self.sparse_address_space_size)
            .field("max_bound_descriptor_sets", &self.max_bound_descriptor_sets)
            .field(
                "max_per_stage_descriptor_samplers",
                &self.max_per_stage_descriptor_samplers,
            )
            .field(
                "max_per_stage_descriptor_uniform_buffers",
                &self.max_per_stage_descriptor_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_storage_buffers",
                &self.max_per_stage_descriptor_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_sampled_images",
                &self.max_per_stage_descriptor_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_storage_images",
                &self.max_per_stage_descriptor_storage_images,
            )
            .field(
                "max_per_stage_descriptor_input_attachments",
                &self.max_per_stage_descriptor_input_attachments,
            )
            .field("max_per_stage_resources", &self.max_per_stage_resources)
            .field("max_descriptor_set_samplers", &self.max_descriptor_set_samplers)
            .field(
                "max_descriptor_set_uniform_buffers",
                &self.max_descriptor_set_uniform_buffers,
            )
            .field(
                "max_descriptor_set_uniform_buffers_dynamic",
                &self.max_descriptor_set_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_storage_buffers",
                &self.max_descriptor_set_storage_buffers,
            )
            .field(
                "max_descriptor_set_storage_buffers_dynamic",
                &self.max_descriptor_set_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_sampled_images",
                &self.max_descriptor_set_sampled_images,
            )
            .field(
                "max_descriptor_set_storage_images",
                &self.max_descriptor_set_storage_images,
            )
            .field(
                "max_descriptor_set_input_attachments",
                &self.max_descriptor_set_input_attachments,
            )
            .field("max_vertex_input_attributes", &self.max_vertex_input_attributes)
            .field("max_vertex_input_bindings", &self.max_vertex_input_bindings)
            .field(
                "max_vertex_input_attribute_offset",
                &self.max_vertex_input_attribute_offset,
            )
            .field("max_vertex_input_binding_stride", &self.max_vertex_input_binding_stride)
            .field("max_vertex_output_components", &self.max_vertex_output_components)
            .field(
                "max_tessellation_generation_level",
                &self.max_tessellation_generation_level,
            )
            .field("max_tessellation_patch_size", &self.max_tessellation_patch_size)
            .field(
                "max_tessellation_control_per_vertex_input_components",
                &self.max_tessellation_control_per_vertex_input_components,
            )
            .field(
                "max_tessellation_control_per_vertex_output_components",
                &self.max_tessellation_control_per_vertex_output_components,
            )
            .field(
                "max_tessellation_control_per_patch_output_components",
                &self.max_tessellation_control_per_patch_output_components,
            )
            .field(
                "max_tessellation_control_total_output_components",
                &self.max_tessellation_control_total_output_components,
            )
            .field(
                "max_tessellation_evaluation_input_components",
                &self.max_tessellation_evaluation_input_components,
            )
            .field(
                "max_tessellation_evaluation_output_components",
                &self.max_tessellation_evaluation_output_components,
            )
            .field("max_geometry_shader_invocations", &self.max_geometry_shader_invocations)
            .field("max_geometry_input_components", &self.max_geometry_input_components)
            .field("max_geometry_output_components", &self.max_geometry_output_components)
            .field("max_geometry_output_vertices", &self.max_geometry_output_vertices)
            .field(
                "max_geometry_total_output_components",
                &self.max_geometry_total_output_components,
            )
            .field("max_fragment_input_components", &self.max_fragment_input_components)
            .field("max_fragment_output_attachments", &self.max_fragment_output_attachments)
            .field(
                "max_fragment_dual_src_attachments",
                &self.max_fragment_dual_src_attachments,
            )
            .field(
                "max_fragment_combined_output_resources",
                &self.max_fragment_combined_output_resources,
            )
            .field("max_compute_shared_memory_size", &self.max_compute_shared_memory_size)
            .field("max_compute_work_group_count", &self.max_compute_work_group_count)
            .field(
                "max_compute_work_group_invocations",
                &self.max_compute_work_group_invocations,
            )
            .field("max_compute_work_group_size", &self.max_compute_work_group_size)
            .field("sub_pixel_precision_bits", &self.sub_pixel_precision_bits)
            .field("sub_texel_precision_bits", &self.sub_texel_precision_bits)
            .field("mipmap_precision_bits", &self.mipmap_precision_bits)
            .field("max_draw_indexed_index_value", &self.max_draw_indexed_index_value)
            .field("max_draw_indirect_count", &self.max_draw_indirect_count)
            .field("max_sampler_lod_bias", &self.max_sampler_lod_bias)
            .field("max_sampler_anisotropy", &self.max_sampler_anisotropy)
            .field("max_viewports", &self.max_viewports)
            .field("max_viewport_dimensions", &self.max_viewport_dimensions)
            .field("viewport_bounds_range", &self.viewport_bounds_range)
            .field("viewport_sub_pixel_bits", &self.viewport_sub_pixel_bits)
            .field("min_memory_map_alignment", &self.min_memory_map_alignment)
            .field(
                "min_texel_buffer_offset_alignment",
                &self.min_texel_buffer_offset_alignment,
            )
            .field(
                "min_uniform_buffer_offset_alignment",
                &self.min_uniform_buffer_offset_alignment,
            )
            .field(
                "min_storage_buffer_offset_alignment",
                &self.min_storage_buffer_offset_alignment,
            )
            .field("min_texel_offset", &self.min_texel_offset)
            .field("max_texel_offset", &self.max_texel_offset)
            .field("min_texel_gather_offset", &self.min_texel_gather_offset)
            .field("max_texel_gather_offset", &self.max_texel_gather_offset)
            .field("min_interpolation_offset", &self.min_interpolation_offset)
            .field("max_interpolation_offset", &self.max_interpolation_offset)
            .field(
                "sub_pixel_interpolation_offset_bits",
                &self.sub_pixel_interpolation_offset_bits,
            )
            .field("max_framebuffer_width", &self.max_framebuffer_width)
            .field("max_framebuffer_height", &self.max_framebuffer_height)
            .field("max_framebuffer_layers", &self.max_framebuffer_layers)
            .field("framebuffer_color_sample_counts", &self.framebuffer_color_sample_counts)
            .field("framebuffer_depth_sample_counts", &self.framebuffer_depth_sample_counts)
            .field(
                "framebuffer_stencil_sample_counts",
                &self.framebuffer_stencil_sample_counts,
            )
            .field(
                "framebuffer_no_attachments_sample_counts",
                &self.framebuffer_no_attachments_sample_counts,
            )
            .field("max_color_attachments", &self.max_color_attachments)
            .field(
                "sampled_image_color_sample_counts",
                &self.sampled_image_color_sample_counts,
            )
            .field(
                "sampled_image_integer_sample_counts",
                &self.sampled_image_integer_sample_counts,
            )
            .field(
                "sampled_image_depth_sample_counts",
                &self.sampled_image_depth_sample_counts,
            )
            .field(
                "sampled_image_stencil_sample_counts",
                &self.sampled_image_stencil_sample_counts,
            )
            .field("storage_image_sample_counts", &self.storage_image_sample_counts)
            .field("max_sample_mask_words", &self.max_sample_mask_words)
            .field("timestamp_compute_and_graphics", &self.timestamp_compute_and_graphics)
            .field("timestamp_period", &self.timestamp_period)
            .field("max_clip_distances", &self.max_clip_distances)
            .field("max_cull_distances", &self.max_cull_distances)
            .field(
                "max_combined_clip_and_cull_distances",
                &self.max_combined_clip_and_cull_distances,
            )
            .field("discrete_queue_priorities", &self.discrete_queue_priorities)
            .field("point_size_range", &self.point_size_range)
            .field("line_width_range", &self.line_width_range)
            .field("point_size_granularity", &self.point_size_granularity)
            .field("line_width_granularity", &self.line_width_granularity)
            .field("strict_lines", &self.strict_lines)
            .field("standard_sample_locations", &self.standard_sample_locations)
            .field(
                "optimal_buffer_copy_offset_alignment",
                &self.optimal_buffer_copy_offset_alignment,
            )
            .field(
                "optimal_buffer_copy_row_pitch_alignment",
                &self.optimal_buffer_copy_row_pitch_alignment,
            )
            .field("non_coherent_atom_size", &self.non_coherent_atom_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Semaphore creation flags
    pub flags: SemaphoreCreateFlags,
}
unsafe impl Send for SemaphoreCreateInfo {}
unsafe impl Sync for SemaphoreCreateInfo {}
impl default::Default for SemaphoreCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_CREATE_INFO,
            p_next: ptr::null(),
            flags: SemaphoreCreateFlags::default(),
        }
    }
}
impl fmt::Debug for SemaphoreCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: QueryPoolCreateFlags,
    pub query_type: QueryType,
    pub query_count: u32,
    /// Optional
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
unsafe impl Send for QueryPoolCreateInfo {}
unsafe impl Sync for QueryPoolCreateInfo {}
impl default::Default for QueryPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: QueryPoolCreateFlags::default(),
            query_type: QueryType::default(),
            query_count: u32::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
        }
    }
}
impl fmt::Debug for QueryPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("query_type", &self.query_type)
            .field("query_count", &self.query_count)
            .field("pipeline_statistics", &self.pipeline_statistics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FramebufferCreateFlags,
    pub render_pass: Option<RenderPass>,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
unsafe impl Send for FramebufferCreateInfo {}
unsafe impl Sync for FramebufferCreateInfo {}
impl default::Default for FramebufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_CREATE_INFO,
            p_next: ptr::null(),
            flags: FramebufferCreateFlags::default(),
            render_pass: None,
            attachment_count: u32::default(),
            p_attachments: ptr::null(),
            width: u32::default(),
            height: u32::default(),
            layers: u32::default(),
        }
    }
}
impl fmt::Debug for FramebufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("render_pass", &self.render_pass)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("layers", &self.layers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DrawIndirectCommand {
    pub vertex_count: u32,
    pub instance_count: u32,
    pub first_vertex: u32,
    pub first_instance: u32,
}
impl default::Default for DrawIndirectCommand {
    fn default() -> Self {
        Self {
            vertex_count: u32::default(),
            instance_count: u32::default(),
            first_vertex: u32::default(),
            first_instance: u32::default(),
        }
    }
}
impl fmt::Debug for DrawIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawIndirectCommand")
            .field("vertex_count", &self.vertex_count)
            .field("instance_count", &self.instance_count)
            .field("first_vertex", &self.first_vertex)
            .field("first_instance", &self.first_instance)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DrawIndexedIndirectCommand {
    pub index_count: u32,
    pub instance_count: u32,
    pub first_index: u32,
    pub vertex_offset: i32,
    pub first_instance: u32,
}
impl default::Default for DrawIndexedIndirectCommand {
    fn default() -> Self {
        Self {
            index_count: u32::default(),
            instance_count: u32::default(),
            first_index: u32::default(),
            vertex_offset: i32::default(),
            first_instance: u32::default(),
        }
    }
}
impl fmt::Debug for DrawIndexedIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawIndexedIndirectCommand")
            .field("index_count", &self.index_count)
            .field("instance_count", &self.instance_count)
            .field("first_index", &self.first_index)
            .field("vertex_offset", &self.vertex_offset)
            .field("first_instance", &self.first_instance)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
impl default::Default for DispatchIndirectCommand {
    fn default() -> Self {
        Self {
            x: u32::default(),
            y: u32::default(),
            z: u32::default(),
        }
    }
}
impl fmt::Debug for DispatchIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DispatchIndirectCommand")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct MultiDrawInfoEXT {
    pub first_vertex: u32,
    pub vertex_count: u32,
}
impl default::Default for MultiDrawInfoEXT {
    fn default() -> Self {
        Self {
            first_vertex: u32::default(),
            vertex_count: u32::default(),
        }
    }
}
impl fmt::Debug for MultiDrawInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiDrawInfoEXT")
            .field("first_vertex", &self.first_vertex)
            .field("vertex_count", &self.vertex_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct MultiDrawIndexedInfoEXT {
    pub first_index: u32,
    pub index_count: u32,
    pub vertex_offset: i32,
}
impl default::Default for MultiDrawIndexedInfoEXT {
    fn default() -> Self {
        Self {
            first_index: u32::default(),
            index_count: u32::default(),
            vertex_offset: i32::default(),
        }
    }
}
impl fmt::Debug for MultiDrawIndexedInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiDrawIndexedInfoEXT")
            .field("first_index", &self.first_index)
            .field("index_count", &self.index_count)
            .field("vertex_offset", &self.vertex_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub p_wait_dst_stage_mask: *const PipelineStageFlags,
    pub command_buffer_count: u32,
    pub p_command_buffers: *const CommandBuffer,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
unsafe impl Send for SubmitInfo {}
unsafe impl Sync for SubmitInfo {}
impl default::Default for SubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ptr::null(),
            p_wait_dst_stage_mask: ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffers: ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ptr::null(),
        }
    }
}
impl fmt::Debug for SubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("p_wait_dst_stage_mask", &self.p_wait_dst_stage_mask)
            .field("command_buffer_count", &self.command_buffer_count)
            .field("p_command_buffers", &self.p_command_buffers)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field("p_signal_semaphores", &self.p_signal_semaphores)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPropertiesKHR {
    /// Handle of the display object
    pub display: Option<DisplayKHR>,
    /// Name of the display
    pub display_name: *const c_char,
    /// In millimeters?
    pub physical_dimensions: Extent2D,
    /// Max resolution for CRT?
    pub physical_resolution: Extent2D,
    /// one or more bits from VkSurfaceTransformFlagsKHR
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// VK_TRUE if the overlay plane's z-order can be changed on this display.
    pub plane_reorder_possible: Bool32,
    /// VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
    pub persistent_content: Bool32,
}
unsafe impl Send for DisplayPropertiesKHR {}
unsafe impl Sync for DisplayPropertiesKHR {}
impl default::Default for DisplayPropertiesKHR {
    fn default() -> Self {
        Self {
            display: None,
            display_name: ptr::null(),
            physical_dimensions: Extent2D::default(),
            physical_resolution: Extent2D::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            plane_reorder_possible: Bool32::default(),
            persistent_content: Bool32::default(),
        }
    }
}
impl fmt::Debug for DisplayPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPropertiesKHR")
            .field("display", &self.display)
            .field("display_name", &self.display_name)
            .field("physical_dimensions", &self.physical_dimensions)
            .field("physical_resolution", &self.physical_resolution)
            .field("supported_transforms", &self.supported_transforms)
            .field("plane_reorder_possible", &self.plane_reorder_possible)
            .field("persistent_content", &self.persistent_content)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlanePropertiesKHR {
    /// Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    pub current_display: Option<DisplayKHR>,
    /// Current z-order of the plane.
    pub current_stack_index: u32,
}
impl default::Default for DisplayPlanePropertiesKHR {
    fn default() -> Self {
        Self {
            current_display: None,
            current_stack_index: u32::default(),
        }
    }
}
impl fmt::Debug for DisplayPlanePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlanePropertiesKHR")
            .field("current_display", &self.current_display)
            .field("current_stack_index", &self.current_stack_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayModeParametersKHR {
    /// Visible scanout region.
    pub visible_region: Extent2D,
    /// Number of times per second the display is updated.
    pub refresh_rate: u32,
}
impl default::Default for DisplayModeParametersKHR {
    fn default() -> Self {
        Self {
            visible_region: Extent2D::default(),
            refresh_rate: u32::default(),
        }
    }
}
impl fmt::Debug for DisplayModeParametersKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeParametersKHR")
            .field("visible_region", &self.visible_region)
            .field("refresh_rate", &self.refresh_rate)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayModePropertiesKHR {
    /// Handle of this display mode.
    pub display_mode: Option<DisplayModeKHR>,
    /// The parameters this mode uses.
    pub parameters: DisplayModeParametersKHR,
}
impl default::Default for DisplayModePropertiesKHR {
    fn default() -> Self {
        Self {
            display_mode: None,
            parameters: DisplayModeParametersKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayModePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModePropertiesKHR")
            .field("display_mode", &self.display_mode)
            .field("parameters", &self.parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayModeCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplayModeCreateFlagsKHR,
    /// The parameters this mode uses.
    pub parameters: DisplayModeParametersKHR,
}
unsafe impl Send for DisplayModeCreateInfoKHR {}
unsafe impl Sync for DisplayModeCreateInfoKHR {}
impl default::Default for DisplayModeCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_MODE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: DisplayModeCreateFlagsKHR::default(),
            parameters: DisplayModeParametersKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayModeCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("parameters", &self.parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayPlaneCapabilitiesKHR {
    /// Types of alpha blending supported, if any.
    pub supported_alpha: DisplayPlaneAlphaFlagsKHR,
    /// Does the plane have any position and extent restrictions?
    pub min_src_position: Offset2D,
    pub max_src_position: Offset2D,
    pub min_src_extent: Extent2D,
    pub max_src_extent: Extent2D,
    pub min_dst_position: Offset2D,
    pub max_dst_position: Offset2D,
    pub min_dst_extent: Extent2D,
    pub max_dst_extent: Extent2D,
}
impl default::Default for DisplayPlaneCapabilitiesKHR {
    fn default() -> Self {
        Self {
            supported_alpha: DisplayPlaneAlphaFlagsKHR::default(),
            min_src_position: Offset2D::default(),
            max_src_position: Offset2D::default(),
            min_src_extent: Extent2D::default(),
            max_src_extent: Extent2D::default(),
            min_dst_position: Offset2D::default(),
            max_dst_position: Offset2D::default(),
            min_dst_extent: Extent2D::default(),
            max_dst_extent: Extent2D::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneCapabilitiesKHR")
            .field("supported_alpha", &self.supported_alpha)
            .field("min_src_position", &self.min_src_position)
            .field("max_src_position", &self.max_src_position)
            .field("min_src_extent", &self.min_src_extent)
            .field("max_src_extent", &self.max_src_extent)
            .field("min_dst_position", &self.min_dst_position)
            .field("max_dst_position", &self.max_dst_position)
            .field("min_dst_extent", &self.min_dst_extent)
            .field("max_dst_extent", &self.max_dst_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplaySurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplaySurfaceCreateFlagsKHR,
    /// The mode to use when displaying this surface
    pub display_mode: Option<DisplayModeKHR>,
    /// The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    pub plane_index: u32,
    /// The z-order of the plane.
    pub plane_stack_index: u32,
    /// Transform to apply to the images as part of the scanout operation
    pub transform: SurfaceTransformFlagsKHR,
    /// Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    pub global_alpha: f32,
    /// What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
    pub alpha_mode: DisplayPlaneAlphaFlagsKHR,
    /// size of the images to use with this surface
    pub image_extent: Extent2D,
}
unsafe impl Send for DisplaySurfaceCreateInfoKHR {}
unsafe impl Sync for DisplaySurfaceCreateInfoKHR {}
impl default::Default for DisplaySurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: DisplaySurfaceCreateFlagsKHR::default(),
            display_mode: None,
            plane_index: u32::default(),
            plane_stack_index: u32::default(),
            transform: SurfaceTransformFlagsKHR::default(),
            global_alpha: f32::default(),
            alpha_mode: DisplayPlaneAlphaFlagsKHR::default(),
            image_extent: Extent2D::default(),
        }
    }
}
impl fmt::Debug for DisplaySurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplaySurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("display_mode", &self.display_mode)
            .field("plane_index", &self.plane_index)
            .field("plane_stack_index", &self.plane_stack_index)
            .field("transform", &self.transform)
            .field("global_alpha", &self.global_alpha)
            .field("alpha_mode", &self.alpha_mode)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Rectangle within the presentable image to read pixel data from when presenting to the display.
    pub src_rect: Rect2D,
    /// Rectangle within the current display mode's visible region to display srcRectangle in.
    pub dst_rect: Rect2D,
    /// For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
    pub persistent: Bool32,
}
unsafe impl Send for DisplayPresentInfoKHR {}
unsafe impl Sync for DisplayPresentInfoKHR {}
impl default::Default for DisplayPresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PRESENT_INFO_KHR,
            p_next: ptr::null(),
            src_rect: Rect2D::default(),
            dst_rect: Rect2D::default(),
            persistent: Bool32::default(),
        }
    }
}
impl fmt::Debug for DisplayPresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_rect", &self.src_rect)
            .field("dst_rect", &self.dst_rect)
            .field("persistent", &self.persistent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceCapabilitiesKHR {
    /// Supported minimum number of images for the surface
    pub min_image_count: u32,
    /// Supported maximum number of images for the surface, 0 for unlimited
    pub max_image_count: u32,
    /// Current image width and height for the surface, (0, 0) if undefined
    pub current_extent: Extent2D,
    /// Supported minimum image width and height for the surface
    pub min_image_extent: Extent2D,
    /// Supported maximum image width and height for the surface
    pub max_image_extent: Extent2D,
    /// Supported maximum number of image layers for the surface
    pub max_image_array_layers: u32,
    /// 1 or more bits representing the transforms supported
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// The surface's current transform relative to the device's natural orientation
    pub current_transform: SurfaceTransformFlagsKHR,
    /// 1 or more bits representing the alpha compositing modes supported
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    /// Supported image usage flags for the surface
    pub supported_usage_flags: ImageUsageFlags,
}
impl default::Default for SurfaceCapabilitiesKHR {
    fn default() -> Self {
        Self {
            min_image_count: u32::default(),
            max_image_count: u32::default(),
            current_extent: Extent2D::default(),
            min_image_extent: Extent2D::default(),
            max_image_extent: Extent2D::default(),
            max_image_array_layers: u32::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            current_transform: SurfaceTransformFlagsKHR::default(),
            supported_composite_alpha: CompositeAlphaFlagsKHR::default(),
            supported_usage_flags: ImageUsageFlags::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilitiesKHR")
            .field("min_image_count", &self.min_image_count)
            .field("max_image_count", &self.max_image_count)
            .field("current_extent", &self.current_extent)
            .field("min_image_extent", &self.min_image_extent)
            .field("max_image_extent", &self.max_image_extent)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("supported_transforms", &self.supported_transforms)
            .field("current_transform", &self.current_transform)
            .field("supported_composite_alpha", &self.supported_composite_alpha)
            .field("supported_usage_flags", &self.supported_usage_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AndroidSurfaceCreateFlagsKHR,
    pub window: *mut ANativeWindow,
}
unsafe impl Send for AndroidSurfaceCreateInfoKHR {}
unsafe impl Sync for AndroidSurfaceCreateInfoKHR {}
impl default::Default for AndroidSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: AndroidSurfaceCreateFlagsKHR::default(),
            window: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for AndroidSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViSurfaceCreateInfoNN {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ViSurfaceCreateFlagsNN,
    pub window: *mut c_void,
}
unsafe impl Send for ViSurfaceCreateInfoNN {}
unsafe impl Sync for ViSurfaceCreateInfoNN {}
impl default::Default for ViSurfaceCreateInfoNN {
    fn default() -> Self {
        Self {
            s_type: StructureType::VI_SURFACE_CREATE_INFO_NN,
            p_next: ptr::null(),
            flags: ViSurfaceCreateFlagsNN::default(),
            window: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ViSurfaceCreateInfoNN {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViSurfaceCreateInfoNN")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WaylandSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: WaylandSurfaceCreateFlagsKHR,
    pub display: *mut wl_display,
    pub surface: *mut wl_surface,
}
unsafe impl Send for WaylandSurfaceCreateInfoKHR {}
unsafe impl Sync for WaylandSurfaceCreateInfoKHR {}
impl default::Default for WaylandSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: WaylandSurfaceCreateFlagsKHR::default(),
            display: ptr::null_mut(),
            surface: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for WaylandSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WaylandSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("display", &self.display)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32SurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: Win32SurfaceCreateFlagsKHR,
    pub hinstance: HINSTANCE,
    pub hwnd: HWND,
}
unsafe impl Send for Win32SurfaceCreateInfoKHR {}
unsafe impl Sync for Win32SurfaceCreateInfoKHR {}
impl default::Default for Win32SurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Win32SurfaceCreateFlagsKHR::default(),
            hinstance: unsafe { mem::zeroed() },
            hwnd: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for Win32SurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32SurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("hinstance", &self.hinstance)
            .field("hwnd", &self.hwnd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XlibSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XlibSurfaceCreateFlagsKHR,
    pub dpy: *mut Display,
    pub window: Window,
}
unsafe impl Send for XlibSurfaceCreateInfoKHR {}
unsafe impl Sync for XlibSurfaceCreateInfoKHR {}
impl default::Default for XlibSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: XlibSurfaceCreateFlagsKHR::default(),
            dpy: ptr::null_mut(),
            window: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for XlibSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XlibSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dpy", &self.dpy)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XcbSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
}
unsafe impl Send for XcbSurfaceCreateInfoKHR {}
unsafe impl Sync for XcbSurfaceCreateInfoKHR {}
impl default::Default for XcbSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::XCB_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: XcbSurfaceCreateFlagsKHR::default(),
            connection: ptr::null_mut(),
            window: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for XcbSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XcbSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("connection", &self.connection)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DirectFBSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DirectFBSurfaceCreateFlagsEXT,
    pub dfb: *mut IDirectFB,
    pub surface: *mut IDirectFBSurface,
}
unsafe impl Send for DirectFBSurfaceCreateInfoEXT {}
unsafe impl Sync for DirectFBSurfaceCreateInfoEXT {}
impl default::Default for DirectFBSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DIRECTFB_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: DirectFBSurfaceCreateFlagsEXT::default(),
            dfb: ptr::null_mut(),
            surface: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DirectFBSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DirectFBSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dfb", &self.dfb)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
    pub image_pipe_handle: zx_handle_t,
}
unsafe impl Send for ImagePipeSurfaceCreateInfoFUCHSIA {}
unsafe impl Sync for ImagePipeSurfaceCreateInfoFUCHSIA {}
impl default::Default for ImagePipeSurfaceCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            flags: ImagePipeSurfaceCreateFlagsFUCHSIA::default(),
            image_pipe_handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImagePipeSurfaceCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImagePipeSurfaceCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image_pipe_handle", &self.image_pipe_handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceFormatKHR {
    /// Supported pair of rendering format
    pub format: Format,
    /// and color space for the surface
    pub color_space: ColorSpaceKHR,
}
impl default::Default for SurfaceFormatKHR {
    fn default() -> Self {
        Self {
            format: Format::default(),
            color_space: ColorSpaceKHR::default(),
        }
    }
}
impl fmt::Debug for SurfaceFormatKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFormatKHR")
            .field("format", &self.format)
            .field("color_space", &self.color_space)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SwapchainCreateFlagsKHR,
    /// The swapchain's target surface
    pub surface: Option<SurfaceKHR>,
    /// Minimum number of presentation images the application needs
    pub min_image_count: u32,
    /// Format of the presentation images
    pub image_format: Format,
    /// Colorspace of the presentation images
    pub image_color_space: ColorSpaceKHR,
    /// Dimensions of the presentation images
    pub image_extent: Extent2D,
    /// Determines the number of views for multiview/stereo presentation
    pub image_array_layers: u32,
    /// Bits indicating how the presentation images will be used
    pub image_usage: ImageUsageFlags,
    /// Sharing mode used for the presentation images
    pub image_sharing_mode: SharingMode,
    /// Number of queue families having access to the images in case of concurrent sharing mode
    pub queue_family_index_count: u32,
    /// Array of queue family indices having access to the images in case of concurrent sharing mode
    pub p_queue_family_indices: *const u32,
    /// The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    pub pre_transform: SurfaceTransformFlagsKHR,
    /// The alpha blending mode used when compositing this surface with other surfaces in the window system
    pub composite_alpha: CompositeAlphaFlagsKHR,
    /// Which presentation mode to use for presents on this swap chain
    pub present_mode: PresentModeKHR,
    /// Specifies whether presentable images may be affected by window clip regions
    pub clipped: Bool32,
    /// Existing swap chain to replace, if any
    pub old_swapchain: Option<SwapchainKHR>,
}
unsafe impl Send for SwapchainCreateInfoKHR {}
unsafe impl Sync for SwapchainCreateInfoKHR {}
impl default::Default for SwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: SwapchainCreateFlagsKHR::default(),
            surface: None,
            min_image_count: u32::default(),
            image_format: Format::default(),
            image_color_space: ColorSpaceKHR::default(),
            image_extent: Extent2D::default(),
            image_array_layers: u32::default(),
            image_usage: ImageUsageFlags::default(),
            image_sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ptr::null(),
            pre_transform: SurfaceTransformFlagsKHR::default(),
            composite_alpha: CompositeAlphaFlagsKHR::default(),
            present_mode: PresentModeKHR::default(),
            clipped: Bool32::default(),
            old_swapchain: None,
        }
    }
}
impl fmt::Debug for SwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("surface", &self.surface)
            .field("min_image_count", &self.min_image_count)
            .field("image_format", &self.image_format)
            .field("image_color_space", &self.image_color_space)
            .field("image_extent", &self.image_extent)
            .field("image_array_layers", &self.image_array_layers)
            .field("image_usage", &self.image_usage)
            .field("image_sharing_mode", &self.image_sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .field("pre_transform", &self.pre_transform)
            .field("composite_alpha", &self.composite_alpha)
            .field("present_mode", &self.present_mode)
            .field("clipped", &self.clipped)
            .field("old_swapchain", &self.old_swapchain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of semaphores to wait for before presenting
    pub wait_semaphore_count: u32,
    /// Semaphores to wait for before presenting
    pub p_wait_semaphores: *const Semaphore,
    /// Number of swapchains to present in this call
    pub swapchain_count: u32,
    /// Swapchains to present an image from
    pub p_swapchains: *const SwapchainKHR,
    /// Indices of which presentable images to present
    pub p_image_indices: *const u32,
    /// Optional (i.e. if non-NULL) VkResult for each swapchain
    pub p_results: *mut Result,
}
unsafe impl Send for PresentInfoKHR {}
unsafe impl Sync for PresentInfoKHR {}
impl default::Default for PresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_INFO_KHR,
            p_next: ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ptr::null(),
            swapchain_count: u32::default(),
            p_swapchains: ptr::null(),
            p_image_indices: ptr::null(),
            p_results: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_swapchains", &self.p_swapchains)
            .field("p_image_indices", &self.p_image_indices)
            .field("p_results", &self.p_results)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugReportCallbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Indicates which events call this callback
    pub flags: DebugReportFlagsEXT,
    /// Function pointer of a callback function
    pub pfn_callback: Option<FnDebugReportCallbackEXT>,
    /// User data provided to callback function
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DebugReportCallbackCreateInfoEXT {}
unsafe impl Sync for DebugReportCallbackCreateInfoEXT {}
impl default::Default for DebugReportCallbackCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: DebugReportFlagsEXT::default(),
            pfn_callback: None,
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DebugReportCallbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugReportCallbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_callback",
                if self.pfn_callback.is_some() { &"Some" } else { &"None" },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationFlagsEXT {
    /// Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of validation checks to disable
    pub disabled_validation_check_count: u32,
    /// Validation checks to disable
    pub p_disabled_validation_checks: *const ValidationCheckEXT,
}
unsafe impl Send for ValidationFlagsEXT {}
unsafe impl Sync for ValidationFlagsEXT {}
impl default::Default for ValidationFlagsEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_FLAGS_EXT,
            p_next: ptr::null(),
            disabled_validation_check_count: u32::default(),
            p_disabled_validation_checks: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationFlagsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationFlagsEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("disabled_validation_check_count", &self.disabled_validation_check_count)
            .field("p_disabled_validation_checks", &self.p_disabled_validation_checks)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationFeaturesEXT {
    /// Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of validation features to enable
    pub enabled_validation_feature_count: u32,
    /// Validation features to enable
    pub p_enabled_validation_features: *const ValidationFeatureEnableEXT,
    /// Number of validation features to disable
    pub disabled_validation_feature_count: u32,
    /// Validation features to disable
    pub p_disabled_validation_features: *const ValidationFeatureDisableEXT,
}
unsafe impl Send for ValidationFeaturesEXT {}
unsafe impl Sync for ValidationFeaturesEXT {}
impl default::Default for ValidationFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_FEATURES_EXT,
            p_next: ptr::null(),
            enabled_validation_feature_count: u32::default(),
            p_enabled_validation_features: ptr::null(),
            disabled_validation_feature_count: u32::default(),
            p_disabled_validation_features: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "enabled_validation_feature_count",
                &self.enabled_validation_feature_count,
            )
            .field("p_enabled_validation_features", &self.p_enabled_validation_features)
            .field(
                "disabled_validation_feature_count",
                &self.disabled_validation_feature_count,
            )
            .field("p_disabled_validation_features", &self.p_disabled_validation_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateRasterizationOrderAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Rasterization order to use for the pipeline
    pub rasterization_order: RasterizationOrderAMD,
}
unsafe impl Send for PipelineRasterizationStateRasterizationOrderAMD {}
unsafe impl Sync for PipelineRasterizationStateRasterizationOrderAMD {}
impl default::Default for PipelineRasterizationStateRasterizationOrderAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
            p_next: ptr::null(),
            rasterization_order: RasterizationOrderAMD::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateRasterizationOrderAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateRasterizationOrderAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("rasterization_order", &self.rasterization_order)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// The type of the object
    pub object_type: DebugReportObjectTypeEXT,
    /// The handle of the object, cast to uint64_t
    pub object: u64,
    /// Name to apply to the object
    pub p_object_name: *const c_char,
}
unsafe impl Send for DebugMarkerObjectNameInfoEXT {}
unsafe impl Sync for DebugMarkerObjectNameInfoEXT {}
impl default::Default for DebugMarkerObjectNameInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
            p_next: ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            p_object_name: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugMarkerObjectNameInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerObjectNameInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object", &self.object)
            .field("p_object_name", &self.p_object_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// The type of the object
    pub object_type: DebugReportObjectTypeEXT,
    /// The handle of the object, cast to uint64_t
    pub object: u64,
    /// The name of the tag to set on the object
    pub tag_name: u64,
    /// The length in bytes of the tag data
    pub tag_size: usize,
    /// Tag data to attach to the object
    pub p_tag: *const c_void,
}
unsafe impl Send for DebugMarkerObjectTagInfoEXT {}
unsafe impl Sync for DebugMarkerObjectTagInfoEXT {}
impl default::Default for DebugMarkerObjectTagInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
            p_next: ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugMarkerObjectTagInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerObjectTagInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object", &self.object)
            .field("tag_name", &self.tag_name)
            .field("tag_size", &self.tag_size)
            .field("p_tag", &self.p_tag)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerMarkerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Name of the debug marker
    pub p_marker_name: *const c_char,
    /// Optional color for debug marker
    pub color: [f32; 4],
}
unsafe impl Send for DebugMarkerMarkerInfoEXT {}
unsafe impl Sync for DebugMarkerMarkerInfoEXT {}
impl default::Default for DebugMarkerMarkerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_MARKER_INFO_EXT,
            p_next: ptr::null(),
            p_marker_name: ptr::null(),
            color: [f32::default(); 4],
        }
    }
}
impl fmt::Debug for DebugMarkerMarkerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerMarkerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_marker_name", &self.p_marker_name)
            .field("color", &self.color)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this image uses a dedicated allocation
    pub dedicated_allocation: Bool32,
}
unsafe impl Send for DedicatedAllocationImageCreateInfoNV {}
unsafe impl Sync for DedicatedAllocationImageCreateInfoNV {}
impl default::Default for DedicatedAllocationImageCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            p_next: ptr::null(),
            dedicated_allocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for DedicatedAllocationImageCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationImageCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dedicated_allocation", &self.dedicated_allocation)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationBufferCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this buffer uses a dedicated allocation
    pub dedicated_allocation: Bool32,
}
unsafe impl Send for DedicatedAllocationBufferCreateInfoNV {}
unsafe impl Sync for DedicatedAllocationBufferCreateInfoNV {}
impl default::Default for DedicatedAllocationBufferCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
            p_next: ptr::null(),
            dedicated_allocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for DedicatedAllocationBufferCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationBufferCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dedicated_allocation", &self.dedicated_allocation)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image that this allocation will be bound to
    pub image: Option<Image>,
    /// Buffer that this allocation will be bound to
    pub buffer: Option<Buffer>,
}
unsafe impl Send for DedicatedAllocationMemoryAllocateInfoNV {}
unsafe impl Sync for DedicatedAllocationMemoryAllocateInfoNV {}
impl default::Default for DedicatedAllocationMemoryAllocateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
            p_next: ptr::null(),
            image: None,
            buffer: None,
        }
    }
}
impl fmt::Debug for DedicatedAllocationMemoryAllocateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationMemoryAllocateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("buffer", &self.buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalImageFormatPropertiesNV {
    pub image_format_properties: ImageFormatProperties,
    pub external_memory_features: ExternalMemoryFeatureFlagsNV,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl default::Default for ExternalImageFormatPropertiesNV {
    fn default() -> Self {
        Self {
            image_format_properties: ImageFormatProperties::default(),
            external_memory_features: ExternalMemoryFeatureFlagsNV::default(),
            export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
            compatible_handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
        }
    }
}
impl fmt::Debug for ExternalImageFormatPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalImageFormatPropertiesNV")
            .field("image_format_properties", &self.image_format_properties)
            .field("external_memory_features", &self.external_memory_features)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
unsafe impl Send for ExternalMemoryImageCreateInfoNV {}
unsafe impl Sync for ExternalMemoryImageCreateInfoNV {}
impl default::Default for ExternalMemoryImageCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            p_next: ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryImageCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryImageCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
unsafe impl Send for ExportMemoryAllocateInfoNV {}
unsafe impl Sync for ExportMemoryAllocateInfoNV {}
impl default::Default for ExportMemoryAllocateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV,
            p_next: ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
        }
    }
}
impl fmt::Debug for ExportMemoryAllocateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryAllocateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlagsNV,
    pub handle: HANDLE,
}
unsafe impl Send for ImportMemoryWin32HandleInfoNV {}
unsafe impl Sync for ImportMemoryWin32HandleInfoNV {}
impl default::Default for ImportMemoryWin32HandleInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlagsNV::default(),
            handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryWin32HandleInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryWin32HandleInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
}
unsafe impl Send for ExportMemoryWin32HandleInfoNV {}
unsafe impl Sync for ExportMemoryWin32HandleInfoNV {}
impl default::Default for ExportMemoryWin32HandleInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMemoryWin32HandleInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryWin32HandleInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeout_milliseconds: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
unsafe impl Send for Win32KeyedMutexAcquireReleaseInfoNV {}
unsafe impl Sync for Win32KeyedMutexAcquireReleaseInfoNV {}
impl default::Default for Win32KeyedMutexAcquireReleaseInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
            p_next: ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeout_milliseconds: ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
        }
    }
}
impl fmt::Debug for Win32KeyedMutexAcquireReleaseInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32KeyedMutexAcquireReleaseInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acquire_count", &self.acquire_count)
            .field("p_acquire_syncs", &self.p_acquire_syncs)
            .field("p_acquire_keys", &self.p_acquire_keys)
            .field("p_acquire_timeout_milliseconds", &self.p_acquire_timeout_milliseconds)
            .field("release_count", &self.release_count)
            .field("p_release_syncs", &self.p_release_syncs)
            .field("p_release_keys", &self.p_release_keys)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_generated_commands: Bool32,
}
unsafe impl Send for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
impl default::Default for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            p_next: ptr::null_mut(),
            device_generated_commands: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceGeneratedCommandsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_generated_commands", &self.device_generated_commands)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DevicePrivateDataCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub private_data_slot_request_count: u32,
}
unsafe impl Send for DevicePrivateDataCreateInfoEXT {}
unsafe impl Sync for DevicePrivateDataCreateInfoEXT {}
impl default::Default for DevicePrivateDataCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO_EXT,
            p_next: ptr::null(),
            private_data_slot_request_count: u32::default(),
        }
    }
}
impl fmt::Debug for DevicePrivateDataCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DevicePrivateDataCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("private_data_slot_request_count", &self.private_data_slot_request_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrivateDataSlotCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PrivateDataSlotCreateFlagsEXT,
}
unsafe impl Send for PrivateDataSlotCreateInfoEXT {}
unsafe impl Sync for PrivateDataSlotCreateInfoEXT {}
impl default::Default for PrivateDataSlotCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRIVATE_DATA_SLOT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: PrivateDataSlotCreateFlagsEXT::default(),
        }
    }
}
impl fmt::Debug for PrivateDataSlotCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PrivateDataSlotCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePrivateDataFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub private_data: Bool32,
}
unsafe impl Send for PhysicalDevicePrivateDataFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePrivateDataFeaturesEXT {}
impl default::Default for PhysicalDevicePrivateDataFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT,
            p_next: ptr::null_mut(),
            private_data: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePrivateDataFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePrivateDataFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("private_data", &self.private_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_graphics_shader_group_count: u32,
    pub max_indirect_sequence_count: u32,
    pub max_indirect_commands_token_count: u32,
    pub max_indirect_commands_stream_count: u32,
    pub max_indirect_commands_token_offset: u32,
    pub max_indirect_commands_stream_stride: u32,
    pub min_sequences_count_buffer_offset_alignment: u32,
    pub min_sequences_index_buffer_offset_alignment: u32,
    pub min_indirect_commands_buffer_offset_alignment: u32,
}
unsafe impl Send for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}
impl default::Default for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_graphics_shader_group_count: u32::default(),
            max_indirect_sequence_count: u32::default(),
            max_indirect_commands_token_count: u32::default(),
            max_indirect_commands_stream_count: u32::default(),
            max_indirect_commands_token_offset: u32::default(),
            max_indirect_commands_stream_stride: u32::default(),
            min_sequences_count_buffer_offset_alignment: u32::default(),
            min_sequences_index_buffer_offset_alignment: u32::default(),
            min_indirect_commands_buffer_offset_alignment: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceGeneratedCommandsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_graphics_shader_group_count", &self.max_graphics_shader_group_count)
            .field("max_indirect_sequence_count", &self.max_indirect_sequence_count)
            .field(
                "max_indirect_commands_token_count",
                &self.max_indirect_commands_token_count,
            )
            .field(
                "max_indirect_commands_stream_count",
                &self.max_indirect_commands_stream_count,
            )
            .field(
                "max_indirect_commands_token_offset",
                &self.max_indirect_commands_token_offset,
            )
            .field(
                "max_indirect_commands_stream_stride",
                &self.max_indirect_commands_stream_stride,
            )
            .field(
                "min_sequences_count_buffer_offset_alignment",
                &self.min_sequences_count_buffer_offset_alignment,
            )
            .field(
                "min_sequences_index_buffer_offset_alignment",
                &self.min_sequences_index_buffer_offset_alignment,
            )
            .field(
                "min_indirect_commands_buffer_offset_alignment",
                &self.min_indirect_commands_buffer_offset_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiDrawPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multi_draw_count: u32,
}
unsafe impl Send for PhysicalDeviceMultiDrawPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceMultiDrawPropertiesEXT {}
impl default::Default for PhysicalDeviceMultiDrawPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_multi_draw_count: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiDrawPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiDrawPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_multi_draw_count", &self.max_multi_draw_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
}
unsafe impl Send for GraphicsShaderGroupCreateInfoNV {}
unsafe impl Sync for GraphicsShaderGroupCreateInfoNV {}
impl default::Default for GraphicsShaderGroupCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
            p_next: ptr::null(),
            stage_count: u32::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_tessellation_state: ptr::null(),
        }
    }
}
impl fmt::Debug for GraphicsShaderGroupCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsShaderGroupCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("p_vertex_input_state", &self.p_vertex_input_state)
            .field("p_tessellation_state", &self.p_tessellation_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineShaderGroupsCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub group_count: u32,
    pub p_groups: *const GraphicsShaderGroupCreateInfoNV,
    pub pipeline_count: u32,
    pub p_pipelines: *const Pipeline,
}
unsafe impl Send for GraphicsPipelineShaderGroupsCreateInfoNV {}
unsafe impl Sync for GraphicsPipelineShaderGroupsCreateInfoNV {}
impl default::Default for GraphicsPipelineShaderGroupsCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
            p_next: ptr::null(),
            group_count: u32::default(),
            p_groups: ptr::null(),
            pipeline_count: u32::default(),
            p_pipelines: ptr::null(),
        }
    }
}
impl fmt::Debug for GraphicsPipelineShaderGroupsCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsPipelineShaderGroupsCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field("pipeline_count", &self.pipeline_count)
            .field("p_pipelines", &self.p_pipelines)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct BindShaderGroupIndirectCommandNV {
    pub group_index: u32,
}
impl default::Default for BindShaderGroupIndirectCommandNV {
    fn default() -> Self {
        Self {
            group_index: u32::default(),
        }
    }
}
impl fmt::Debug for BindShaderGroupIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindShaderGroupIndirectCommandNV")
            .field("group_index", &self.group_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct BindIndexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub index_type: IndexType,
}
impl default::Default for BindIndexBufferIndirectCommandNV {
    fn default() -> Self {
        Self {
            buffer_address: DeviceAddress::default(),
            size: u32::default(),
            index_type: IndexType::default(),
        }
    }
}
impl fmt::Debug for BindIndexBufferIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindIndexBufferIndirectCommandNV")
            .field("buffer_address", &self.buffer_address)
            .field("size", &self.size)
            .field("index_type", &self.index_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct BindVertexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub stride: u32,
}
impl default::Default for BindVertexBufferIndirectCommandNV {
    fn default() -> Self {
        Self {
            buffer_address: DeviceAddress::default(),
            size: u32::default(),
            stride: u32::default(),
        }
    }
}
impl fmt::Debug for BindVertexBufferIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindVertexBufferIndirectCommandNV")
            .field("buffer_address", &self.buffer_address)
            .field("size", &self.size)
            .field("stride", &self.stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct SetStateFlagsIndirectCommandNV {
    pub data: u32,
}
impl default::Default for SetStateFlagsIndirectCommandNV {
    fn default() -> Self {
        Self { data: u32::default() }
    }
}
impl fmt::Debug for SetStateFlagsIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SetStateFlagsIndirectCommandNV")
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndirectCommandsStreamNV {
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
}
impl default::Default for IndirectCommandsStreamNV {
    fn default() -> Self {
        Self {
            buffer: None,
            offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for IndirectCommandsStreamNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsStreamNV")
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndirectCommandsLayoutTokenNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub token_type: IndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertex_binding_unit: u32,
    pub vertex_dynamic_stride: Bool32,
    pub pushconstant_pipeline_layout: Option<PipelineLayout>,
    pub pushconstant_shader_stage_flags: ShaderStageFlags,
    pub pushconstant_offset: u32,
    pub pushconstant_size: u32,
    pub indirect_state_flags: IndirectStateFlagsNV,
    pub index_type_count: u32,
    pub p_index_types: *const IndexType,
    pub p_index_type_values: *const u32,
}
unsafe impl Send for IndirectCommandsLayoutTokenNV {}
unsafe impl Sync for IndirectCommandsLayoutTokenNV {}
impl default::Default for IndirectCommandsLayoutTokenNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
            p_next: ptr::null(),
            token_type: IndirectCommandsTokenTypeNV::default(),
            stream: u32::default(),
            offset: u32::default(),
            vertex_binding_unit: u32::default(),
            vertex_dynamic_stride: Bool32::default(),
            pushconstant_pipeline_layout: None,
            pushconstant_shader_stage_flags: ShaderStageFlags::default(),
            pushconstant_offset: u32::default(),
            pushconstant_size: u32::default(),
            indirect_state_flags: IndirectStateFlagsNV::default(),
            index_type_count: u32::default(),
            p_index_types: ptr::null(),
            p_index_type_values: ptr::null(),
        }
    }
}
impl fmt::Debug for IndirectCommandsLayoutTokenNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsLayoutTokenNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("token_type", &self.token_type)
            .field("stream", &self.stream)
            .field("offset", &self.offset)
            .field("vertex_binding_unit", &self.vertex_binding_unit)
            .field("vertex_dynamic_stride", &self.vertex_dynamic_stride)
            .field("pushconstant_pipeline_layout", &self.pushconstant_pipeline_layout)
            .field("pushconstant_shader_stage_flags", &self.pushconstant_shader_stage_flags)
            .field("pushconstant_offset", &self.pushconstant_offset)
            .field("pushconstant_size", &self.pushconstant_size)
            .field("indirect_state_flags", &self.indirect_state_flags)
            .field("index_type_count", &self.index_type_count)
            .field("p_index_types", &self.p_index_types)
            .field("p_index_type_values", &self.p_index_type_values)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndirectCommandsLayoutCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IndirectCommandsLayoutUsageFlagsNV,
    pub pipeline_bind_point: PipelineBindPoint,
    pub token_count: u32,
    pub p_tokens: *const IndirectCommandsLayoutTokenNV,
    pub stream_count: u32,
    pub p_stream_strides: *const u32,
}
unsafe impl Send for IndirectCommandsLayoutCreateInfoNV {}
unsafe impl Sync for IndirectCommandsLayoutCreateInfoNV {}
impl default::Default for IndirectCommandsLayoutCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: IndirectCommandsLayoutUsageFlagsNV::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            token_count: u32::default(),
            p_tokens: ptr::null(),
            stream_count: u32::default(),
            p_stream_strides: ptr::null(),
        }
    }
}
impl fmt::Debug for IndirectCommandsLayoutCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsLayoutCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("token_count", &self.token_count)
            .field("p_tokens", &self.p_tokens)
            .field("stream_count", &self.stream_count)
            .field("p_stream_strides", &self.p_stream_strides)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeneratedCommandsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub stream_count: u32,
    pub p_streams: *const IndirectCommandsStreamNV,
    pub sequences_count: u32,
    pub preprocess_buffer: Option<Buffer>,
    pub preprocess_offset: DeviceSize,
    pub preprocess_size: DeviceSize,
    pub sequences_count_buffer: Option<Buffer>,
    pub sequences_count_offset: DeviceSize,
    pub sequences_index_buffer: Option<Buffer>,
    pub sequences_index_offset: DeviceSize,
}
unsafe impl Send for GeneratedCommandsInfoNV {}
unsafe impl Sync for GeneratedCommandsInfoNV {}
impl default::Default for GeneratedCommandsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GENERATED_COMMANDS_INFO_NV,
            p_next: ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: None,
            indirect_commands_layout: None,
            stream_count: u32::default(),
            p_streams: ptr::null(),
            sequences_count: u32::default(),
            preprocess_buffer: None,
            preprocess_offset: DeviceSize::default(),
            preprocess_size: DeviceSize::default(),
            sequences_count_buffer: None,
            sequences_count_offset: DeviceSize::default(),
            sequences_index_buffer: None,
            sequences_index_offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for GeneratedCommandsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeneratedCommandsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline", &self.pipeline)
            .field("indirect_commands_layout", &self.indirect_commands_layout)
            .field("stream_count", &self.stream_count)
            .field("p_streams", &self.p_streams)
            .field("sequences_count", &self.sequences_count)
            .field("preprocess_buffer", &self.preprocess_buffer)
            .field("preprocess_offset", &self.preprocess_offset)
            .field("preprocess_size", &self.preprocess_size)
            .field("sequences_count_buffer", &self.sequences_count_buffer)
            .field("sequences_count_offset", &self.sequences_count_offset)
            .field("sequences_index_buffer", &self.sequences_index_buffer)
            .field("sequences_index_offset", &self.sequences_index_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeneratedCommandsMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub max_sequences_count: u32,
}
unsafe impl Send for GeneratedCommandsMemoryRequirementsInfoNV {}
unsafe impl Sync for GeneratedCommandsMemoryRequirementsInfoNV {}
impl default::Default for GeneratedCommandsMemoryRequirementsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: None,
            indirect_commands_layout: None,
            max_sequences_count: u32::default(),
        }
    }
}
impl fmt::Debug for GeneratedCommandsMemoryRequirementsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeneratedCommandsMemoryRequirementsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline", &self.pipeline)
            .field("indirect_commands_layout", &self.indirect_commands_layout)
            .field("max_sequences_count", &self.max_sequences_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFeatures2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub features: PhysicalDeviceFeatures,
}
unsafe impl Send for PhysicalDeviceFeatures2 {}
unsafe impl Sync for PhysicalDeviceFeatures2 {}
impl default::Default for PhysicalDeviceFeatures2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FEATURES_2,
            p_next: ptr::null_mut(),
            features: PhysicalDeviceFeatures::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFeatures2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFeatures2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("features", &self.features)
            .finish()
    }
}
pub type PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: PhysicalDeviceProperties,
}
unsafe impl Send for PhysicalDeviceProperties2 {}
unsafe impl Sync for PhysicalDeviceProperties2 {}
impl default::Default for PhysicalDeviceProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROPERTIES_2,
            p_next: ptr::null_mut(),
            properties: PhysicalDeviceProperties::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("properties", &self.properties)
            .finish()
    }
}
pub type PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_properties: FormatProperties,
}
unsafe impl Send for FormatProperties2 {}
unsafe impl Sync for FormatProperties2 {}
impl default::Default for FormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            format_properties: FormatProperties::default(),
        }
    }
}
impl fmt::Debug for FormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_properties", &self.format_properties)
            .finish()
    }
}
pub type FormatProperties2KHR = FormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_format_properties: ImageFormatProperties,
}
unsafe impl Send for ImageFormatProperties2 {}
unsafe impl Sync for ImageFormatProperties2 {}
impl default::Default for ImageFormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            image_format_properties: ImageFormatProperties::default(),
        }
    }
}
impl fmt::Debug for ImageFormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_format_properties", &self.image_format_properties)
            .finish()
    }
}
pub type ImageFormatProperties2KHR = ImageFormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub flags: ImageCreateFlags,
}
unsafe impl Send for PhysicalDeviceImageFormatInfo2 {}
unsafe impl Sync for PhysicalDeviceImageFormatInfo2 {}
impl default::Default for PhysicalDeviceImageFormatInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            p_next: ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            flags: ImageCreateFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageFormatInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageFormatInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ty", &self.ty)
            .field("tiling", &self.tiling)
            .field("usage", &self.usage)
            .field("flags", &self.flags)
            .finish()
    }
}
pub type PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub queue_family_properties: QueueFamilyProperties,
}
unsafe impl Send for QueueFamilyProperties2 {}
unsafe impl Sync for QueueFamilyProperties2 {}
impl default::Default for QueueFamilyProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_PROPERTIES_2,
            p_next: ptr::null_mut(),
            queue_family_properties: QueueFamilyProperties::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("queue_family_properties", &self.queue_family_properties)
            .finish()
    }
}
pub type QueueFamilyProperties2KHR = QueueFamilyProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_properties: PhysicalDeviceMemoryProperties,
}
unsafe impl Send for PhysicalDeviceMemoryProperties2 {}
unsafe impl Sync for PhysicalDeviceMemoryProperties2 {}
impl default::Default for PhysicalDeviceMemoryProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
            p_next: ptr::null_mut(),
            memory_properties: PhysicalDeviceMemoryProperties::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_properties", &self.memory_properties)
            .finish()
    }
}
pub type PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: SparseImageFormatProperties,
}
unsafe impl Send for SparseImageFormatProperties2 {}
unsafe impl Sync for SparseImageFormatProperties2 {}
impl default::Default for SparseImageFormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            properties: SparseImageFormatProperties::default(),
        }
    }
}
impl fmt::Debug for SparseImageFormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageFormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("properties", &self.properties)
            .finish()
    }
}
pub type SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSparseImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub samples: SampleCountFlags,
    pub usage: ImageUsageFlags,
    pub tiling: ImageTiling,
}
unsafe impl Send for PhysicalDeviceSparseImageFormatInfo2 {}
unsafe impl Sync for PhysicalDeviceSparseImageFormatInfo2 {}
impl default::Default for PhysicalDeviceSparseImageFormatInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
            p_next: ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            samples: SampleCountFlags::default(),
            usage: ImageUsageFlags::default(),
            tiling: ImageTiling::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSparseImageFormatInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSparseImageFormatInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ty", &self.ty)
            .field("samples", &self.samples)
            .field("usage", &self.usage)
            .field("tiling", &self.tiling)
            .finish()
    }
}
pub type PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePushDescriptorPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_push_descriptors: u32,
}
unsafe impl Send for PhysicalDevicePushDescriptorPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePushDescriptorPropertiesKHR {}
impl default::Default for PhysicalDevicePushDescriptorPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            max_push_descriptors: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePushDescriptorPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePushDescriptorPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_push_descriptors", &self.max_push_descriptors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
impl default::Default for ConformanceVersion {
    fn default() -> Self {
        Self {
            major: u8::default(),
            minor: u8::default(),
            subminor: u8::default(),
            patch: u8::default(),
        }
    }
}
impl fmt::Debug for ConformanceVersion {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ConformanceVersion")
            .field("major", &self.major)
            .field("minor", &self.minor)
            .field("subminor", &self.subminor)
            .field("patch", &self.patch)
            .finish()
    }
}
pub type ConformanceVersionKHR = ConformanceVersion;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDriverProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
}
unsafe impl Send for PhysicalDeviceDriverProperties {}
unsafe impl Sync for PhysicalDeviceDriverProperties {}
impl default::Default for PhysicalDeviceDriverProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            p_next: ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: [c_char::default(); MAX_DRIVER_NAME_SIZE],
            driver_info: [c_char::default(); MAX_DRIVER_INFO_SIZE],
            conformance_version: ConformanceVersion::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDriverProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDriverProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe { CStr::from_ptr(self.driver_name.as_ptr()) })
            .field("driver_info", &unsafe { CStr::from_ptr(self.driver_info.as_ptr()) })
            .field("conformance_version", &self.conformance_version)
            .finish()
    }
}
pub type PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentRegionsKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// The regions that have changed
    pub p_regions: *const PresentRegionKHR,
}
unsafe impl Send for PresentRegionsKHR {}
unsafe impl Sync for PresentRegionsKHR {}
impl default::Default for PresentRegionsKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_REGIONS_KHR,
            p_next: ptr::null(),
            swapchain_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentRegionsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentRegionsKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentRegionKHR {
    /// Number of rectangles in pRectangles
    pub rectangle_count: u32,
    /// Array of rectangles that have changed in a swapchain's image(s)
    pub p_rectangles: *const RectLayerKHR,
}
unsafe impl Send for PresentRegionKHR {}
unsafe impl Sync for PresentRegionKHR {}
impl default::Default for PresentRegionKHR {
    fn default() -> Self {
        Self {
            rectangle_count: u32::default(),
            p_rectangles: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentRegionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentRegionKHR")
            .field("rectangle_count", &self.rectangle_count)
            .field("p_rectangles", &self.p_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct RectLayerKHR {
    /// upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    pub offset: Offset2D,
    /// Dimensions of a rectangle that has not changed, in pixels of a presentation images
    pub extent: Extent2D,
    /// Layer of a swapchain's image(s), for stereoscopic-3D images
    pub layer: u32,
}
impl default::Default for RectLayerKHR {
    fn default() -> Self {
        Self {
            offset: Offset2D::default(),
            extent: Extent2D::default(),
            layer: u32::default(),
        }
    }
}
impl fmt::Debug for RectLayerKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RectLayerKHR")
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .field("layer", &self.layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVariablePointersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
}
unsafe impl Send for PhysicalDeviceVariablePointersFeatures {}
unsafe impl Sync for PhysicalDeviceVariablePointersFeatures {}
impl default::Default for PhysicalDeviceVariablePointersFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            p_next: ptr::null_mut(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVariablePointersFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVariablePointersFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "variable_pointers_storage_buffer",
                &self.variable_pointers_storage_buffer,
            )
            .field("variable_pointers", &self.variable_pointers)
            .finish()
    }
}
pub type PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub type PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ExternalMemoryProperties {
    pub external_memory_features: ExternalMemoryFeatureFlags,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlags,
}
impl default::Default for ExternalMemoryProperties {
    fn default() -> Self {
        Self {
            external_memory_features: ExternalMemoryFeatureFlags::default(),
            export_from_imported_handle_types: ExternalMemoryHandleTypeFlags::default(),
            compatible_handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryProperties")
            .field("external_memory_features", &self.external_memory_features)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .finish()
    }
}
pub type ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalImageFormatInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalImageFormatInfo {}
unsafe impl Sync for PhysicalDeviceExternalImageFormatInfo {}
impl default::Default for PhysicalDeviceExternalImageFormatInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalImageFormatInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalImageFormatInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
unsafe impl Send for ExternalImageFormatProperties {}
unsafe impl Sync for ExternalImageFormatProperties {}
impl default::Default for ExternalImageFormatProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            p_next: ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
        }
    }
}
impl fmt::Debug for ExternalImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalImageFormatProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_properties", &self.external_memory_properties)
            .finish()
    }
}
pub type ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalBufferInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub usage: BufferUsageFlags,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalBufferInfo {}
unsafe impl Sync for PhysicalDeviceExternalBufferInfo {}
impl default::Default for PhysicalDeviceExternalBufferInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            p_next: ptr::null(),
            flags: BufferCreateFlags::default(),
            usage: BufferUsageFlags::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalBufferInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalBufferInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("usage", &self.usage)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalBufferProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
unsafe impl Send for ExternalBufferProperties {}
unsafe impl Sync for ExternalBufferProperties {}
impl default::Default for ExternalBufferProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_BUFFER_PROPERTIES,
            p_next: ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
        }
    }
}
impl fmt::Debug for ExternalBufferProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalBufferProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_properties", &self.external_memory_properties)
            .finish()
    }
}
pub type ExternalBufferPropertiesKHR = ExternalBufferProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceIDProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
}
unsafe impl Send for PhysicalDeviceIDProperties {}
unsafe impl Sync for PhysicalDeviceIDProperties {}
impl default::Default for PhysicalDeviceIDProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ID_PROPERTIES,
            p_next: ptr::null_mut(),
            device_uuid: [u8::default(); UUID_SIZE],
            driver_uuid: [u8::default(); UUID_SIZE],
            device_luid: [u8::default(); LUID_SIZE],
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceIDProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceIDProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_uuid", &self.device_uuid)
            .field("driver_uuid", &self.driver_uuid)
            .field("device_luid", &self.device_luid)
            .field("device_node_mask", &self.device_node_mask)
            .field("device_luid_valid", &self.device_luid_valid)
            .finish()
    }
}
pub type PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExternalMemoryImageCreateInfo {}
unsafe impl Sync for ExternalMemoryImageCreateInfo {}
impl default::Default for ExternalMemoryImageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryImageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryImageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryBufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExternalMemoryBufferCreateInfo {}
unsafe impl Sync for ExternalMemoryBufferCreateInfo {}
impl default::Default for ExternalMemoryBufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryBufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryBufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExportMemoryAllocateInfo {}
unsafe impl Sync for ExportMemoryAllocateInfo {}
impl default::Default for ExportMemoryAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_ALLOCATE_INFO,
            p_next: ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExportMemoryAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportMemoryWin32HandleInfoKHR {}
unsafe impl Sync for ImportMemoryWin32HandleInfoKHR {}
impl default::Default for ImportMemoryWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportMemoryWin32HandleInfoKHR {}
unsafe impl Sync for ExportMemoryWin32HandleInfoKHR {}
impl default::Default for ExportMemoryWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMemoryWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: zx_handle_t,
}
unsafe impl Send for ImportMemoryZirconHandleInfoFUCHSIA {}
unsafe impl Sync for ImportMemoryZirconHandleInfoFUCHSIA {}
impl default::Default for ImportMemoryZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryZirconHandlePropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryZirconHandlePropertiesFUCHSIA {}
unsafe impl Sync for MemoryZirconHandlePropertiesFUCHSIA {}
impl default::Default for MemoryZirconHandlePropertiesFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
            p_next: ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryZirconHandlePropertiesFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryZirconHandlePropertiesFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetZirconHandleInfoFUCHSIA {}
unsafe impl Sync for MemoryGetZirconHandleInfoFUCHSIA {}
impl default::Default for MemoryGetZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            memory: None,
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryGetZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryWin32HandlePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryWin32HandlePropertiesKHR {}
unsafe impl Sync for MemoryWin32HandlePropertiesKHR {}
impl default::Default for MemoryWin32HandlePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryWin32HandlePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryWin32HandlePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetWin32HandleInfoKHR {}
unsafe impl Sync for MemoryGetWin32HandleInfoKHR {}
impl default::Default for MemoryGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            memory: None,
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportMemoryFdInfoKHR {}
unsafe impl Sync for ImportMemoryFdInfoKHR {}
impl default::Default for ImportMemoryFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_FD_INFO_KHR,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
impl fmt::Debug for ImportMemoryFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryFdPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryFdPropertiesKHR {}
unsafe impl Sync for MemoryFdPropertiesKHR {}
impl default::Default for MemoryFdPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_FD_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryFdPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryFdPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetFdInfoKHR {}
unsafe impl Sync for MemoryGetFdInfoKHR {}
impl default::Default for MemoryGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            memory: None,
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeouts: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
unsafe impl Send for Win32KeyedMutexAcquireReleaseInfoKHR {}
unsafe impl Sync for Win32KeyedMutexAcquireReleaseInfoKHR {}
impl default::Default for Win32KeyedMutexAcquireReleaseInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            p_next: ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeouts: ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
        }
    }
}
impl fmt::Debug for Win32KeyedMutexAcquireReleaseInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32KeyedMutexAcquireReleaseInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acquire_count", &self.acquire_count)
            .field("p_acquire_syncs", &self.p_acquire_syncs)
            .field("p_acquire_keys", &self.p_acquire_keys)
            .field("p_acquire_timeouts", &self.p_acquire_timeouts)
            .field("release_count", &self.release_count)
            .field("p_release_syncs", &self.p_release_syncs)
            .field("p_release_keys", &self.p_release_keys)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalSemaphoreInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalSemaphoreInfo {}
unsafe impl Sync for PhysicalDeviceExternalSemaphoreInfo {}
impl default::Default for PhysicalDeviceExternalSemaphoreInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            p_next: ptr::null(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalSemaphoreInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalSemaphoreInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub external_semaphore_features: ExternalSemaphoreFeatureFlags,
}
unsafe impl Send for ExternalSemaphoreProperties {}
unsafe impl Sync for ExternalSemaphoreProperties {}
impl default::Default for ExternalSemaphoreProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_SEMAPHORE_PROPERTIES,
            p_next: ptr::null_mut(),
            export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            compatible_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            external_semaphore_features: ExternalSemaphoreFeatureFlags::default(),
        }
    }
}
impl fmt::Debug for ExternalSemaphoreProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalSemaphoreProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .field("external_semaphore_features", &self.external_semaphore_features)
            .finish()
    }
}
pub type ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportSemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for ExportSemaphoreCreateInfo {}
unsafe impl Sync for ExportSemaphoreCreateInfo {}
impl default::Default for ExportSemaphoreCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_SEMAPHORE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExportSemaphoreCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportSemaphoreCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportSemaphoreWin32HandleInfoKHR {}
unsafe impl Sync for ImportSemaphoreWin32HandleInfoKHR {}
impl default::Default for ImportSemaphoreWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            semaphore: None,
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportSemaphoreWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportSemaphoreWin32HandleInfoKHR {}
unsafe impl Sync for ExportSemaphoreWin32HandleInfoKHR {}
impl default::Default for ExportSemaphoreWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportSemaphoreWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportSemaphoreWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct D3D12FenceSubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_values_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_values_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
unsafe impl Send for D3D12FenceSubmitInfoKHR {}
unsafe impl Sync for D3D12FenceSubmitInfoKHR {}
impl default::Default for D3D12FenceSubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::D3D12_FENCE_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            wait_semaphore_values_count: u32::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_values_count: u32::default(),
            p_signal_semaphore_values: ptr::null(),
        }
    }
}
impl fmt::Debug for D3D12FenceSubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("D3D12FenceSubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_values_count", &self.wait_semaphore_values_count)
            .field("p_wait_semaphore_values", &self.p_wait_semaphore_values)
            .field("signal_semaphore_values_count", &self.signal_semaphore_values_count)
            .field("p_signal_semaphore_values", &self.p_signal_semaphore_values)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetWin32HandleInfoKHR {}
unsafe impl Sync for SemaphoreGetWin32HandleInfoKHR {}
impl default::Default for SemaphoreGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            semaphore: None,
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportSemaphoreFdInfoKHR {}
unsafe impl Sync for ImportSemaphoreFdInfoKHR {}
impl default::Default for ImportSemaphoreFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR,
            p_next: ptr::null(),
            semaphore: None,
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
impl fmt::Debug for ImportSemaphoreFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetFdInfoKHR {}
unsafe impl Sync for SemaphoreGetFdInfoKHR {}
impl default::Default for SemaphoreGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            semaphore: None,
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub zircon_handle: zx_handle_t,
}
unsafe impl Send for ImportSemaphoreZirconHandleInfoFUCHSIA {}
unsafe impl Sync for ImportSemaphoreZirconHandleInfoFUCHSIA {}
impl default::Default for ImportSemaphoreZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            semaphore: None,
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            zircon_handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportSemaphoreZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("zircon_handle", &self.zircon_handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetZirconHandleInfoFUCHSIA {}
unsafe impl Sync for SemaphoreGetZirconHandleInfoFUCHSIA {}
impl default::Default for SemaphoreGetZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            semaphore: None,
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalFenceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalFenceInfo {}
unsafe impl Sync for PhysicalDeviceExternalFenceInfo {}
impl default::Default for PhysicalDeviceExternalFenceInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
            p_next: ptr::null(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalFenceInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalFenceInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalFenceProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    pub compatible_handle_types: ExternalFenceHandleTypeFlags,
    pub external_fence_features: ExternalFenceFeatureFlags,
}
unsafe impl Send for ExternalFenceProperties {}
unsafe impl Sync for ExternalFenceProperties {}
impl default::Default for ExternalFenceProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_FENCE_PROPERTIES,
            p_next: ptr::null_mut(),
            export_from_imported_handle_types: ExternalFenceHandleTypeFlags::default(),
            compatible_handle_types: ExternalFenceHandleTypeFlags::default(),
            external_fence_features: ExternalFenceFeatureFlags::default(),
        }
    }
}
impl fmt::Debug for ExternalFenceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalFenceProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .field("external_fence_features", &self.external_fence_features)
            .finish()
    }
}
pub type ExternalFencePropertiesKHR = ExternalFenceProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportFenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for ExportFenceCreateInfo {}
unsafe impl Sync for ExportFenceCreateInfo {}
impl default::Default for ExportFenceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_FENCE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for ExportFenceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportFenceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportFenceWin32HandleInfoKHR {}
unsafe impl Sync for ImportFenceWin32HandleInfoKHR {}
impl default::Default for ImportFenceWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            fence: None,
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportFenceWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportFenceWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportFenceWin32HandleInfoKHR {}
unsafe impl Sync for ExportFenceWin32HandleInfoKHR {}
impl default::Default for ExportFenceWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportFenceWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportFenceWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for FenceGetWin32HandleInfoKHR {}
unsafe impl Sync for FenceGetWin32HandleInfoKHR {}
impl default::Default for FenceGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            fence: None,
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for FenceGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportFenceFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportFenceFdInfoKHR {}
unsafe impl Sync for ImportFenceFdInfoKHR {}
impl default::Default for ImportFenceFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_FENCE_FD_INFO_KHR,
            p_next: ptr::null(),
            fence: None,
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
impl fmt::Debug for ImportFenceFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportFenceFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for FenceGetFdInfoKHR {}
unsafe impl Sync for FenceGetFdInfoKHR {}
impl default::Default for FenceGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            fence: None,
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for FenceGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Multiple views in a renderpass
    pub multiview: Bool32,
    /// Multiple views in a renderpass w/ geometry shader
    pub multiview_geometry_shader: Bool32,
    /// Multiple views in a renderpass w/ tessellation shader
    pub multiview_tessellation_shader: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiviewFeatures {}
unsafe impl Sync for PhysicalDeviceMultiviewFeatures {}
impl default::Default for PhysicalDeviceMultiviewFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            p_next: ptr::null_mut(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("multiview", &self.multiview)
            .field("multiview_geometry_shader", &self.multiview_geometry_shader)
            .field("multiview_tessellation_shader", &self.multiview_tessellation_shader)
            .finish()
    }
}
pub type PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max number of views in a subpass
    pub max_multiview_view_count: u32,
    /// max instance index for a draw in a multiview subpass
    pub max_multiview_instance_index: u32,
}
unsafe impl Send for PhysicalDeviceMultiviewProperties {}
unsafe impl Sync for PhysicalDeviceMultiviewProperties {}
impl default::Default for PhysicalDeviceMultiviewProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            p_next: ptr::null_mut(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_multiview_view_count", &self.max_multiview_view_count)
            .field("max_multiview_instance_index", &self.max_multiview_instance_index)
            .finish()
    }
}
pub type PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassMultiviewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub subpass_count: u32,
    pub p_view_masks: *const u32,
    pub dependency_count: u32,
    pub p_view_offsets: *const i32,
    pub correlation_mask_count: u32,
    pub p_correlation_masks: *const u32,
}
unsafe impl Send for RenderPassMultiviewCreateInfo {}
unsafe impl Sync for RenderPassMultiviewCreateInfo {}
impl default::Default for RenderPassMultiviewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO,
            p_next: ptr::null(),
            subpass_count: u32::default(),
            p_view_masks: ptr::null(),
            dependency_count: u32::default(),
            p_view_offsets: ptr::null(),
            correlation_mask_count: u32::default(),
            p_correlation_masks: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassMultiviewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassMultiviewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subpass_count", &self.subpass_count)
            .field("p_view_masks", &self.p_view_masks)
            .field("dependency_count", &self.dependency_count)
            .field("p_view_offsets", &self.p_view_offsets)
            .field("correlation_mask_count", &self.correlation_mask_count)
            .field("p_correlation_masks", &self.p_correlation_masks)
            .finish()
    }
}
pub type RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilities2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Supported minimum number of images for the surface
    pub min_image_count: u32,
    /// Supported maximum number of images for the surface, 0 for unlimited
    pub max_image_count: u32,
    /// Current image width and height for the surface, (0, 0) if undefined
    pub current_extent: Extent2D,
    /// Supported minimum image width and height for the surface
    pub min_image_extent: Extent2D,
    /// Supported maximum image width and height for the surface
    pub max_image_extent: Extent2D,
    /// Supported maximum number of image layers for the surface
    pub max_image_array_layers: u32,
    /// 1 or more bits representing the transforms supported
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// The surface's current transform relative to the device's natural orientation
    pub current_transform: SurfaceTransformFlagsKHR,
    /// 1 or more bits representing the alpha compositing modes supported
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    /// Supported image usage flags for the surface
    pub supported_usage_flags: ImageUsageFlags,
    pub supported_surface_counters: SurfaceCounterFlagsEXT,
}
unsafe impl Send for SurfaceCapabilities2EXT {}
unsafe impl Sync for SurfaceCapabilities2EXT {}
impl default::Default for SurfaceCapabilities2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_2_EXT,
            p_next: ptr::null_mut(),
            min_image_count: u32::default(),
            max_image_count: u32::default(),
            current_extent: Extent2D::default(),
            min_image_extent: Extent2D::default(),
            max_image_extent: Extent2D::default(),
            max_image_array_layers: u32::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            current_transform: SurfaceTransformFlagsKHR::default(),
            supported_composite_alpha: CompositeAlphaFlagsKHR::default(),
            supported_usage_flags: ImageUsageFlags::default(),
            supported_surface_counters: SurfaceCounterFlagsEXT::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilities2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilities2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_image_count", &self.min_image_count)
            .field("max_image_count", &self.max_image_count)
            .field("current_extent", &self.current_extent)
            .field("min_image_extent", &self.min_image_extent)
            .field("max_image_extent", &self.max_image_extent)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("supported_transforms", &self.supported_transforms)
            .field("current_transform", &self.current_transform)
            .field("supported_composite_alpha", &self.supported_composite_alpha)
            .field("supported_usage_flags", &self.supported_usage_flags)
            .field("supported_surface_counters", &self.supported_surface_counters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPowerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub power_state: DisplayPowerStateEXT,
}
unsafe impl Send for DisplayPowerInfoEXT {}
unsafe impl Sync for DisplayPowerInfoEXT {}
impl default::Default for DisplayPowerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_POWER_INFO_EXT,
            p_next: ptr::null(),
            power_state: DisplayPowerStateEXT::default(),
        }
    }
}
impl fmt::Debug for DisplayPowerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPowerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("power_state", &self.power_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_event: DeviceEventTypeEXT,
}
unsafe impl Send for DeviceEventInfoEXT {}
unsafe impl Sync for DeviceEventInfoEXT {}
impl default::Default for DeviceEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_EVENT_INFO_EXT,
            p_next: ptr::null(),
            device_event: DeviceEventTypeEXT::default(),
        }
    }
}
impl fmt::Debug for DeviceEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_event", &self.device_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_event: DisplayEventTypeEXT,
}
unsafe impl Send for DisplayEventInfoEXT {}
unsafe impl Sync for DisplayEventInfoEXT {}
impl default::Default for DisplayEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_EVENT_INFO_EXT,
            p_next: ptr::null(),
            display_event: DisplayEventTypeEXT::default(),
        }
    }
}
impl fmt::Debug for DisplayEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_event", &self.display_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainCounterCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface_counters: SurfaceCounterFlagsEXT,
}
unsafe impl Send for SwapchainCounterCreateInfoEXT {}
unsafe impl Sync for SwapchainCounterCreateInfoEXT {}
impl default::Default for SwapchainCounterCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            p_next: ptr::null(),
            surface_counters: SurfaceCounterFlagsEXT::default(),
        }
    }
}
impl fmt::Debug for SwapchainCounterCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainCounterCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_counters", &self.surface_counters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub physical_device_count: u32,
    pub physical_devices: [Option<PhysicalDevice>; MAX_DEVICE_GROUP_SIZE],
    pub subset_allocation: Bool32,
}
unsafe impl Send for PhysicalDeviceGroupProperties {}
unsafe impl Sync for PhysicalDeviceGroupProperties {}
impl default::Default for PhysicalDeviceGroupProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES,
            p_next: ptr::null_mut(),
            physical_device_count: u32::default(),
            physical_devices: [None; MAX_DEVICE_GROUP_SIZE],
            subset_allocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGroupProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGroupProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("physical_device_count", &self.physical_device_count)
            .field("physical_devices", &self.physical_devices)
            .field("subset_allocation", &self.subset_allocation)
            .finish()
    }
}
pub type PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryAllocateFlagsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryAllocateFlags,
    pub device_mask: u32,
}
unsafe impl Send for MemoryAllocateFlagsInfo {}
unsafe impl Sync for MemoryAllocateFlagsInfo {}
impl default::Default for MemoryAllocateFlagsInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ALLOCATE_FLAGS_INFO,
            p_next: ptr::null(),
            flags: MemoryAllocateFlags::default(),
            device_mask: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryAllocateFlagsInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryAllocateFlagsInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
pub type MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindBufferMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
}
unsafe impl Send for BindBufferMemoryInfo {}
unsafe impl Sync for BindBufferMemoryInfo {}
impl default::Default for BindBufferMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_BUFFER_MEMORY_INFO,
            p_next: ptr::null(),
            buffer: None,
            memory: None,
            memory_offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BindBufferMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindBufferMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .finish()
    }
}
pub type BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindBufferMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
unsafe impl Send for BindBufferMemoryDeviceGroupInfo {}
unsafe impl Sync for BindBufferMemoryDeviceGroupInfo {}
impl default::Default for BindBufferMemoryDeviceGroupInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            p_next: ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BindBufferMemoryDeviceGroupInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindBufferMemoryDeviceGroupInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .finish()
    }
}
pub type BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
}
unsafe impl Send for BindImageMemoryInfo {}
unsafe impl Sync for BindImageMemoryInfo {}
impl default::Default for BindImageMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_INFO,
            p_next: ptr::null(),
            image: None,
            memory: None,
            memory_offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BindImageMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .finish()
    }
}
pub type BindImageMemoryInfoKHR = BindImageMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub split_instance_bind_region_count: u32,
    pub p_split_instance_bind_regions: *const Rect2D,
}
unsafe impl Send for BindImageMemoryDeviceGroupInfo {}
unsafe impl Sync for BindImageMemoryDeviceGroupInfo {}
impl default::Default for BindImageMemoryDeviceGroupInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            p_next: ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ptr::null(),
            split_instance_bind_region_count: u32::default(),
            p_split_instance_bind_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for BindImageMemoryDeviceGroupInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemoryDeviceGroupInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .field(
                "split_instance_bind_region_count",
                &self.split_instance_bind_region_count,
            )
            .field("p_split_instance_bind_regions", &self.p_split_instance_bind_regions)
            .finish()
    }
}
pub type BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupRenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
    pub device_render_area_count: u32,
    pub p_device_render_areas: *const Rect2D,
}
unsafe impl Send for DeviceGroupRenderPassBeginInfo {}
unsafe impl Sync for DeviceGroupRenderPassBeginInfo {}
impl default::Default for DeviceGroupRenderPassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            p_next: ptr::null(),
            device_mask: u32::default(),
            device_render_area_count: u32::default(),
            p_device_render_areas: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupRenderPassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupRenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_mask", &self.device_mask)
            .field("device_render_area_count", &self.device_render_area_count)
            .field("p_device_render_areas", &self.p_device_render_areas)
            .finish()
    }
}
pub type DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupCommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
}
unsafe impl Send for DeviceGroupCommandBufferBeginInfo {}
unsafe impl Sync for DeviceGroupCommandBufferBeginInfo {}
impl default::Default for DeviceGroupCommandBufferBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            p_next: ptr::null(),
            device_mask: u32::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupCommandBufferBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupCommandBufferBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
pub type DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphore_device_indices: *const u32,
    pub command_buffer_count: u32,
    pub p_command_buffer_device_masks: *const u32,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphore_device_indices: *const u32,
}
unsafe impl Send for DeviceGroupSubmitInfo {}
unsafe impl Sync for DeviceGroupSubmitInfo {}
impl default::Default for DeviceGroupSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphore_device_indices: ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffer_device_masks: ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphore_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphore_device_indices", &self.p_wait_semaphore_device_indices)
            .field("command_buffer_count", &self.command_buffer_count)
            .field("p_command_buffer_device_masks", &self.p_command_buffer_device_masks)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field(
                "p_signal_semaphore_device_indices",
                &self.p_signal_semaphore_device_indices,
            )
            .finish()
    }
}
pub type DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupBindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub resource_device_index: u32,
    pub memory_device_index: u32,
}
unsafe impl Send for DeviceGroupBindSparseInfo {}
unsafe impl Sync for DeviceGroupBindSparseInfo {}
impl default::Default for DeviceGroupBindSparseInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_BIND_SPARSE_INFO,
            p_next: ptr::null(),
            resource_device_index: u32::default(),
            memory_device_index: u32::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupBindSparseInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupBindSparseInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("resource_device_index", &self.resource_device_index)
            .field("memory_device_index", &self.memory_device_index)
            .finish()
    }
}
pub type DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupPresentCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupPresentCapabilitiesKHR {}
unsafe impl Sync for DeviceGroupPresentCapabilitiesKHR {}
impl default::Default for DeviceGroupPresentCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
            p_next: ptr::null_mut(),
            present_mask: [u32::default(); MAX_DEVICE_GROUP_SIZE],
            modes: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupPresentCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupPresentCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_mask", &self.present_mask)
            .field("modes", &self.modes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
}
unsafe impl Send for ImageSwapchainCreateInfoKHR {}
unsafe impl Sync for ImageSwapchainCreateInfoKHR {}
impl default::Default for ImageSwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            swapchain: None,
        }
    }
}
impl fmt::Debug for ImageSwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemorySwapchainInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
    pub image_index: u32,
}
unsafe impl Send for BindImageMemorySwapchainInfoKHR {}
unsafe impl Sync for BindImageMemorySwapchainInfoKHR {}
impl default::Default for BindImageMemorySwapchainInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            p_next: ptr::null(),
            swapchain: None,
            image_index: u32::default(),
        }
    }
}
impl fmt::Debug for BindImageMemorySwapchainInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemorySwapchainInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .field("image_index", &self.image_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AcquireNextImageInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
    pub timeout: u64,
    pub semaphore: Option<Semaphore>,
    pub fence: Option<Fence>,
    pub device_mask: u32,
}
unsafe impl Send for AcquireNextImageInfoKHR {}
unsafe impl Sync for AcquireNextImageInfoKHR {}
impl default::Default for AcquireNextImageInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR,
            p_next: ptr::null(),
            swapchain: None,
            timeout: u64::default(),
            semaphore: None,
            fence: None,
            device_mask: u32::default(),
        }
    }
}
impl fmt::Debug for AcquireNextImageInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AcquireNextImageInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .field("timeout", &self.timeout)
            .field("semaphore", &self.semaphore)
            .field("fence", &self.fence)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_device_masks: *const u32,
    pub mode: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupPresentInfoKHR {}
unsafe impl Sync for DeviceGroupPresentInfoKHR {}
impl default::Default for DeviceGroupPresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_PRESENT_INFO_KHR,
            p_next: ptr::null(),
            swapchain_count: u32::default(),
            p_device_masks: ptr::null(),
            mode: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupPresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupPresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_device_masks", &self.p_device_masks)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupDeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub physical_device_count: u32,
    pub p_physical_devices: *const PhysicalDevice,
}
unsafe impl Send for DeviceGroupDeviceCreateInfo {}
unsafe impl Sync for DeviceGroupDeviceCreateInfo {}
impl default::Default for DeviceGroupDeviceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO,
            p_next: ptr::null(),
            physical_device_count: u32::default(),
            p_physical_devices: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupDeviceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupDeviceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("physical_device_count", &self.physical_device_count)
            .field("p_physical_devices", &self.p_physical_devices)
            .finish()
    }
}
pub type DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupSwapchainCreateInfoKHR {}
unsafe impl Sync for DeviceGroupSwapchainCreateInfoKHR {}
impl default::Default for DeviceGroupSwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            modes: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupSwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupSwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("modes", &self.modes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateEntry {
    /// Binding within the destination descriptor set to write
    pub dst_binding: u32,
    /// Array element within the destination binding to write
    pub dst_array_element: u32,
    /// Number of descriptors to write
    pub descriptor_count: u32,
    /// Descriptor type to write
    pub descriptor_type: DescriptorType,
    /// Offset into pData where the descriptors to update are stored
    pub offset: usize,
    /// Stride between two descriptors in pData when writing more than one descriptor
    pub stride: usize,
}
impl default::Default for DescriptorUpdateTemplateEntry {
    fn default() -> Self {
        Self {
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
            descriptor_type: DescriptorType::default(),
            offset: usize::default(),
            stride: usize::default(),
        }
    }
}
impl fmt::Debug for DescriptorUpdateTemplateEntry {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorUpdateTemplateEntry")
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .field("descriptor_type", &self.descriptor_type)
            .field("offset", &self.offset)
            .field("stride", &self.stride)
            .finish()
    }
}
pub type DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorUpdateTemplateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorUpdateTemplateCreateFlags,
    /// Number of descriptor update entries to use for the update template
    pub descriptor_update_entry_count: u32,
    /// Descriptor update entries for the template
    pub p_descriptor_update_entries: *const DescriptorUpdateTemplateEntry,
    pub template_type: DescriptorUpdateTemplateType,
    pub descriptor_set_layout: Option<DescriptorSetLayout>,
    pub pipeline_bind_point: PipelineBindPoint,
    /// If used for push descriptors, this is the only allowed layout
    pub pipeline_layout: Option<PipelineLayout>,
    pub set: u32,
}
unsafe impl Send for DescriptorUpdateTemplateCreateInfo {}
unsafe impl Sync for DescriptorUpdateTemplateCreateInfo {}
impl default::Default for DescriptorUpdateTemplateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: DescriptorUpdateTemplateCreateFlags::default(),
            descriptor_update_entry_count: u32::default(),
            p_descriptor_update_entries: ptr::null(),
            template_type: DescriptorUpdateTemplateType::default(),
            descriptor_set_layout: None,
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline_layout: None,
            set: u32::default(),
        }
    }
}
impl fmt::Debug for DescriptorUpdateTemplateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorUpdateTemplateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("descriptor_update_entry_count", &self.descriptor_update_entry_count)
            .field("p_descriptor_update_entries", &self.p_descriptor_update_entries)
            .field("template_type", &self.template_type)
            .field("descriptor_set_layout", &self.descriptor_set_layout)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline_layout", &self.pipeline_layout)
            .field("set", &self.set)
            .finish()
    }
}
pub type DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
/// Chromaticity coordinate
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XYColorEXT {
    pub x: f32,
    pub y: f32,
}
impl default::Default for XYColorEXT {
    fn default() -> Self {
        Self {
            x: f32::default(),
            y: f32::default(),
        }
    }
}
impl fmt::Debug for XYColorEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XYColorEXT")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePresentIdFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Present ID in VkPresentInfoKHR
    pub present_id: Bool32,
}
unsafe impl Send for PhysicalDevicePresentIdFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePresentIdFeaturesKHR {}
impl default::Default for PhysicalDevicePresentIdFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            p_next: ptr::null_mut(),
            present_id: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePresentIdFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePresentIdFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_id", &self.present_id)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentIdKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// Present ID values for each swapchain
    pub p_present_ids: *const u64,
}
unsafe impl Send for PresentIdKHR {}
unsafe impl Sync for PresentIdKHR {}
impl default::Default for PresentIdKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_ID_KHR,
            p_next: ptr::null(),
            swapchain_count: u32::default(),
            p_present_ids: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentIdKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentIdKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_present_ids", &self.p_present_ids)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePresentWaitFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// vkWaitForPresentKHR is supported
    pub present_wait: Bool32,
}
unsafe impl Send for PhysicalDevicePresentWaitFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePresentWaitFeaturesKHR {}
impl default::Default for PhysicalDevicePresentWaitFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            p_next: ptr::null_mut(),
            present_wait: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePresentWaitFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePresentWaitFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_wait", &self.present_wait)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdrMetadataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Display primary's Red
    pub display_primary_red: XYColorEXT,
    /// Display primary's Green
    pub display_primary_green: XYColorEXT,
    /// Display primary's Blue
    pub display_primary_blue: XYColorEXT,
    /// Display primary's Blue
    pub white_point: XYColorEXT,
    /// Display maximum luminance
    pub max_luminance: f32,
    /// Display minimum luminance
    pub min_luminance: f32,
    /// Content maximum luminance
    pub max_content_light_level: f32,
    pub max_frame_average_light_level: f32,
}
unsafe impl Send for HdrMetadataEXT {}
unsafe impl Sync for HdrMetadataEXT {}
impl default::Default for HdrMetadataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::HDR_METADATA_EXT,
            p_next: ptr::null(),
            display_primary_red: XYColorEXT::default(),
            display_primary_green: XYColorEXT::default(),
            display_primary_blue: XYColorEXT::default(),
            white_point: XYColorEXT::default(),
            max_luminance: f32::default(),
            min_luminance: f32::default(),
            max_content_light_level: f32::default(),
            max_frame_average_light_level: f32::default(),
        }
    }
}
impl fmt::Debug for HdrMetadataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("HdrMetadataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_primary_red", &self.display_primary_red)
            .field("display_primary_green", &self.display_primary_green)
            .field("display_primary_blue", &self.display_primary_blue)
            .field("white_point", &self.white_point)
            .field("max_luminance", &self.max_luminance)
            .field("min_luminance", &self.min_luminance)
            .field("max_content_light_level", &self.max_content_light_level)
            .field("max_frame_average_light_level", &self.max_frame_average_light_level)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub local_dimming_support: Bool32,
}
unsafe impl Send for DisplayNativeHdrSurfaceCapabilitiesAMD {}
unsafe impl Sync for DisplayNativeHdrSurfaceCapabilitiesAMD {}
impl default::Default for DisplayNativeHdrSurfaceCapabilitiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            p_next: ptr::null_mut(),
            local_dimming_support: Bool32::default(),
        }
    }
}
impl fmt::Debug for DisplayNativeHdrSurfaceCapabilitiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayNativeHdrSurfaceCapabilitiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("local_dimming_support", &self.local_dimming_support)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainDisplayNativeHdrCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub local_dimming_enable: Bool32,
}
unsafe impl Send for SwapchainDisplayNativeHdrCreateInfoAMD {}
unsafe impl Sync for SwapchainDisplayNativeHdrCreateInfoAMD {}
impl default::Default for SwapchainDisplayNativeHdrCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            p_next: ptr::null(),
            local_dimming_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for SwapchainDisplayNativeHdrCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainDisplayNativeHdrCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("local_dimming_enable", &self.local_dimming_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct RefreshCycleDurationGOOGLE {
    /// Number of nanoseconds from the start of one refresh cycle to the next
    pub refresh_duration: u64,
}
impl default::Default for RefreshCycleDurationGOOGLE {
    fn default() -> Self {
        Self {
            refresh_duration: u64::default(),
        }
    }
}
impl fmt::Debug for RefreshCycleDurationGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RefreshCycleDurationGOOGLE")
            .field("refresh_duration", &self.refresh_duration)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PastPresentationTimingGOOGLE {
    /// Application-provided identifier, previously given to vkQueuePresentKHR
    pub present_id: u32,
    /// Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    pub desired_present_time: u64,
    /// Time the image was actually displayed
    pub actual_present_time: u64,
    /// Earliest time the image could have been displayed
    pub earliest_present_time: u64,
    /// How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
    pub present_margin: u64,
}
impl default::Default for PastPresentationTimingGOOGLE {
    fn default() -> Self {
        Self {
            present_id: u32::default(),
            desired_present_time: u64::default(),
            actual_present_time: u64::default(),
            earliest_present_time: u64::default(),
            present_margin: u64::default(),
        }
    }
}
impl fmt::Debug for PastPresentationTimingGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PastPresentationTimingGOOGLE")
            .field("present_id", &self.present_id)
            .field("desired_present_time", &self.desired_present_time)
            .field("actual_present_time", &self.actual_present_time)
            .field("earliest_present_time", &self.earliest_present_time)
            .field("present_margin", &self.present_margin)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentTimesInfoGOOGLE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// The earliest times to present images
    pub p_times: *const PresentTimeGOOGLE,
}
unsafe impl Send for PresentTimesInfoGOOGLE {}
unsafe impl Sync for PresentTimesInfoGOOGLE {}
impl default::Default for PresentTimesInfoGOOGLE {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_TIMES_INFO_GOOGLE,
            p_next: ptr::null(),
            swapchain_count: u32::default(),
            p_times: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentTimesInfoGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentTimesInfoGOOGLE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_times", &self.p_times)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PresentTimeGOOGLE {
    /// Application-provided identifier
    pub present_id: u32,
    /// Earliest time an image should be presented
    pub desired_present_time: u64,
}
impl default::Default for PresentTimeGOOGLE {
    fn default() -> Self {
        Self {
            present_id: u32::default(),
            desired_present_time: u64::default(),
        }
    }
}
impl fmt::Debug for PresentTimeGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentTimeGOOGLE")
            .field("present_id", &self.present_id)
            .field("desired_present_time", &self.desired_present_time)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
unsafe impl Send for IOSSurfaceCreateInfoMVK {}
unsafe impl Sync for IOSSurfaceCreateInfoMVK {}
impl default::Default for IOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        Self {
            s_type: StructureType::IOS_SURFACE_CREATE_INFO_MVK,
            p_next: ptr::null(),
            flags: IOSSurfaceCreateFlagsMVK::default(),
            p_view: ptr::null(),
        }
    }
}
impl fmt::Debug for IOSSurfaceCreateInfoMVK {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IOSSurfaceCreateInfoMVK")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_view", &self.p_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MacOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MacOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
unsafe impl Send for MacOSSurfaceCreateInfoMVK {}
unsafe impl Sync for MacOSSurfaceCreateInfoMVK {}
impl default::Default for MacOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        Self {
            s_type: StructureType::MACOS_SURFACE_CREATE_INFO_MVK,
            p_next: ptr::null(),
            flags: MacOSSurfaceCreateFlagsMVK::default(),
            p_view: ptr::null(),
        }
    }
}
impl fmt::Debug for MacOSSurfaceCreateInfoMVK {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MacOSSurfaceCreateInfoMVK")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_view", &self.p_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MetalSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MetalSurfaceCreateFlagsEXT,
    pub p_layer: *const CAMetalLayer,
}
unsafe impl Send for MetalSurfaceCreateInfoEXT {}
unsafe impl Sync for MetalSurfaceCreateInfoEXT {}
impl default::Default for MetalSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::METAL_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: MetalSurfaceCreateFlagsEXT::default(),
            p_layer: ptr::null(),
        }
    }
}
impl fmt::Debug for MetalSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MetalSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_layer", &self.p_layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
impl default::Default for ViewportWScalingNV {
    fn default() -> Self {
        Self {
            xcoeff: f32::default(),
            ycoeff: f32::default(),
        }
    }
}
impl fmt::Debug for ViewportWScalingNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViewportWScalingNV")
            .field("xcoeff", &self.xcoeff)
            .field("ycoeff", &self.ycoeff)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportWScalingStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_w_scaling_enable: Bool32,
    pub viewport_count: u32,
    pub p_viewport_w_scalings: *const ViewportWScalingNV,
}
unsafe impl Send for PipelineViewportWScalingStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportWScalingStateCreateInfoNV {}
impl default::Default for PipelineViewportWScalingStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            viewport_w_scaling_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_viewport_w_scalings: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportWScalingStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportWScalingStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("viewport_w_scaling_enable", &self.viewport_w_scaling_enable)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewport_w_scalings", &self.p_viewport_w_scalings)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ViewportSwizzleNV {
    pub x: ViewportCoordinateSwizzleNV,
    pub y: ViewportCoordinateSwizzleNV,
    pub z: ViewportCoordinateSwizzleNV,
    pub w: ViewportCoordinateSwizzleNV,
}
impl default::Default for ViewportSwizzleNV {
    fn default() -> Self {
        Self {
            x: ViewportCoordinateSwizzleNV::default(),
            y: ViewportCoordinateSwizzleNV::default(),
            z: ViewportCoordinateSwizzleNV::default(),
            w: ViewportCoordinateSwizzleNV::default(),
        }
    }
}
impl fmt::Debug for ViewportSwizzleNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViewportSwizzleNV")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .field("w", &self.w)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportSwizzleStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportSwizzleStateCreateFlagsNV,
    pub viewport_count: u32,
    pub p_viewport_swizzles: *const ViewportSwizzleNV,
}
unsafe impl Send for PipelineViewportSwizzleStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportSwizzleStateCreateInfoNV {}
impl default::Default for PipelineViewportSwizzleStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: PipelineViewportSwizzleStateCreateFlagsNV::default(),
            viewport_count: u32::default(),
            p_viewport_swizzles: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportSwizzleStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportSwizzleStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewport_swizzles", &self.p_viewport_swizzles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max number of active discard rectangles
    pub max_discard_rectangles: u32,
}
unsafe impl Send for PhysicalDeviceDiscardRectanglePropertiesEXT {}
unsafe impl Sync for PhysicalDeviceDiscardRectanglePropertiesEXT {}
impl default::Default for PhysicalDeviceDiscardRectanglePropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_discard_rectangles: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDiscardRectanglePropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDiscardRectanglePropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_discard_rectangles", &self.max_discard_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDiscardRectangleStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDiscardRectangleStateCreateFlagsEXT,
    pub discard_rectangle_mode: DiscardRectangleModeEXT,
    pub discard_rectangle_count: u32,
    pub p_discard_rectangles: *const Rect2D,
}
unsafe impl Send for PipelineDiscardRectangleStateCreateInfoEXT {}
unsafe impl Sync for PipelineDiscardRectangleStateCreateInfoEXT {}
impl default::Default for PipelineDiscardRectangleStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: PipelineDiscardRectangleStateCreateFlagsEXT::default(),
            discard_rectangle_mode: DiscardRectangleModeEXT::default(),
            discard_rectangle_count: u32::default(),
            p_discard_rectangles: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineDiscardRectangleStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDiscardRectangleStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("discard_rectangle_mode", &self.discard_rectangle_mode)
            .field("discard_rectangle_count", &self.discard_rectangle_count)
            .field("p_discard_rectangles", &self.p_discard_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub per_view_position_all_components: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {}
unsafe impl Sync for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {}
impl default::Default for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            p_next: ptr::null_mut(),
            per_view_position_all_components: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "per_view_position_all_components",
                &self.per_view_position_all_components,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct InputAttachmentAspectReference {
    pub subpass: u32,
    pub input_attachment_index: u32,
    pub aspect_mask: ImageAspectFlags,
}
impl default::Default for InputAttachmentAspectReference {
    fn default() -> Self {
        Self {
            subpass: u32::default(),
            input_attachment_index: u32::default(),
            aspect_mask: ImageAspectFlags::default(),
        }
    }
}
impl fmt::Debug for InputAttachmentAspectReference {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InputAttachmentAspectReference")
            .field("subpass", &self.subpass)
            .field("input_attachment_index", &self.input_attachment_index)
            .field("aspect_mask", &self.aspect_mask)
            .finish()
    }
}
pub type InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassInputAttachmentAspectCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aspect_reference_count: u32,
    pub p_aspect_references: *const InputAttachmentAspectReference,
}
unsafe impl Send for RenderPassInputAttachmentAspectCreateInfo {}
unsafe impl Sync for RenderPassInputAttachmentAspectCreateInfo {}
impl default::Default for RenderPassInputAttachmentAspectCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            p_next: ptr::null(),
            aspect_reference_count: u32::default(),
            p_aspect_references: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassInputAttachmentAspectCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassInputAttachmentAspectCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("aspect_reference_count", &self.aspect_reference_count)
            .field("p_aspect_references", &self.p_aspect_references)
            .finish()
    }
}
pub type RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSurfaceInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface: Option<SurfaceKHR>,
}
unsafe impl Send for PhysicalDeviceSurfaceInfo2KHR {}
unsafe impl Sync for PhysicalDeviceSurfaceInfo2KHR {}
impl default::Default for PhysicalDeviceSurfaceInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            p_next: ptr::null(),
            surface: None,
        }
    }
}
impl fmt::Debug for PhysicalDeviceSurfaceInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSurfaceInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_capabilities: SurfaceCapabilitiesKHR,
}
unsafe impl Send for SurfaceCapabilities2KHR {}
unsafe impl Sync for SurfaceCapabilities2KHR {}
impl default::Default for SurfaceCapabilities2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_2_KHR,
            p_next: ptr::null_mut(),
            surface_capabilities: SurfaceCapabilitiesKHR::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilities2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilities2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_capabilities", &self.surface_capabilities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFormat2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_format: SurfaceFormatKHR,
}
unsafe impl Send for SurfaceFormat2KHR {}
unsafe impl Sync for SurfaceFormat2KHR {}
impl default::Default for SurfaceFormat2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FORMAT_2_KHR,
            p_next: ptr::null_mut(),
            surface_format: SurfaceFormatKHR::default(),
        }
    }
}
impl fmt::Debug for SurfaceFormat2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFormat2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_format", &self.surface_format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_properties: DisplayPropertiesKHR,
}
unsafe impl Send for DisplayProperties2KHR {}
unsafe impl Sync for DisplayProperties2KHR {}
impl default::Default for DisplayProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_properties: DisplayPropertiesKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_properties", &self.display_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_plane_properties: DisplayPlanePropertiesKHR,
}
unsafe impl Send for DisplayPlaneProperties2KHR {}
unsafe impl Sync for DisplayPlaneProperties2KHR {}
impl default::Default for DisplayPlaneProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_plane_properties: DisplayPlanePropertiesKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_plane_properties", &self.display_plane_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayModeProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_mode_properties: DisplayModePropertiesKHR,
}
unsafe impl Send for DisplayModeProperties2KHR {}
unsafe impl Sync for DisplayModeProperties2KHR {}
impl default::Default for DisplayModeProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_MODE_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_mode_properties: DisplayModePropertiesKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayModeProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_mode_properties", &self.display_mode_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mode: Option<DisplayModeKHR>,
    pub plane_index: u32,
}
unsafe impl Send for DisplayPlaneInfo2KHR {}
unsafe impl Sync for DisplayPlaneInfo2KHR {}
impl default::Default for DisplayPlaneInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_INFO_2_KHR,
            p_next: ptr::null(),
            mode: None,
            plane_index: u32::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mode", &self.mode)
            .field("plane_index", &self.plane_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub capabilities: DisplayPlaneCapabilitiesKHR,
}
unsafe impl Send for DisplayPlaneCapabilities2KHR {}
unsafe impl Sync for DisplayPlaneCapabilities2KHR {}
impl default::Default for DisplayPlaneCapabilities2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR,
            p_next: ptr::null_mut(),
            capabilities: DisplayPlaneCapabilitiesKHR::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneCapabilities2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneCapabilities2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("capabilities", &self.capabilities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SharedPresentSurfaceCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Supported image usage flags if swapchain created using a shared present mode
    pub shared_present_supported_usage_flags: ImageUsageFlags,
}
unsafe impl Send for SharedPresentSurfaceCapabilitiesKHR {}
unsafe impl Sync for SharedPresentSurfaceCapabilitiesKHR {}
impl default::Default for SharedPresentSurfaceCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            p_next: ptr::null_mut(),
            shared_present_supported_usage_flags: ImageUsageFlags::default(),
        }
    }
}
impl fmt::Debug for SharedPresentSurfaceCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SharedPresentSurfaceCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shared_present_supported_usage_flags",
                &self.shared_present_supported_usage_flags,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice16BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit integer/floating-point variables supported in BufferBlock
    pub storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in BufferBlock and Block
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in PushConstant
    pub storage_push_constant16: Bool32,
    /// 16-bit integer/floating-point variables supported in shader inputs and outputs
    pub storage_input_output16: Bool32,
}
unsafe impl Send for PhysicalDevice16BitStorageFeatures {}
unsafe impl Sync for PhysicalDevice16BitStorageFeatures {}
impl default::Default for PhysicalDevice16BitStorageFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice16BitStorageFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice16BitStorageFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer16_bit_access", &self.storage_buffer16_bit_access)
            .field(
                "uniform_and_storage_buffer16_bit_access",
                &self.uniform_and_storage_buffer16_bit_access,
            )
            .field("storage_push_constant16", &self.storage_push_constant16)
            .field("storage_input_output16", &self.storage_input_output16)
            .finish()
    }
}
pub type PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The size of a subgroup for this queue.
    pub subgroup_size: u32,
    /// Bitfield of what shader stages support subgroup operations
    pub supported_stages: ShaderStageFlags,
    /// Bitfield of what subgroup operations are supported.
    pub supported_operations: SubgroupFeatureFlags,
    /// Flag to specify whether quad operations are available in all stages.
    pub quad_operations_in_all_stages: Bool32,
}
unsafe impl Send for PhysicalDeviceSubgroupProperties {}
unsafe impl Sync for PhysicalDeviceSubgroupProperties {}
impl default::Default for PhysicalDeviceSubgroupProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            p_next: ptr::null_mut(),
            subgroup_size: u32::default(),
            supported_stages: ShaderStageFlags::default(),
            supported_operations: SubgroupFeatureFlags::default(),
            quad_operations_in_all_stages: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subgroup_size", &self.subgroup_size)
            .field("supported_stages", &self.supported_stages)
            .field("supported_operations", &self.supported_operations)
            .field("quad_operations_in_all_stages", &self.quad_operations_in_all_stages)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Flag to specify whether subgroup operations with extended types are supported
    pub shader_subgroup_extended_types: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
unsafe impl Sync for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
impl default::Default for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            p_next: ptr::null_mut(),
            shader_subgroup_extended_types: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSubgroupExtendedTypesFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_subgroup_extended_types", &self.shader_subgroup_extended_types)
            .finish()
    }
}
pub type PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
}
unsafe impl Send for BufferMemoryRequirementsInfo2 {}
unsafe impl Sync for BufferMemoryRequirementsInfo2 {}
impl default::Default for BufferMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            buffer: None,
        }
    }
}
impl fmt::Debug for BufferMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceBufferMemoryRequirementsKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const BufferCreateInfo,
}
unsafe impl Send for DeviceBufferMemoryRequirementsKHR {}
unsafe impl Sync for DeviceBufferMemoryRequirementsKHR {}
impl default::Default for DeviceBufferMemoryRequirementsKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR,
            p_next: ptr::null(),
            p_create_info: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceBufferMemoryRequirementsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceBufferMemoryRequirementsKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
}
unsafe impl Send for ImageMemoryRequirementsInfo2 {}
unsafe impl Sync for ImageMemoryRequirementsInfo2 {}
impl default::Default for ImageMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            image: None,
        }
    }
}
impl fmt::Debug for ImageMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .finish()
    }
}
pub type ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageSparseMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
}
unsafe impl Send for ImageSparseMemoryRequirementsInfo2 {}
unsafe impl Sync for ImageSparseMemoryRequirementsInfo2 {}
impl default::Default for ImageSparseMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            image: None,
        }
    }
}
impl fmt::Debug for ImageSparseMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSparseMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .finish()
    }
}
pub type ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceImageMemoryRequirementsKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const ImageCreateInfo,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for DeviceImageMemoryRequirementsKHR {}
unsafe impl Sync for DeviceImageMemoryRequirementsKHR {}
impl default::Default for DeviceImageMemoryRequirementsKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR,
            p_next: ptr::null(),
            p_create_info: ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
impl fmt::Debug for DeviceImageMemoryRequirementsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceImageMemoryRequirementsKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: MemoryRequirements,
}
unsafe impl Send for MemoryRequirements2 {}
unsafe impl Sync for MemoryRequirements2 {}
impl default::Default for MemoryRequirements2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_REQUIREMENTS_2,
            p_next: ptr::null_mut(),
            memory_requirements: MemoryRequirements::default(),
        }
    }
}
impl fmt::Debug for MemoryRequirements2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryRequirements2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_requirements", &self.memory_requirements)
            .finish()
    }
}
pub type MemoryRequirements2KHR = MemoryRequirements2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageMemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: SparseImageMemoryRequirements,
}
unsafe impl Send for SparseImageMemoryRequirements2 {}
unsafe impl Sync for SparseImageMemoryRequirements2 {}
impl default::Default for SparseImageMemoryRequirements2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
            p_next: ptr::null_mut(),
            memory_requirements: SparseImageMemoryRequirements::default(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryRequirements2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryRequirements2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_requirements", &self.memory_requirements)
            .finish()
    }
}
pub type SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePointClippingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub point_clipping_behavior: PointClippingBehavior,
}
unsafe impl Send for PhysicalDevicePointClippingProperties {}
unsafe impl Sync for PhysicalDevicePointClippingProperties {}
impl default::Default for PhysicalDevicePointClippingProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            p_next: ptr::null_mut(),
            point_clipping_behavior: PointClippingBehavior::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePointClippingProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePointClippingProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("point_clipping_behavior", &self.point_clipping_behavior)
            .finish()
    }
}
pub type PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDedicatedRequirements {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub prefers_dedicated_allocation: Bool32,
    pub requires_dedicated_allocation: Bool32,
}
unsafe impl Send for MemoryDedicatedRequirements {}
unsafe impl Sync for MemoryDedicatedRequirements {}
impl default::Default for MemoryDedicatedRequirements {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_DEDICATED_REQUIREMENTS,
            p_next: ptr::null_mut(),
            prefers_dedicated_allocation: Bool32::default(),
            requires_dedicated_allocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for MemoryDedicatedRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryDedicatedRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("prefers_dedicated_allocation", &self.prefers_dedicated_allocation)
            .field("requires_dedicated_allocation", &self.requires_dedicated_allocation)
            .finish()
    }
}
pub type MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDedicatedAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image that this allocation will be bound to
    pub image: Option<Image>,
    /// Buffer that this allocation will be bound to
    pub buffer: Option<Buffer>,
}
unsafe impl Send for MemoryDedicatedAllocateInfo {}
unsafe impl Sync for MemoryDedicatedAllocateInfo {}
impl default::Default for MemoryDedicatedAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_DEDICATED_ALLOCATE_INFO,
            p_next: ptr::null(),
            image: None,
            buffer: None,
        }
    }
}
impl fmt::Debug for MemoryDedicatedAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryDedicatedAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: ImageUsageFlags,
}
unsafe impl Send for ImageViewUsageCreateInfo {}
unsafe impl Sync for ImageViewUsageCreateInfo {}
impl default::Default for ImageViewUsageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_USAGE_CREATE_INFO,
            p_next: ptr::null(),
            usage: ImageUsageFlags::default(),
        }
    }
}
impl fmt::Debug for ImageViewUsageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewUsageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("usage", &self.usage)
            .finish()
    }
}
pub type ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineTessellationDomainOriginStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub domain_origin: TessellationDomainOrigin,
}
unsafe impl Send for PipelineTessellationDomainOriginStateCreateInfo {}
unsafe impl Sync for PipelineTessellationDomainOriginStateCreateInfo {}
impl default::Default for PipelineTessellationDomainOriginStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            p_next: ptr::null(),
            domain_origin: TessellationDomainOrigin::default(),
        }
    }
}
impl fmt::Debug for PipelineTessellationDomainOriginStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineTessellationDomainOriginStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("domain_origin", &self.domain_origin)
            .finish()
    }
}
pub type PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conversion: Option<SamplerYcbcrConversion>,
}
unsafe impl Send for SamplerYcbcrConversionInfo {}
unsafe impl Sync for SamplerYcbcrConversionInfo {}
impl default::Default for SamplerYcbcrConversionInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_INFO,
            p_next: ptr::null(),
            conversion: None,
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conversion", &self.conversion)
            .finish()
    }
}
pub type SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ycbcr_model: SamplerYcbcrModelConversion,
    pub ycbcr_range: SamplerYcbcrRange,
    pub components: ComponentMapping,
    pub x_chroma_offset: ChromaLocation,
    pub y_chroma_offset: ChromaLocation,
    pub chroma_filter: Filter,
    pub force_explicit_reconstruction: Bool32,
}
unsafe impl Send for SamplerYcbcrConversionCreateInfo {}
unsafe impl Sync for SamplerYcbcrConversionCreateInfo {}
impl default::Default for SamplerYcbcrConversionCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            p_next: ptr::null(),
            format: Format::default(),
            ycbcr_model: SamplerYcbcrModelConversion::default(),
            ycbcr_range: SamplerYcbcrRange::default(),
            components: ComponentMapping::default(),
            x_chroma_offset: ChromaLocation::default(),
            y_chroma_offset: ChromaLocation::default(),
            chroma_filter: Filter::default(),
            force_explicit_reconstruction: Bool32::default(),
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ycbcr_model", &self.ycbcr_model)
            .field("ycbcr_range", &self.ycbcr_range)
            .field("components", &self.components)
            .field("x_chroma_offset", &self.x_chroma_offset)
            .field("y_chroma_offset", &self.y_chroma_offset)
            .field("chroma_filter", &self.chroma_filter)
            .field("force_explicit_reconstruction", &self.force_explicit_reconstruction)
            .finish()
    }
}
pub type SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImagePlaneMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for BindImagePlaneMemoryInfo {}
unsafe impl Sync for BindImagePlaneMemoryInfo {}
impl default::Default for BindImagePlaneMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_PLANE_MEMORY_INFO,
            p_next: ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
impl fmt::Debug for BindImagePlaneMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImagePlaneMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
pub type BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImagePlaneMemoryRequirementsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for ImagePlaneMemoryRequirementsInfo {}
unsafe impl Sync for ImagePlaneMemoryRequirementsInfo {}
impl default::Default for ImagePlaneMemoryRequirementsInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            p_next: ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
impl fmt::Debug for ImagePlaneMemoryRequirementsInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImagePlaneMemoryRequirementsInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
pub type ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Sampler color conversion supported
    pub sampler_ycbcr_conversion: Bool32,
}
unsafe impl Send for PhysicalDeviceSamplerYcbcrConversionFeatures {}
unsafe impl Sync for PhysicalDeviceSamplerYcbcrConversionFeatures {}
impl default::Default for PhysicalDeviceSamplerYcbcrConversionFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            p_next: ptr::null_mut(),
            sampler_ycbcr_conversion: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSamplerYcbcrConversionFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSamplerYcbcrConversionFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sampler_ycbcr_conversion", &self.sampler_ycbcr_conversion)
            .finish()
    }
}
pub type PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_descriptor_count: u32,
}
unsafe impl Send for SamplerYcbcrConversionImageFormatProperties {}
unsafe impl Sync for SamplerYcbcrConversionImageFormatProperties {}
impl default::Default for SamplerYcbcrConversionImageFormatProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            p_next: ptr::null_mut(),
            combined_image_sampler_descriptor_count: u32::default(),
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionImageFormatProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "combined_image_sampler_descriptor_count",
                &self.combined_image_sampler_descriptor_count,
            )
            .finish()
    }
}
pub type SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TextureLODGatherFormatPropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supports_texture_gather_lod_bias_amd: Bool32,
}
unsafe impl Send for TextureLODGatherFormatPropertiesAMD {}
unsafe impl Sync for TextureLODGatherFormatPropertiesAMD {}
impl default::Default for TextureLODGatherFormatPropertiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
            p_next: ptr::null_mut(),
            supports_texture_gather_lod_bias_amd: Bool32::default(),
        }
    }
}
impl fmt::Debug for TextureLODGatherFormatPropertiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TextureLODGatherFormatPropertiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "supports_texture_gather_lod_bias_amd",
                &self.supports_texture_gather_lod_bias_amd,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConditionalRenderingBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub flags: ConditionalRenderingFlagsEXT,
}
unsafe impl Send for ConditionalRenderingBeginInfoEXT {}
unsafe impl Sync for ConditionalRenderingBeginInfoEXT {}
impl default::Default for ConditionalRenderingBeginInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
            p_next: ptr::null(),
            buffer: None,
            offset: DeviceSize::default(),
            flags: ConditionalRenderingFlagsEXT::default(),
        }
    }
}
impl fmt::Debug for ConditionalRenderingBeginInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ConditionalRenderingBeginInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ProtectedSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Submit protected command buffers
    pub protected_submit: Bool32,
}
unsafe impl Send for ProtectedSubmitInfo {}
unsafe impl Sync for ProtectedSubmitInfo {}
impl default::Default for ProtectedSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PROTECTED_SUBMIT_INFO,
            p_next: ptr::null(),
            protected_submit: Bool32::default(),
        }
    }
}
impl fmt::Debug for ProtectedSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ProtectedSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_submit", &self.protected_submit)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceProtectedMemoryFeatures {}
unsafe impl Sync for PhysicalDeviceProtectedMemoryFeatures {}
impl default::Default for PhysicalDeviceProtectedMemoryFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            p_next: ptr::null_mut(),
            protected_memory: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProtectedMemoryFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProtectedMemoryFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_memory", &self.protected_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_no_fault: Bool32,
}
unsafe impl Send for PhysicalDeviceProtectedMemoryProperties {}
unsafe impl Sync for PhysicalDeviceProtectedMemoryProperties {}
impl default::Default for PhysicalDeviceProtectedMemoryProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            p_next: ptr::null_mut(),
            protected_no_fault: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProtectedMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProtectedMemoryProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_no_fault", &self.protected_no_fault)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_index: u32,
}
unsafe impl Send for DeviceQueueInfo2 {}
unsafe impl Sync for DeviceQueueInfo2 {}
impl default::Default for DeviceQueueInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_INFO_2,
            p_next: ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_index: u32::default(),
        }
    }
}
impl fmt::Debug for DeviceQueueInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .field("queue_index", &self.queue_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageToColorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageToColorStateCreateFlagsNV,
    pub coverage_to_color_enable: Bool32,
    pub coverage_to_color_location: u32,
}
unsafe impl Send for PipelineCoverageToColorStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageToColorStateCreateInfoNV {}
impl default::Default for PipelineCoverageToColorStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: PipelineCoverageToColorStateCreateFlagsNV::default(),
            coverage_to_color_enable: Bool32::default(),
            coverage_to_color_location: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineCoverageToColorStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageToColorStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_to_color_enable", &self.coverage_to_color_enable)
            .field("coverage_to_color_location", &self.coverage_to_color_location)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSamplerFilterMinmaxProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
}
unsafe impl Send for PhysicalDeviceSamplerFilterMinmaxProperties {}
unsafe impl Sync for PhysicalDeviceSamplerFilterMinmaxProperties {}
impl default::Default for PhysicalDeviceSamplerFilterMinmaxProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            p_next: ptr::null_mut(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSamplerFilterMinmaxProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSamplerFilterMinmaxProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .finish()
    }
}
pub type PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
impl default::Default for SampleLocationEXT {
    fn default() -> Self {
        Self {
            x: f32::default(),
            y: f32::default(),
        }
    }
}
impl fmt::Debug for SampleLocationEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SampleLocationEXT")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SampleLocationsInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_per_pixel: SampleCountFlags,
    pub sample_location_grid_size: Extent2D,
    pub sample_locations_count: u32,
    pub p_sample_locations: *const SampleLocationEXT,
}
unsafe impl Send for SampleLocationsInfoEXT {}
unsafe impl Sync for SampleLocationsInfoEXT {}
impl default::Default for SampleLocationsInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLE_LOCATIONS_INFO_EXT,
            p_next: ptr::null(),
            sample_locations_per_pixel: SampleCountFlags::default(),
            sample_location_grid_size: Extent2D::default(),
            sample_locations_count: u32::default(),
            p_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for SampleLocationsInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SampleLocationsInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_locations_per_pixel", &self.sample_locations_per_pixel)
            .field("sample_location_grid_size", &self.sample_location_grid_size)
            .field("sample_locations_count", &self.sample_locations_count)
            .field("p_sample_locations", &self.p_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentSampleLocationsEXT {
    pub attachment_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl default::Default for AttachmentSampleLocationsEXT {
    fn default() -> Self {
        Self {
            attachment_index: u32::default(),
            sample_locations_info: SampleLocationsInfoEXT::default(),
        }
    }
}
impl fmt::Debug for AttachmentSampleLocationsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentSampleLocationsEXT")
            .field("attachment_index", &self.attachment_index)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassSampleLocationsEXT {
    pub subpass_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl default::Default for SubpassSampleLocationsEXT {
    fn default() -> Self {
        Self {
            subpass_index: u32::default(),
            sample_locations_info: SampleLocationsInfoEXT::default(),
        }
    }
}
impl fmt::Debug for SubpassSampleLocationsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassSampleLocationsEXT")
            .field("subpass_index", &self.subpass_index)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassSampleLocationsBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_initial_sample_locations_count: u32,
    pub p_attachment_initial_sample_locations: *const AttachmentSampleLocationsEXT,
    pub post_subpass_sample_locations_count: u32,
    pub p_post_subpass_sample_locations: *const SubpassSampleLocationsEXT,
}
unsafe impl Send for RenderPassSampleLocationsBeginInfoEXT {}
unsafe impl Sync for RenderPassSampleLocationsBeginInfoEXT {}
impl default::Default for RenderPassSampleLocationsBeginInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            p_next: ptr::null(),
            attachment_initial_sample_locations_count: u32::default(),
            p_attachment_initial_sample_locations: ptr::null(),
            post_subpass_sample_locations_count: u32::default(),
            p_post_subpass_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassSampleLocationsBeginInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSampleLocationsBeginInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "attachment_initial_sample_locations_count",
                &self.attachment_initial_sample_locations_count,
            )
            .field(
                "p_attachment_initial_sample_locations",
                &self.p_attachment_initial_sample_locations,
            )
            .field(
                "post_subpass_sample_locations_count",
                &self.post_subpass_sample_locations_count,
            )
            .field("p_post_subpass_sample_locations", &self.p_post_subpass_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineSampleLocationsStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_enable: Bool32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
unsafe impl Send for PipelineSampleLocationsStateCreateInfoEXT {}
unsafe impl Sync for PipelineSampleLocationsStateCreateInfoEXT {}
impl default::Default for PipelineSampleLocationsStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            sample_locations_enable: Bool32::default(),
            sample_locations_info: SampleLocationsInfoEXT::default(),
        }
    }
}
impl fmt::Debug for PipelineSampleLocationsStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineSampleLocationsStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_locations_enable", &self.sample_locations_enable)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_location_sample_counts: SampleCountFlags,
    pub max_sample_location_grid_size: Extent2D,
    pub sample_location_coordinate_range: [f32; 2],
    pub sample_location_sub_pixel_bits: u32,
    pub variable_sample_locations: Bool32,
}
unsafe impl Send for PhysicalDeviceSampleLocationsPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceSampleLocationsPropertiesEXT {}
impl default::Default for PhysicalDeviceSampleLocationsPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            sample_location_sample_counts: SampleCountFlags::default(),
            max_sample_location_grid_size: Extent2D::default(),
            sample_location_coordinate_range: [f32::default(); 2],
            sample_location_sub_pixel_bits: u32::default(),
            variable_sample_locations: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSampleLocationsPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSampleLocationsPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_location_sample_counts", &self.sample_location_sample_counts)
            .field("max_sample_location_grid_size", &self.max_sample_location_grid_size)
            .field(
                "sample_location_coordinate_range",
                &self.sample_location_coordinate_range,
            )
            .field("sample_location_sub_pixel_bits", &self.sample_location_sub_pixel_bits)
            .field("variable_sample_locations", &self.variable_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MultisamplePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_sample_location_grid_size: Extent2D,
}
unsafe impl Send for MultisamplePropertiesEXT {}
unsafe impl Sync for MultisamplePropertiesEXT {}
impl default::Default for MultisamplePropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MULTISAMPLE_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_sample_location_grid_size: Extent2D::default(),
        }
    }
}
impl fmt::Debug for MultisamplePropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultisamplePropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_sample_location_grid_size", &self.max_sample_location_grid_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerReductionModeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reduction_mode: SamplerReductionMode,
}
unsafe impl Send for SamplerReductionModeCreateInfo {}
unsafe impl Sync for SamplerReductionModeCreateInfo {}
impl default::Default for SamplerReductionModeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO,
            p_next: ptr::null(),
            reduction_mode: SamplerReductionMode::default(),
        }
    }
}
impl fmt::Debug for SamplerReductionModeCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerReductionModeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("reduction_mode", &self.reduction_mode)
            .finish()
    }
}
pub type SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_coherent_operations: Bool32,
}
unsafe impl Send for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
impl default::Default for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            p_next: ptr::null_mut(),
            advanced_blend_coherent_operations: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBlendOperationAdvancedFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "advanced_blend_coherent_operations",
                &self.advanced_blend_coherent_operations,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiDrawFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multi_draw: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiDrawFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceMultiDrawFeaturesEXT {}
impl default::Default for PhysicalDeviceMultiDrawFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            p_next: ptr::null_mut(),
            multi_draw: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiDrawFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiDrawFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("multi_draw", &self.multi_draw)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_max_color_attachments: u32,
    pub advanced_blend_independent_blend: Bool32,
    pub advanced_blend_non_premultiplied_src_color: Bool32,
    pub advanced_blend_non_premultiplied_dst_color: Bool32,
    pub advanced_blend_correlated_overlap: Bool32,
    pub advanced_blend_all_operations: Bool32,
}
unsafe impl Send for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}
impl default::Default for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            advanced_blend_max_color_attachments: u32::default(),
            advanced_blend_independent_blend: Bool32::default(),
            advanced_blend_non_premultiplied_src_color: Bool32::default(),
            advanced_blend_non_premultiplied_dst_color: Bool32::default(),
            advanced_blend_correlated_overlap: Bool32::default(),
            advanced_blend_all_operations: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBlendOperationAdvancedPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "advanced_blend_max_color_attachments",
                &self.advanced_blend_max_color_attachments,
            )
            .field(
                "advanced_blend_independent_blend",
                &self.advanced_blend_independent_blend,
            )
            .field(
                "advanced_blend_non_premultiplied_src_color",
                &self.advanced_blend_non_premultiplied_src_color,
            )
            .field(
                "advanced_blend_non_premultiplied_dst_color",
                &self.advanced_blend_non_premultiplied_dst_color,
            )
            .field(
                "advanced_blend_correlated_overlap",
                &self.advanced_blend_correlated_overlap,
            )
            .field("advanced_blend_all_operations", &self.advanced_blend_all_operations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
}
unsafe impl Send for PipelineColorBlendAdvancedStateCreateInfoEXT {}
unsafe impl Sync for PipelineColorBlendAdvancedStateCreateInfoEXT {}
impl default::Default for PipelineColorBlendAdvancedStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            src_premultiplied: Bool32::default(),
            dst_premultiplied: Bool32::default(),
            blend_overlap: BlendOverlapEXT::default(),
        }
    }
}
impl fmt::Debug for PipelineColorBlendAdvancedStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendAdvancedStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_premultiplied", &self.src_premultiplied)
            .field("dst_premultiplied", &self.dst_premultiplied)
            .field("blend_overlap", &self.blend_overlap)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
}
unsafe impl Send for PhysicalDeviceInlineUniformBlockFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceInlineUniformBlockFeaturesEXT {}
impl default::Default for PhysicalDeviceInlineUniformBlockFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            inline_uniform_block: Bool32::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInlineUniformBlockFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInlineUniformBlockFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("inline_uniform_block", &self.inline_uniform_block)
            .field(
                "descriptor_binding_inline_uniform_block_update_after_bind",
                &self.descriptor_binding_inline_uniform_block_update_after_bind,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
}
unsafe impl Send for PhysicalDeviceInlineUniformBlockPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceInlineUniformBlockPropertiesEXT {}
impl default::Default for PhysicalDeviceInlineUniformBlockPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_inline_uniform_block_size: u32::default(),
            max_per_stage_descriptor_inline_uniform_blocks: u32::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32::default(),
            max_descriptor_set_inline_uniform_blocks: u32::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInlineUniformBlockPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInlineUniformBlockPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_inline_uniform_block_size", &self.max_inline_uniform_block_size)
            .field(
                "max_per_stage_descriptor_inline_uniform_blocks",
                &self.max_per_stage_descriptor_inline_uniform_blocks,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks",
                &self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_inline_uniform_blocks",
                &self.max_descriptor_set_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_update_after_bind_inline_uniform_blocks",
                &self.max_descriptor_set_update_after_bind_inline_uniform_blocks,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetInlineUniformBlockEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: u32,
    pub p_data: *const c_void,
}
unsafe impl Send for WriteDescriptorSetInlineUniformBlockEXT {}
unsafe impl Sync for WriteDescriptorSetInlineUniformBlockEXT {}
impl default::Default for WriteDescriptorSetInlineUniformBlockEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
            p_next: ptr::null(),
            data_size: u32::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetInlineUniformBlockEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetInlineUniformBlockEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorPoolInlineUniformBlockCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_inline_uniform_block_bindings: u32,
}
unsafe impl Send for DescriptorPoolInlineUniformBlockCreateInfoEXT {}
unsafe impl Sync for DescriptorPoolInlineUniformBlockCreateInfoEXT {}
impl default::Default for DescriptorPoolInlineUniformBlockCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            max_inline_uniform_block_bindings: u32::default(),
        }
    }
}
impl fmt::Debug for DescriptorPoolInlineUniformBlockCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolInlineUniformBlockCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_inline_uniform_block_bindings",
                &self.max_inline_uniform_block_bindings,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageModulationStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageModulationStateCreateFlagsNV,
    pub coverage_modulation_mode: CoverageModulationModeNV,
    pub coverage_modulation_table_enable: Bool32,
    pub coverage_modulation_table_count: u32,
    pub p_coverage_modulation_table: *const f32,
}
unsafe impl Send for PipelineCoverageModulationStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageModulationStateCreateInfoNV {}
impl default::Default for PipelineCoverageModulationStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: PipelineCoverageModulationStateCreateFlagsNV::default(),
            coverage_modulation_mode: CoverageModulationModeNV::default(),
            coverage_modulation_table_enable: Bool32::default(),
            coverage_modulation_table_count: u32::default(),
            p_coverage_modulation_table: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineCoverageModulationStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageModulationStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_modulation_mode", &self.coverage_modulation_mode)
            .field(
                "coverage_modulation_table_enable",
                &self.coverage_modulation_table_enable,
            )
            .field("coverage_modulation_table_count", &self.coverage_modulation_table_count)
            .field("p_coverage_modulation_table", &self.p_coverage_modulation_table)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatListCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
unsafe impl Send for ImageFormatListCreateInfo {}
unsafe impl Sync for ImageFormatListCreateInfo {}
impl default::Default for ImageFormatListCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_LIST_CREATE_INFO,
            p_next: ptr::null(),
            view_format_count: u32::default(),
            p_view_formats: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageFormatListCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatListCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("view_format_count", &self.view_format_count)
            .field("p_view_formats", &self.p_view_formats)
            .finish()
    }
}
pub type ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ValidationCacheCreateFlagsEXT,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
}
unsafe impl Send for ValidationCacheCreateInfoEXT {}
unsafe impl Sync for ValidationCacheCreateInfoEXT {}
impl default::Default for ValidationCacheCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: ValidationCacheCreateFlagsEXT::default(),
            initial_data_size: usize::default(),
            p_initial_data: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationCacheCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationCacheCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("initial_data_size", &self.initial_data_size)
            .field("p_initial_data", &self.p_initial_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderModuleValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub validation_cache: Option<ValidationCacheEXT>,
}
unsafe impl Send for ShaderModuleValidationCacheCreateInfoEXT {}
unsafe impl Sync for ShaderModuleValidationCacheCreateInfoEXT {}
impl default::Default for ShaderModuleValidationCacheCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            validation_cache: None,
        }
    }
}
impl fmt::Debug for ShaderModuleValidationCacheCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderModuleValidationCacheCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("validation_cache", &self.validation_cache)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance3Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceMaintenance3Properties {}
unsafe impl Sync for PhysicalDeviceMaintenance3Properties {}
impl default::Default for PhysicalDeviceMaintenance3Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            p_next: ptr::null_mut(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance3Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance3Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_per_set_descriptors", &self.max_per_set_descriptors)
            .field("max_memory_allocation_size", &self.max_memory_allocation_size)
            .finish()
    }
}
pub type PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance4FeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub maintenance4: Bool32,
}
unsafe impl Send for PhysicalDeviceMaintenance4FeaturesKHR {}
unsafe impl Sync for PhysicalDeviceMaintenance4FeaturesKHR {}
impl default::Default for PhysicalDeviceMaintenance4FeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR,
            p_next: ptr::null_mut(),
            maintenance4: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance4FeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance4FeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("maintenance4", &self.maintenance4)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance4PropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_buffer_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceMaintenance4PropertiesKHR {}
unsafe impl Sync for PhysicalDeviceMaintenance4PropertiesKHR {}
impl default::Default for PhysicalDeviceMaintenance4PropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            max_buffer_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance4PropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance4PropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_buffer_size", &self.max_buffer_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported: Bool32,
}
unsafe impl Send for DescriptorSetLayoutSupport {}
unsafe impl Sync for DescriptorSetLayoutSupport {}
impl default::Default for DescriptorSetLayoutSupport {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT,
            p_next: ptr::null_mut(),
            supported: Bool32::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutSupport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutSupport")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supported", &self.supported)
            .finish()
    }
}
pub type DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderDrawParametersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_draw_parameters: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderDrawParametersFeatures {}
unsafe impl Sync for PhysicalDeviceShaderDrawParametersFeatures {}
impl default::Default for PhysicalDeviceShaderDrawParametersFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            p_next: ptr::null_mut(),
            shader_draw_parameters: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderDrawParametersFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderDrawParametersFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_draw_parameters", &self.shader_draw_parameters)
            .finish()
    }
}
pub type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderFloat16Int8Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit floats (halfs) in shaders
    pub shader_float16: Bool32,
    /// 8-bit integers in shaders
    pub shader_int8: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderFloat16Int8Features {}
unsafe impl Sync for PhysicalDeviceShaderFloat16Int8Features {}
impl default::Default for PhysicalDeviceShaderFloat16Int8Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            p_next: ptr::null_mut(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderFloat16Int8Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderFloat16Int8Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_float16", &self.shader_float16)
            .field("shader_int8", &self.shader_int8)
            .finish()
    }
}
pub type PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub type PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFloatControlsProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float16: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float32: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float64: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float16: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float32: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float64: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float16: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float32: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float64: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float16: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float32: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float64: Bool32,
}
unsafe impl Send for PhysicalDeviceFloatControlsProperties {}
unsafe impl Sync for PhysicalDeviceFloatControlsProperties {}
impl default::Default for PhysicalDeviceFloatControlsProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            p_next: ptr::null_mut(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFloatControlsProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFloatControlsProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("denorm_behavior_independence", &self.denorm_behavior_independence)
            .field("rounding_mode_independence", &self.rounding_mode_independence)
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field("shader_denorm_preserve_float16", &self.shader_denorm_preserve_float16)
            .field("shader_denorm_preserve_float32", &self.shader_denorm_preserve_float32)
            .field("shader_denorm_preserve_float64", &self.shader_denorm_preserve_float64)
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .finish()
    }
}
pub type PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceHostQueryResetFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub host_query_reset: Bool32,
}
unsafe impl Send for PhysicalDeviceHostQueryResetFeatures {}
unsafe impl Sync for PhysicalDeviceHostQueryResetFeatures {}
impl default::Default for PhysicalDeviceHostQueryResetFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            p_next: ptr::null_mut(),
            host_query_reset: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceHostQueryResetFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceHostQueryResetFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("host_query_reset", &self.host_query_reset)
            .finish()
    }
}
pub type PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderResourceUsageAMD {
    pub num_used_vgprs: u32,
    pub num_used_sgprs: u32,
    pub lds_size_per_local_work_group: u32,
    pub lds_usage_size_in_bytes: usize,
    pub scratch_mem_usage_in_bytes: usize,
}
impl default::Default for ShaderResourceUsageAMD {
    fn default() -> Self {
        Self {
            num_used_vgprs: u32::default(),
            num_used_sgprs: u32::default(),
            lds_size_per_local_work_group: u32::default(),
            lds_usage_size_in_bytes: usize::default(),
            scratch_mem_usage_in_bytes: usize::default(),
        }
    }
}
impl fmt::Debug for ShaderResourceUsageAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderResourceUsageAMD")
            .field("num_used_vgprs", &self.num_used_vgprs)
            .field("num_used_sgprs", &self.num_used_sgprs)
            .field("lds_size_per_local_work_group", &self.lds_size_per_local_work_group)
            .field("lds_usage_size_in_bytes", &self.lds_usage_size_in_bytes)
            .field("scratch_mem_usage_in_bytes", &self.scratch_mem_usage_in_bytes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderStatisticsInfoAMD {
    pub shader_stage_mask: ShaderStageFlags,
    pub resource_usage: ShaderResourceUsageAMD,
    pub num_physical_vgprs: u32,
    pub num_physical_sgprs: u32,
    pub num_available_vgprs: u32,
    pub num_available_sgprs: u32,
    pub compute_work_group_size: [u32; 3],
}
impl default::Default for ShaderStatisticsInfoAMD {
    fn default() -> Self {
        Self {
            shader_stage_mask: ShaderStageFlags::default(),
            resource_usage: ShaderResourceUsageAMD::default(),
            num_physical_vgprs: u32::default(),
            num_physical_sgprs: u32::default(),
            num_available_vgprs: u32::default(),
            num_available_sgprs: u32::default(),
            compute_work_group_size: [u32::default(); 3],
        }
    }
}
impl fmt::Debug for ShaderStatisticsInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderStatisticsInfoAMD")
            .field("shader_stage_mask", &self.shader_stage_mask)
            .field("resource_usage", &self.resource_usage)
            .field("num_physical_vgprs", &self.num_physical_vgprs)
            .field("num_physical_sgprs", &self.num_physical_sgprs)
            .field("num_available_vgprs", &self.num_available_vgprs)
            .field("num_available_sgprs", &self.num_available_sgprs)
            .field("compute_work_group_size", &self.compute_work_group_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueGlobalPriorityCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub global_priority: QueueGlobalPriorityEXT,
}
unsafe impl Send for DeviceQueueGlobalPriorityCreateInfoEXT {}
unsafe impl Sync for DeviceQueueGlobalPriorityCreateInfoEXT {}
impl default::Default for DeviceQueueGlobalPriorityCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
            p_next: ptr::null(),
            global_priority: QueueGlobalPriorityEXT::default(),
        }
    }
}
impl fmt::Debug for DeviceQueueGlobalPriorityCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueGlobalPriorityCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("global_priority", &self.global_priority)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub global_priority_query: Bool32,
}
unsafe impl Send for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {}
impl default::Default for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            global_priority_query: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGlobalPriorityQueryFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("global_priority_query", &self.global_priority_query)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyGlobalPriorityPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub priority_count: u32,
    pub priorities: [QueueGlobalPriorityEXT; MAX_GLOBAL_PRIORITY_SIZE_EXT],
}
unsafe impl Send for QueueFamilyGlobalPriorityPropertiesEXT {}
unsafe impl Sync for QueueFamilyGlobalPriorityPropertiesEXT {}
impl default::Default for QueueFamilyGlobalPriorityPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            priority_count: u32::default(),
            priorities: [QueueGlobalPriorityEXT::default(); MAX_GLOBAL_PRIORITY_SIZE_EXT],
        }
    }
}
impl fmt::Debug for QueueFamilyGlobalPriorityPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyGlobalPriorityPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("priority_count", &self.priority_count)
            .field("priorities", &self.priorities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub p_object_name: *const c_char,
}
unsafe impl Send for DebugUtilsObjectNameInfoEXT {}
unsafe impl Sync for DebugUtilsObjectNameInfoEXT {}
impl default::Default for DebugUtilsObjectNameInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            p_next: ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            p_object_name: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsObjectNameInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsObjectNameInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("p_object_name", &self.p_object_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
}
unsafe impl Send for DebugUtilsObjectTagInfoEXT {}
unsafe impl Sync for DebugUtilsObjectTagInfoEXT {}
impl default::Default for DebugUtilsObjectTagInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
            p_next: ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsObjectTagInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsObjectTagInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("tag_name", &self.tag_name)
            .field("tag_size", &self.tag_size)
            .field("p_tag", &self.p_tag)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsLabelEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_label_name: *const c_char,
    pub color: [f32; 4],
}
unsafe impl Send for DebugUtilsLabelEXT {}
unsafe impl Sync for DebugUtilsLabelEXT {}
impl default::Default for DebugUtilsLabelEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_LABEL_EXT,
            p_next: ptr::null(),
            p_label_name: ptr::null(),
            color: [f32::default(); 4],
        }
    }
}
impl fmt::Debug for DebugUtilsLabelEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsLabelEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_label_name", &self.p_label_name)
            .field("color", &self.color)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCreateFlagsEXT,
    pub message_severity: DebugUtilsMessageSeverityFlagsEXT,
    pub message_type: DebugUtilsMessageTypeFlagsEXT,
    pub pfn_user_callback: Option<FnDebugUtilsMessengerCallbackEXT>,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DebugUtilsMessengerCreateInfoEXT {}
unsafe impl Sync for DebugUtilsMessengerCreateInfoEXT {}
impl default::Default for DebugUtilsMessengerCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: DebugUtilsMessengerCreateFlagsEXT::default(),
            message_severity: DebugUtilsMessageSeverityFlagsEXT::default(),
            message_type: DebugUtilsMessageTypeFlagsEXT::default(),
            pfn_user_callback: None,
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DebugUtilsMessengerCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("message_severity", &self.message_severity)
            .field("message_type", &self.message_type)
            .field(
                "pfn_user_callback",
                if self.pfn_user_callback.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCallbackDataFlagsEXT,
    pub p_message_id_name: *const c_char,
    pub message_id_number: i32,
    pub p_message: *const c_char,
    pub queue_label_count: u32,
    pub p_queue_labels: *const DebugUtilsLabelEXT,
    pub cmd_buf_label_count: u32,
    pub p_cmd_buf_labels: *const DebugUtilsLabelEXT,
    pub object_count: u32,
    pub p_objects: *const DebugUtilsObjectNameInfoEXT,
}
unsafe impl Send for DebugUtilsMessengerCallbackDataEXT {}
unsafe impl Sync for DebugUtilsMessengerCallbackDataEXT {}
impl default::Default for DebugUtilsMessengerCallbackDataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            p_next: ptr::null(),
            flags: DebugUtilsMessengerCallbackDataFlagsEXT::default(),
            p_message_id_name: ptr::null(),
            message_id_number: i32::default(),
            p_message: ptr::null(),
            queue_label_count: u32::default(),
            p_queue_labels: ptr::null(),
            cmd_buf_label_count: u32::default(),
            p_cmd_buf_labels: ptr::null(),
            object_count: u32::default(),
            p_objects: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsMessengerCallbackDataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCallbackDataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_message_id_name", &self.p_message_id_name)
            .field("message_id_number", &self.message_id_number)
            .field("p_message", &self.p_message)
            .field("queue_label_count", &self.queue_label_count)
            .field("p_queue_labels", &self.p_queue_labels)
            .field("cmd_buf_label_count", &self.cmd_buf_label_count)
            .field("p_cmd_buf_labels", &self.p_cmd_buf_labels)
            .field("object_count", &self.object_count)
            .field("p_objects", &self.p_objects)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_memory_report: Bool32,
}
unsafe impl Send for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
impl default::Default for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            device_memory_report: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceMemoryReportFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_memory_report", &self.device_memory_report)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceDeviceMemoryReportCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub pfn_user_callback: Option<FnDeviceMemoryReportCallbackEXT>,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DeviceDeviceMemoryReportCreateInfoEXT {}
unsafe impl Sync for DeviceDeviceMemoryReportCreateInfoEXT {}
impl default::Default for DeviceDeviceMemoryReportCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            pfn_user_callback: None,
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DeviceDeviceMemoryReportCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDeviceMemoryReportCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_user_callback",
                if self.pfn_user_callback.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryReportCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub ty: DeviceMemoryReportEventTypeEXT,
    pub memory_object_id: u64,
    pub size: DeviceSize,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub heap_index: u32,
}
unsafe impl Send for DeviceMemoryReportCallbackDataEXT {}
unsafe impl Sync for DeviceMemoryReportCallbackDataEXT {}
impl default::Default for DeviceMemoryReportCallbackDataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
            p_next: ptr::null_mut(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            ty: DeviceMemoryReportEventTypeEXT::default(),
            memory_object_id: u64::default(),
            size: DeviceSize::default(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            heap_index: u32::default(),
        }
    }
}
impl fmt::Debug for DeviceMemoryReportCallbackDataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryReportCallbackDataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("ty", &self.ty)
            .field("memory_object_id", &self.memory_object_id)
            .field("size", &self.size)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("heap_index", &self.heap_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryHostPointerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub p_host_pointer: *mut c_void,
}
unsafe impl Send for ImportMemoryHostPointerInfoEXT {}
unsafe impl Sync for ImportMemoryHostPointerInfoEXT {}
impl default::Default for ImportMemoryHostPointerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            p_next: ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            p_host_pointer: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ImportMemoryHostPointerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryHostPointerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("p_host_pointer", &self.p_host_pointer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryHostPointerPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryHostPointerPropertiesEXT {}
unsafe impl Sync for MemoryHostPointerPropertiesEXT {}
impl default::Default for MemoryHostPointerPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for MemoryHostPointerPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryHostPointerPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_imported_host_pointer_alignment: DeviceSize,
}
unsafe impl Send for PhysicalDeviceExternalMemoryHostPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceExternalMemoryHostPropertiesEXT {}
impl default::Default for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            min_imported_host_pointer_alignment: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalMemoryHostPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_imported_host_pointer_alignment",
                &self.min_imported_host_pointer_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The size in pixels the primitive is enlarged at each edge during conservative rasterization
    pub primitive_overestimation_size: f32,
    /// The maximum additional overestimation the client can specify in the pipeline state
    pub max_extra_primitive_overestimation_size: f32,
    /// The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    pub extra_primitive_overestimation_size_granularity: f32,
    /// true if the implementation supports conservative rasterization underestimation mode
    pub primitive_underestimation: Bool32,
    /// true if conservative rasterization also applies to points and lines
    pub conservative_point_and_line_rasterization: Bool32,
    /// true if degenerate triangles (those with zero area after snap) are rasterized
    pub degenerate_triangles_rasterized: Bool32,
    /// true if degenerate lines (those with zero length after snap) are rasterized
    pub degenerate_lines_rasterized: Bool32,
    /// true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    pub fully_covered_fragment_shader_input_variable: Bool32,
    /// true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
    pub conservative_rasterization_post_depth_coverage: Bool32,
}
unsafe impl Send for PhysicalDeviceConservativeRasterizationPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceConservativeRasterizationPropertiesEXT {}
impl default::Default for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            primitive_overestimation_size: f32::default(),
            max_extra_primitive_overestimation_size: f32::default(),
            extra_primitive_overestimation_size_granularity: f32::default(),
            primitive_underestimation: Bool32::default(),
            conservative_point_and_line_rasterization: Bool32::default(),
            degenerate_triangles_rasterized: Bool32::default(),
            degenerate_lines_rasterized: Bool32::default(),
            fully_covered_fragment_shader_input_variable: Bool32::default(),
            conservative_rasterization_post_depth_coverage: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceConservativeRasterizationPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("primitive_overestimation_size", &self.primitive_overestimation_size)
            .field(
                "max_extra_primitive_overestimation_size",
                &self.max_extra_primitive_overestimation_size,
            )
            .field(
                "extra_primitive_overestimation_size_granularity",
                &self.extra_primitive_overestimation_size_granularity,
            )
            .field("primitive_underestimation", &self.primitive_underestimation)
            .field(
                "conservative_point_and_line_rasterization",
                &self.conservative_point_and_line_rasterization,
            )
            .field("degenerate_triangles_rasterized", &self.degenerate_triangles_rasterized)
            .field("degenerate_lines_rasterized", &self.degenerate_lines_rasterized)
            .field(
                "fully_covered_fragment_shader_input_variable",
                &self.fully_covered_fragment_shader_input_variable,
            )
            .field(
                "conservative_rasterization_post_depth_coverage",
                &self.conservative_rasterization_post_depth_coverage,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CalibratedTimestampInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub time_domain: TimeDomainEXT,
}
unsafe impl Send for CalibratedTimestampInfoEXT {}
unsafe impl Sync for CalibratedTimestampInfoEXT {}
impl default::Default for CalibratedTimestampInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::CALIBRATED_TIMESTAMP_INFO_EXT,
            p_next: ptr::null(),
            time_domain: TimeDomainEXT::default(),
        }
    }
}
impl fmt::Debug for CalibratedTimestampInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CalibratedTimestampInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("time_domain", &self.time_domain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderCorePropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// number of shader engines
    pub shader_engine_count: u32,
    /// number of shader arrays
    pub shader_arrays_per_engine_count: u32,
    /// number of physical CUs per shader array
    pub compute_units_per_shader_array: u32,
    /// number of SIMDs per compute unit
    pub simd_per_compute_unit: u32,
    /// number of wavefront slots in each SIMD
    pub wavefronts_per_simd: u32,
    /// maximum number of threads per wavefront
    pub wavefront_size: u32,
    /// number of physical SGPRs per SIMD
    pub sgprs_per_simd: u32,
    /// minimum number of SGPRs that can be allocated by a wave
    pub min_sgpr_allocation: u32,
    /// number of available SGPRs
    pub max_sgpr_allocation: u32,
    /// SGPRs are allocated in groups of this size
    pub sgpr_allocation_granularity: u32,
    /// number of physical VGPRs per SIMD
    pub vgprs_per_simd: u32,
    /// minimum number of VGPRs that can be allocated by a wave
    pub min_vgpr_allocation: u32,
    /// number of available VGPRs
    pub max_vgpr_allocation: u32,
    /// VGPRs are allocated in groups of this size
    pub vgpr_allocation_granularity: u32,
}
unsafe impl Send for PhysicalDeviceShaderCorePropertiesAMD {}
unsafe impl Sync for PhysicalDeviceShaderCorePropertiesAMD {}
impl default::Default for PhysicalDeviceShaderCorePropertiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            p_next: ptr::null_mut(),
            shader_engine_count: u32::default(),
            shader_arrays_per_engine_count: u32::default(),
            compute_units_per_shader_array: u32::default(),
            simd_per_compute_unit: u32::default(),
            wavefronts_per_simd: u32::default(),
            wavefront_size: u32::default(),
            sgprs_per_simd: u32::default(),
            min_sgpr_allocation: u32::default(),
            max_sgpr_allocation: u32::default(),
            sgpr_allocation_granularity: u32::default(),
            vgprs_per_simd: u32::default(),
            min_vgpr_allocation: u32::default(),
            max_vgpr_allocation: u32::default(),
            vgpr_allocation_granularity: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderCorePropertiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderCorePropertiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_engine_count", &self.shader_engine_count)
            .field("shader_arrays_per_engine_count", &self.shader_arrays_per_engine_count)
            .field("compute_units_per_shader_array", &self.compute_units_per_shader_array)
            .field("simd_per_compute_unit", &self.simd_per_compute_unit)
            .field("wavefronts_per_simd", &self.wavefronts_per_simd)
            .field("wavefront_size", &self.wavefront_size)
            .field("sgprs_per_simd", &self.sgprs_per_simd)
            .field("min_sgpr_allocation", &self.min_sgpr_allocation)
            .field("max_sgpr_allocation", &self.max_sgpr_allocation)
            .field("sgpr_allocation_granularity", &self.sgpr_allocation_granularity)
            .field("vgprs_per_simd", &self.vgprs_per_simd)
            .field("min_vgpr_allocation", &self.min_vgpr_allocation)
            .field("max_vgpr_allocation", &self.max_vgpr_allocation)
            .field("vgpr_allocation_granularity", &self.vgpr_allocation_granularity)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderCoreProperties2AMD {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    /// features supported by the shader core
    pub shader_core_features: ShaderCorePropertiesFlagsAMD,
    /// number of active compute units across all shader engines/arrays
    pub active_compute_unit_count: u32,
}
unsafe impl Send for PhysicalDeviceShaderCoreProperties2AMD {}
unsafe impl Sync for PhysicalDeviceShaderCoreProperties2AMD {}
impl default::Default for PhysicalDeviceShaderCoreProperties2AMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            p_next: ptr::null_mut(),
            shader_core_features: ShaderCorePropertiesFlagsAMD::default(),
            active_compute_unit_count: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderCoreProperties2AMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderCoreProperties2AMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_core_features", &self.shader_core_features)
            .field("active_compute_unit_count", &self.active_compute_unit_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Reserved
    pub flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
    /// Conservative rasterization mode
    pub conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    /// Extra overestimation to add to the primitive
    pub extra_primitive_overestimation_size: f32,
}
unsafe impl Send for PipelineRasterizationConservativeStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationConservativeStateCreateInfoEXT {}
impl default::Default for PipelineRasterizationConservativeStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: PipelineRasterizationConservativeStateCreateFlagsEXT::default(),
            conservative_rasterization_mode: ConservativeRasterizationModeEXT::default(),
            extra_primitive_overestimation_size: f32::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationConservativeStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationConservativeStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("conservative_rasterization_mode", &self.conservative_rasterization_mode)
            .field(
                "extra_primitive_overestimation_size",
                &self.extra_primitive_overestimation_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
}
unsafe impl Send for PhysicalDeviceDescriptorIndexingFeatures {}
unsafe impl Sync for PhysicalDeviceDescriptorIndexingFeatures {}
impl default::Default for PhysicalDeviceDescriptorIndexingFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            p_next: ptr::null_mut(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDescriptorIndexingFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDescriptorIndexingFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_input_attachment_array_dynamic_indexing",
                &self.shader_input_attachment_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_dynamic_indexing",
                &self.shader_uniform_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_dynamic_indexing",
                &self.shader_storage_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing",
                &self.shader_uniform_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing",
                &self.shader_sampled_image_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing",
                &self.shader_storage_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing",
                &self.shader_storage_image_array_non_uniform_indexing,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing",
                &self.shader_input_attachment_array_non_uniform_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_non_uniform_indexing",
                &self.shader_uniform_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_non_uniform_indexing",
                &self.shader_storage_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "descriptor_binding_uniform_buffer_update_after_bind",
                &self.descriptor_binding_uniform_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_sampled_image_update_after_bind",
                &self.descriptor_binding_sampled_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_image_update_after_bind",
                &self.descriptor_binding_storage_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_buffer_update_after_bind",
                &self.descriptor_binding_storage_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_uniform_texel_buffer_update_after_bind",
                &self.descriptor_binding_uniform_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_texel_buffer_update_after_bind",
                &self.descriptor_binding_storage_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_update_unused_while_pending",
                &self.descriptor_binding_update_unused_while_pending,
            )
            .field(
                "descriptor_binding_partially_bound",
                &self.descriptor_binding_partially_bound,
            )
            .field(
                "descriptor_binding_variable_descriptor_count",
                &self.descriptor_binding_variable_descriptor_count,
            )
            .field("runtime_descriptor_array", &self.runtime_descriptor_array)
            .finish()
    }
}
pub type PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
}
unsafe impl Send for PhysicalDeviceDescriptorIndexingProperties {}
unsafe impl Sync for PhysicalDeviceDescriptorIndexingProperties {}
impl default::Default for PhysicalDeviceDescriptorIndexingProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            p_next: ptr::null_mut(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDescriptorIndexingProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDescriptorIndexingProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field("quad_divergent_implicit_lod", &self.quad_divergent_implicit_lod)
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .finish()
    }
}
pub type PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutBindingFlagsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub binding_count: u32,
    pub p_binding_flags: *const DescriptorBindingFlags,
}
unsafe impl Send for DescriptorSetLayoutBindingFlagsCreateInfo {}
unsafe impl Sync for DescriptorSetLayoutBindingFlagsCreateInfo {}
impl default::Default for DescriptorSetLayoutBindingFlagsCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            p_next: ptr::null(),
            binding_count: u32::default(),
            p_binding_flags: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutBindingFlagsCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutBindingFlagsCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("binding_count", &self.binding_count)
            .field("p_binding_flags", &self.p_binding_flags)
            .finish()
    }
}
pub type DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_count: u32,
    pub p_descriptor_counts: *const u32,
}
unsafe impl Send for DescriptorSetVariableDescriptorCountAllocateInfo {}
unsafe impl Sync for DescriptorSetVariableDescriptorCountAllocateInfo {}
impl default::Default for DescriptorSetVariableDescriptorCountAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            p_next: ptr::null(),
            descriptor_set_count: u32::default(),
            p_descriptor_counts: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetVariableDescriptorCountAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetVariableDescriptorCountAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_set_count", &self.descriptor_set_count)
            .field("p_descriptor_counts", &self.p_descriptor_counts)
            .finish()
    }
}
pub type DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_variable_descriptor_count: u32,
}
unsafe impl Send for DescriptorSetVariableDescriptorCountLayoutSupport {}
unsafe impl Sync for DescriptorSetVariableDescriptorCountLayoutSupport {}
impl default::Default for DescriptorSetVariableDescriptorCountLayoutSupport {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            p_next: ptr::null_mut(),
            max_variable_descriptor_count: u32::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetVariableDescriptorCountLayoutSupport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetVariableDescriptorCountLayoutSupport")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_variable_descriptor_count", &self.max_variable_descriptor_count)
            .finish()
    }
}
pub type DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    /// Load operation for color or depth data
    pub load_op: AttachmentLoadOp,
    /// Store operation for color or depth data
    pub store_op: AttachmentStoreOp,
    /// Load operation for stencil data
    pub stencil_load_op: AttachmentLoadOp,
    /// Store operation for stencil data
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
unsafe impl Send for AttachmentDescription2 {}
unsafe impl Sync for AttachmentDescription2 {}
impl default::Default for AttachmentDescription2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_DESCRIPTION_2,
            p_next: ptr::null(),
            flags: AttachmentDescriptionFlags::default(),
            format: Format::default(),
            samples: SampleCountFlags::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            stencil_load_op: AttachmentLoadOp::default(),
            stencil_store_op: AttachmentStoreOp::default(),
            initial_layout: ImageLayout::default(),
            final_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for AttachmentDescription2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescription2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("format", &self.format)
            .field("samples", &self.samples)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("stencil_load_op", &self.stencil_load_op)
            .field("stencil_store_op", &self.stencil_store_op)
            .field("initial_layout", &self.initial_layout)
            .field("final_layout", &self.final_layout)
            .finish()
    }
}
pub type AttachmentDescription2KHR = AttachmentDescription2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentReference2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment: u32,
    pub layout: ImageLayout,
    pub aspect_mask: ImageAspectFlags,
}
unsafe impl Send for AttachmentReference2 {}
unsafe impl Sync for AttachmentReference2 {}
impl default::Default for AttachmentReference2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_REFERENCE_2,
            p_next: ptr::null(),
            attachment: u32::default(),
            layout: ImageLayout::default(),
            aspect_mask: ImageAspectFlags::default(),
        }
    }
}
impl fmt::Debug for AttachmentReference2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReference2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment", &self.attachment)
            .field("layout", &self.layout)
            .field("aspect_mask", &self.aspect_mask)
            .finish()
    }
}
pub type AttachmentReference2KHR = AttachmentReference2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub view_mask: u32,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference2,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference2,
    pub p_resolve_attachments: *const AttachmentReference2,
    pub p_depth_stencil_attachment: *const AttachmentReference2,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
unsafe impl Send for SubpassDescription2 {}
unsafe impl Sync for SubpassDescription2 {}
impl default::Default for SubpassDescription2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DESCRIPTION_2,
            p_next: ptr::null(),
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            view_mask: u32::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescription2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescription2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("view_mask", &self.view_mask)
            .field("input_attachment_count", &self.input_attachment_count)
            .field("p_input_attachments", &self.p_input_attachments)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_resolve_attachments", &self.p_resolve_attachments)
            .field("p_depth_stencil_attachment", &self.p_depth_stencil_attachment)
            .field("preserve_attachment_count", &self.preserve_attachment_count)
            .field("p_preserve_attachments", &self.p_preserve_attachments)
            .finish()
    }
}
pub type SubpassDescription2KHR = SubpassDescription2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDependency2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
    pub view_offset: i32,
}
unsafe impl Send for SubpassDependency2 {}
unsafe impl Sync for SubpassDependency2 {}
impl default::Default for SubpassDependency2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DEPENDENCY_2,
            p_next: ptr::null(),
            src_subpass: u32::default(),
            dst_subpass: u32::default(),
            src_stage_mask: PipelineStageFlags::default(),
            dst_stage_mask: PipelineStageFlags::default(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            dependency_flags: DependencyFlags::default(),
            view_offset: i32::default(),
        }
    }
}
impl fmt::Debug for SubpassDependency2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDependency2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subpass", &self.src_subpass)
            .field("dst_subpass", &self.dst_subpass)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("dependency_flags", &self.dependency_flags)
            .field("view_offset", &self.view_offset)
            .finish()
    }
}
pub type SubpassDependency2KHR = SubpassDependency2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreateInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription2,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription2,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency2,
    pub correlated_view_mask_count: u32,
    pub p_correlated_view_masks: *const u32,
}
unsafe impl Send for RenderPassCreateInfo2 {}
unsafe impl Sync for RenderPassCreateInfo2 {}
impl default::Default for RenderPassCreateInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATE_INFO_2,
            p_next: ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ptr::null(),
            correlated_view_mask_count: u32::default(),
            p_correlated_view_masks: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassCreateInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreateInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("subpass_count", &self.subpass_count)
            .field("p_subpasses", &self.p_subpasses)
            .field("dependency_count", &self.dependency_count)
            .field("p_dependencies", &self.p_dependencies)
            .field("correlated_view_mask_count", &self.correlated_view_mask_count)
            .field("p_correlated_view_masks", &self.p_correlated_view_masks)
            .finish()
    }
}
pub type RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub contents: SubpassContents,
}
unsafe impl Send for SubpassBeginInfo {}
unsafe impl Sync for SubpassBeginInfo {}
impl default::Default for SubpassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_BEGIN_INFO,
            p_next: ptr::null(),
            contents: SubpassContents::default(),
        }
    }
}
impl fmt::Debug for SubpassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("contents", &self.contents)
            .finish()
    }
}
pub type SubpassBeginInfoKHR = SubpassBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassEndInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
}
unsafe impl Send for SubpassEndInfo {}
unsafe impl Sync for SubpassEndInfo {}
impl default::Default for SubpassEndInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_END_INFO,
            p_next: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassEndInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassEndInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
pub type SubpassEndInfoKHR = SubpassEndInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTimelineSemaphoreFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub timeline_semaphore: Bool32,
}
unsafe impl Send for PhysicalDeviceTimelineSemaphoreFeatures {}
unsafe impl Sync for PhysicalDeviceTimelineSemaphoreFeatures {}
impl default::Default for PhysicalDeviceTimelineSemaphoreFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            p_next: ptr::null_mut(),
            timeline_semaphore: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTimelineSemaphoreFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTimelineSemaphoreFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("timeline_semaphore", &self.timeline_semaphore)
            .finish()
    }
}
pub type PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTimelineSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_timeline_semaphore_value_difference: u64,
}
unsafe impl Send for PhysicalDeviceTimelineSemaphoreProperties {}
unsafe impl Sync for PhysicalDeviceTimelineSemaphoreProperties {}
impl default::Default for PhysicalDeviceTimelineSemaphoreProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            p_next: ptr::null_mut(),
            max_timeline_semaphore_value_difference: u64::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTimelineSemaphoreProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTimelineSemaphoreProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .finish()
    }
}
pub type PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreTypeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore_type: SemaphoreType,
    pub initial_value: u64,
}
unsafe impl Send for SemaphoreTypeCreateInfo {}
unsafe impl Sync for SemaphoreTypeCreateInfo {}
impl default::Default for SemaphoreTypeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_TYPE_CREATE_INFO,
            p_next: ptr::null(),
            semaphore_type: SemaphoreType::default(),
            initial_value: u64::default(),
        }
    }
}
impl fmt::Debug for SemaphoreTypeCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreTypeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore_type", &self.semaphore_type)
            .field("initial_value", &self.initial_value)
            .finish()
    }
}
pub type SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TimelineSemaphoreSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_value_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_value_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
unsafe impl Send for TimelineSemaphoreSubmitInfo {}
unsafe impl Sync for TimelineSemaphoreSubmitInfo {}
impl default::Default for TimelineSemaphoreSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::TIMELINE_SEMAPHORE_SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_value_count: u32::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_value_count: u32::default(),
            p_signal_semaphore_values: ptr::null(),
        }
    }
}
impl fmt::Debug for TimelineSemaphoreSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TimelineSemaphoreSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_value_count", &self.wait_semaphore_value_count)
            .field("p_wait_semaphore_values", &self.p_wait_semaphore_values)
            .field("signal_semaphore_value_count", &self.signal_semaphore_value_count)
            .field("p_signal_semaphore_values", &self.p_signal_semaphore_values)
            .finish()
    }
}
pub type TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreWaitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreWaitFlags,
    pub semaphore_count: u32,
    pub p_semaphores: *const Semaphore,
    pub p_values: *const u64,
}
unsafe impl Send for SemaphoreWaitInfo {}
unsafe impl Sync for SemaphoreWaitInfo {}
impl default::Default for SemaphoreWaitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_WAIT_INFO,
            p_next: ptr::null(),
            flags: SemaphoreWaitFlags::default(),
            semaphore_count: u32::default(),
            p_semaphores: ptr::null(),
            p_values: ptr::null(),
        }
    }
}
impl fmt::Debug for SemaphoreWaitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreWaitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("semaphore_count", &self.semaphore_count)
            .field("p_semaphores", &self.p_semaphores)
            .field("p_values", &self.p_values)
            .finish()
    }
}
pub type SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreSignalInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
}
unsafe impl Send for SemaphoreSignalInfo {}
unsafe impl Sync for SemaphoreSignalInfo {}
impl default::Default for SemaphoreSignalInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_SIGNAL_INFO,
            p_next: ptr::null(),
            semaphore: None,
            value: u64::default(),
        }
    }
}
impl fmt::Debug for SemaphoreSignalInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreSignalInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("value", &self.value)
            .finish()
    }
}
pub type SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct VertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
impl default::Default for VertexInputBindingDivisorDescriptionEXT {
    fn default() -> Self {
        Self {
            binding: u32::default(),
            divisor: u32::default(),
        }
    }
}
impl fmt::Debug for VertexInputBindingDivisorDescriptionEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDivisorDescriptionEXT")
            .field("binding", &self.binding)
            .field("divisor", &self.divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineVertexInputDivisorStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_binding_divisor_count: u32,
    pub p_vertex_binding_divisors: *const VertexInputBindingDivisorDescriptionEXT,
}
unsafe impl Send for PipelineVertexInputDivisorStateCreateInfoEXT {}
unsafe impl Sync for PipelineVertexInputDivisorStateCreateInfoEXT {}
impl default::Default for PipelineVertexInputDivisorStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            vertex_binding_divisor_count: u32::default(),
            p_vertex_binding_divisors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineVertexInputDivisorStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineVertexInputDivisorStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_binding_divisor_count", &self.vertex_binding_divisor_count)
            .field("p_vertex_binding_divisors", &self.p_vertex_binding_divisors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max value of vertex attribute divisor
    pub max_vertex_attrib_divisor: u32,
}
unsafe impl Send for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
impl default::Default for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_vertex_attrib_divisor: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexAttributeDivisorPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_vertex_attrib_divisor", &self.max_vertex_attrib_divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pci_domain: u32,
    pub pci_bus: u32,
    pub pci_device: u32,
    pub pci_function: u32,
}
unsafe impl Send for PhysicalDevicePCIBusInfoPropertiesEXT {}
unsafe impl Sync for PhysicalDevicePCIBusInfoPropertiesEXT {}
impl default::Default for PhysicalDevicePCIBusInfoPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            pci_domain: u32::default(),
            pci_bus: u32::default(),
            pci_device: u32::default(),
            pci_function: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePCIBusInfoPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePCIBusInfoPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pci_domain", &self.pci_domain)
            .field("pci_bus", &self.pci_bus)
            .field("pci_device", &self.pci_device)
            .field("pci_function", &self.pci_function)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: *mut AHardwareBuffer,
}
unsafe impl Send for ImportAndroidHardwareBufferInfoANDROID {}
unsafe impl Sync for ImportAndroidHardwareBufferInfoANDROID {}
impl default::Default for ImportAndroidHardwareBufferInfoANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: ptr::null(),
            buffer: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ImportAndroidHardwareBufferInfoANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportAndroidHardwareBufferInfoANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferUsageANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub android_hardware_buffer_usage: u64,
}
unsafe impl Send for AndroidHardwareBufferUsageANDROID {}
unsafe impl Sync for AndroidHardwareBufferUsageANDROID {}
impl default::Default for AndroidHardwareBufferUsageANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            p_next: ptr::null_mut(),
            android_hardware_buffer_usage: u64::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferUsageANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferUsageANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("android_hardware_buffer_usage", &self.android_hardware_buffer_usage)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
}
unsafe impl Send for AndroidHardwareBufferPropertiesANDROID {}
unsafe impl Sync for AndroidHardwareBufferPropertiesANDROID {}
impl default::Default for AndroidHardwareBufferPropertiesANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            p_next: ptr::null_mut(),
            allocation_size: DeviceSize::default(),
            memory_type_bits: u32::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferPropertiesANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferPropertiesANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("allocation_size", &self.allocation_size)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
}
unsafe impl Send for MemoryGetAndroidHardwareBufferInfoANDROID {}
unsafe impl Sync for MemoryGetAndroidHardwareBufferInfoANDROID {}
impl default::Default for MemoryGetAndroidHardwareBufferInfoANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: ptr::null(),
            memory: None,
        }
    }
}
impl fmt::Debug for MemoryGetAndroidHardwareBufferInfoANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetAndroidHardwareBufferInfoANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferFormatPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for AndroidHardwareBufferFormatPropertiesANDROID {}
unsafe impl Sync for AndroidHardwareBufferFormatPropertiesANDROID {}
impl default::Default for AndroidHardwareBufferFormatPropertiesANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            p_next: ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferFormatPropertiesANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferFormatPropertiesANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("external_format", &self.external_format)
            .field("format_features", &self.format_features)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this secondary command buffer may be executed during an active conditional rendering
    pub conditional_rendering_enable: Bool32,
}
unsafe impl Send for CommandBufferInheritanceConditionalRenderingInfoEXT {}
unsafe impl Sync for CommandBufferInheritanceConditionalRenderingInfoEXT {}
impl default::Default for CommandBufferInheritanceConditionalRenderingInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            p_next: ptr::null(),
            conditional_rendering_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceConditionalRenderingInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceConditionalRenderingInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conditional_rendering_enable", &self.conditional_rendering_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalFormatANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_format: u64,
}
unsafe impl Send for ExternalFormatANDROID {}
unsafe impl Sync for ExternalFormatANDROID {}
impl default::Default for ExternalFormatANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_FORMAT_ANDROID,
            p_next: ptr::null_mut(),
            external_format: u64::default(),
        }
    }
}
impl fmt::Debug for ExternalFormatANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalFormatANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_format", &self.external_format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice8BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 8-bit integer variables supported in StorageBuffer
    pub storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in StorageBuffer and Uniform
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in PushConstant
    pub storage_push_constant8: Bool32,
}
unsafe impl Send for PhysicalDevice8BitStorageFeatures {}
unsafe impl Sync for PhysicalDevice8BitStorageFeatures {}
impl default::Default for PhysicalDevice8BitStorageFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice8BitStorageFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice8BitStorageFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer8_bit_access", &self.storage_buffer8_bit_access)
            .field(
                "uniform_and_storage_buffer8_bit_access",
                &self.uniform_and_storage_buffer8_bit_access,
            )
            .field("storage_push_constant8", &self.storage_push_constant8)
            .finish()
    }
}
pub type PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub conditional_rendering: Bool32,
    pub inherited_conditional_rendering: Bool32,
}
unsafe impl Send for PhysicalDeviceConditionalRenderingFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceConditionalRenderingFeaturesEXT {}
impl default::Default for PhysicalDeviceConditionalRenderingFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            p_next: ptr::null_mut(),
            conditional_rendering: Bool32::default(),
            inherited_conditional_rendering: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceConditionalRenderingFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceConditionalRenderingFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conditional_rendering", &self.conditional_rendering)
            .field("inherited_conditional_rendering", &self.inherited_conditional_rendering)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkanMemoryModelFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkanMemoryModelFeatures {}
unsafe impl Sync for PhysicalDeviceVulkanMemoryModelFeatures {}
impl default::Default for PhysicalDeviceVulkanMemoryModelFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            p_next: ptr::null_mut(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkanMemoryModelFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkanMemoryModelFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vulkan_memory_model", &self.vulkan_memory_model)
            .field(
                "vulkan_memory_model_device_scope",
                &self.vulkan_memory_model_device_scope,
            )
            .field(
                "vulkan_memory_model_availability_visibility_chains",
                &self.vulkan_memory_model_availability_visibility_chains,
            )
            .finish()
    }
}
pub type PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicInt64Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicInt64Features {}
unsafe impl Sync for PhysicalDeviceShaderAtomicInt64Features {}
impl default::Default for PhysicalDeviceShaderAtomicInt64Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            p_next: ptr::null_mut(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicInt64Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicInt64Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_int64_atomics", &self.shader_buffer_int64_atomics)
            .field("shader_shared_int64_atomics", &self.shader_shared_int64_atomics)
            .finish()
    }
}
pub type PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float32_atomics: Bool32,
    pub shader_buffer_float32_atomic_add: Bool32,
    pub shader_buffer_float64_atomics: Bool32,
    pub shader_buffer_float64_atomic_add: Bool32,
    pub shader_shared_float32_atomics: Bool32,
    pub shader_shared_float32_atomic_add: Bool32,
    pub shader_shared_float64_atomics: Bool32,
    pub shader_shared_float64_atomic_add: Bool32,
    pub shader_image_float32_atomics: Bool32,
    pub shader_image_float32_atomic_add: Bool32,
    pub sparse_image_float32_atomics: Bool32,
    pub sparse_image_float32_atomic_add: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
impl default::Default for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_buffer_float32_atomics: Bool32::default(),
            shader_buffer_float32_atomic_add: Bool32::default(),
            shader_buffer_float64_atomics: Bool32::default(),
            shader_buffer_float64_atomic_add: Bool32::default(),
            shader_shared_float32_atomics: Bool32::default(),
            shader_shared_float32_atomic_add: Bool32::default(),
            shader_shared_float64_atomics: Bool32::default(),
            shader_shared_float64_atomic_add: Bool32::default(),
            shader_image_float32_atomics: Bool32::default(),
            shader_image_float32_atomic_add: Bool32::default(),
            sparse_image_float32_atomics: Bool32::default(),
            sparse_image_float32_atomic_add: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicFloatFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_float32_atomics", &self.shader_buffer_float32_atomics)
            .field(
                "shader_buffer_float32_atomic_add",
                &self.shader_buffer_float32_atomic_add,
            )
            .field("shader_buffer_float64_atomics", &self.shader_buffer_float64_atomics)
            .field(
                "shader_buffer_float64_atomic_add",
                &self.shader_buffer_float64_atomic_add,
            )
            .field("shader_shared_float32_atomics", &self.shader_shared_float32_atomics)
            .field(
                "shader_shared_float32_atomic_add",
                &self.shader_shared_float32_atomic_add,
            )
            .field("shader_shared_float64_atomics", &self.shader_shared_float64_atomics)
            .field(
                "shader_shared_float64_atomic_add",
                &self.shader_shared_float64_atomic_add,
            )
            .field("shader_image_float32_atomics", &self.shader_image_float32_atomics)
            .field("shader_image_float32_atomic_add", &self.shader_image_float32_atomic_add)
            .field("sparse_image_float32_atomics", &self.sparse_image_float32_atomics)
            .field("sparse_image_float32_atomic_add", &self.sparse_image_float32_atomic_add)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float16_atomics: Bool32,
    pub shader_buffer_float16_atomic_add: Bool32,
    pub shader_buffer_float16_atomic_min_max: Bool32,
    pub shader_buffer_float32_atomic_min_max: Bool32,
    pub shader_buffer_float64_atomic_min_max: Bool32,
    pub shader_shared_float16_atomics: Bool32,
    pub shader_shared_float16_atomic_add: Bool32,
    pub shader_shared_float16_atomic_min_max: Bool32,
    pub shader_shared_float32_atomic_min_max: Bool32,
    pub shader_shared_float64_atomic_min_max: Bool32,
    pub shader_image_float32_atomic_min_max: Bool32,
    pub sparse_image_float32_atomic_min_max: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
impl default::Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_buffer_float16_atomics: Bool32::default(),
            shader_buffer_float16_atomic_add: Bool32::default(),
            shader_buffer_float16_atomic_min_max: Bool32::default(),
            shader_buffer_float32_atomic_min_max: Bool32::default(),
            shader_buffer_float64_atomic_min_max: Bool32::default(),
            shader_shared_float16_atomics: Bool32::default(),
            shader_shared_float16_atomic_add: Bool32::default(),
            shader_shared_float16_atomic_min_max: Bool32::default(),
            shader_shared_float32_atomic_min_max: Bool32::default(),
            shader_shared_float64_atomic_min_max: Bool32::default(),
            shader_image_float32_atomic_min_max: Bool32::default(),
            sparse_image_float32_atomic_min_max: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicFloat2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_float16_atomics", &self.shader_buffer_float16_atomics)
            .field(
                "shader_buffer_float16_atomic_add",
                &self.shader_buffer_float16_atomic_add,
            )
            .field(
                "shader_buffer_float16_atomic_min_max",
                &self.shader_buffer_float16_atomic_min_max,
            )
            .field(
                "shader_buffer_float32_atomic_min_max",
                &self.shader_buffer_float32_atomic_min_max,
            )
            .field(
                "shader_buffer_float64_atomic_min_max",
                &self.shader_buffer_float64_atomic_min_max,
            )
            .field("shader_shared_float16_atomics", &self.shader_shared_float16_atomics)
            .field(
                "shader_shared_float16_atomic_add",
                &self.shader_shared_float16_atomic_add,
            )
            .field(
                "shader_shared_float16_atomic_min_max",
                &self.shader_shared_float16_atomic_min_max,
            )
            .field(
                "shader_shared_float32_atomic_min_max",
                &self.shader_shared_float32_atomic_min_max,
            )
            .field(
                "shader_shared_float64_atomic_min_max",
                &self.shader_shared_float64_atomic_min_max,
            )
            .field(
                "shader_image_float32_atomic_min_max",
                &self.shader_image_float32_atomic_min_max,
            )
            .field(
                "sparse_image_float32_atomic_min_max",
                &self.sparse_image_float32_atomic_min_max,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_attribute_instance_rate_divisor: Bool32,
    pub vertex_attribute_instance_rate_zero_divisor: Bool32,
}
unsafe impl Send for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
impl default::Default for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
            p_next: ptr::null_mut(),
            vertex_attribute_instance_rate_divisor: Bool32::default(),
            vertex_attribute_instance_rate_zero_divisor: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexAttributeDivisorFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "vertex_attribute_instance_rate_divisor",
                &self.vertex_attribute_instance_rate_divisor,
            )
            .field(
                "vertex_attribute_instance_rate_zero_divisor",
                &self.vertex_attribute_instance_rate_zero_divisor,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyCheckpointPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags,
}
unsafe impl Send for QueueFamilyCheckpointPropertiesNV {}
unsafe impl Sync for QueueFamilyCheckpointPropertiesNV {}
impl default::Default for QueueFamilyCheckpointPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyCheckpointPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyCheckpointPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("checkpoint_execution_stage_mask", &self.checkpoint_execution_stage_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CheckpointDataNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags,
    pub p_checkpoint_marker: *mut c_void,
}
unsafe impl Send for CheckpointDataNV {}
unsafe impl Sync for CheckpointDataNV {}
impl default::Default for CheckpointDataNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::CHECKPOINT_DATA_NV,
            p_next: ptr::null_mut(),
            stage: PipelineStageFlags::default(),
            p_checkpoint_marker: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for CheckpointDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CheckpointDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage", &self.stage)
            .field("p_checkpoint_marker", &self.p_checkpoint_marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthStencilResolveProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// supported depth resolve modes
    pub supported_depth_resolve_modes: ResolveModeFlags,
    /// supported stencil resolve modes
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    /// depth and stencil resolve modes can be set independently if one of them is none
    pub independent_resolve_none: Bool32,
    /// depth and stencil resolve modes can be set independently
    pub independent_resolve: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthStencilResolveProperties {}
unsafe impl Sync for PhysicalDeviceDepthStencilResolveProperties {}
impl default::Default for PhysicalDeviceDepthStencilResolveProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            p_next: ptr::null_mut(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthStencilResolveProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthStencilResolveProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supported_depth_resolve_modes", &self.supported_depth_resolve_modes)
            .field("supported_stencil_resolve_modes", &self.supported_stencil_resolve_modes)
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .finish()
    }
}
pub type PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescriptionDepthStencilResolve {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// depth resolve mode
    pub depth_resolve_mode: ResolveModeFlags,
    /// stencil resolve mode
    pub stencil_resolve_mode: ResolveModeFlags,
    /// depth/stencil resolve attachment
    pub p_depth_stencil_resolve_attachment: *const AttachmentReference2,
}
unsafe impl Send for SubpassDescriptionDepthStencilResolve {}
unsafe impl Sync for SubpassDescriptionDepthStencilResolve {}
impl default::Default for SubpassDescriptionDepthStencilResolve {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            p_next: ptr::null(),
            depth_resolve_mode: ResolveModeFlags::default(),
            stencil_resolve_mode: ResolveModeFlags::default(),
            p_depth_stencil_resolve_attachment: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescriptionDepthStencilResolve {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescriptionDepthStencilResolve")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_resolve_mode", &self.depth_resolve_mode)
            .field("stencil_resolve_mode", &self.stencil_resolve_mode)
            .field(
                "p_depth_stencil_resolve_attachment",
                &self.p_depth_stencil_resolve_attachment,
            )
            .finish()
    }
}
pub type SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewASTCDecodeModeEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub decode_mode: Format,
}
unsafe impl Send for ImageViewASTCDecodeModeEXT {}
unsafe impl Sync for ImageViewASTCDecodeModeEXT {}
impl default::Default for ImageViewASTCDecodeModeEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            p_next: ptr::null(),
            decode_mode: Format::default(),
        }
    }
}
impl fmt::Debug for ImageViewASTCDecodeModeEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewASTCDecodeModeEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("decode_mode", &self.decode_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub decode_mode_shared_exponent: Bool32,
}
unsafe impl Send for PhysicalDeviceASTCDecodeFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceASTCDecodeFeaturesEXT {}
impl default::Default for PhysicalDeviceASTCDecodeFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            decode_mode_shared_exponent: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceASTCDecodeFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceASTCDecodeFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("decode_mode_shared_exponent", &self.decode_mode_shared_exponent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform_feedback: Bool32,
    pub geometry_streams: Bool32,
}
unsafe impl Send for PhysicalDeviceTransformFeedbackFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceTransformFeedbackFeaturesEXT {}
impl default::Default for PhysicalDeviceTransformFeedbackFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            transform_feedback: Bool32::default(),
            geometry_streams: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTransformFeedbackFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTransformFeedbackFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform_feedback", &self.transform_feedback)
            .field("geometry_streams", &self.geometry_streams)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_transform_feedback_streams: u32,
    pub max_transform_feedback_buffers: u32,
    pub max_transform_feedback_buffer_size: DeviceSize,
    pub max_transform_feedback_stream_data_size: u32,
    pub max_transform_feedback_buffer_data_size: u32,
    pub max_transform_feedback_buffer_data_stride: u32,
    pub transform_feedback_queries: Bool32,
    pub transform_feedback_streams_lines_triangles: Bool32,
    pub transform_feedback_rasterization_stream_select: Bool32,
    pub transform_feedback_draw: Bool32,
}
unsafe impl Send for PhysicalDeviceTransformFeedbackPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceTransformFeedbackPropertiesEXT {}
impl default::Default for PhysicalDeviceTransformFeedbackPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_transform_feedback_streams: u32::default(),
            max_transform_feedback_buffers: u32::default(),
            max_transform_feedback_buffer_size: DeviceSize::default(),
            max_transform_feedback_stream_data_size: u32::default(),
            max_transform_feedback_buffer_data_size: u32::default(),
            max_transform_feedback_buffer_data_stride: u32::default(),
            transform_feedback_queries: Bool32::default(),
            transform_feedback_streams_lines_triangles: Bool32::default(),
            transform_feedback_rasterization_stream_select: Bool32::default(),
            transform_feedback_draw: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTransformFeedbackPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTransformFeedbackPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_transform_feedback_streams", &self.max_transform_feedback_streams)
            .field("max_transform_feedback_buffers", &self.max_transform_feedback_buffers)
            .field(
                "max_transform_feedback_buffer_size",
                &self.max_transform_feedback_buffer_size,
            )
            .field(
                "max_transform_feedback_stream_data_size",
                &self.max_transform_feedback_stream_data_size,
            )
            .field(
                "max_transform_feedback_buffer_data_size",
                &self.max_transform_feedback_buffer_data_size,
            )
            .field(
                "max_transform_feedback_buffer_data_stride",
                &self.max_transform_feedback_buffer_data_stride,
            )
            .field("transform_feedback_queries", &self.transform_feedback_queries)
            .field(
                "transform_feedback_streams_lines_triangles",
                &self.transform_feedback_streams_lines_triangles,
            )
            .field(
                "transform_feedback_rasterization_stream_select",
                &self.transform_feedback_rasterization_stream_select,
            )
            .field("transform_feedback_draw", &self.transform_feedback_draw)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateStreamCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterization_stream: u32,
}
unsafe impl Send for PipelineRasterizationStateStreamCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationStateStreamCreateInfoEXT {}
impl default::Default for PipelineRasterizationStateStreamCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: PipelineRasterizationStateStreamCreateFlagsEXT::default(),
            rasterization_stream: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateStreamCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateStreamCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("rasterization_stream", &self.rasterization_stream)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub representative_fragment_test: Bool32,
}
unsafe impl Send for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
unsafe impl Sync for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
impl default::Default for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            p_next: ptr::null_mut(),
            representative_fragment_test: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRepresentativeFragmentTestFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("representative_fragment_test", &self.representative_fragment_test)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub representative_fragment_test_enable: Bool32,
}
unsafe impl Send for PipelineRepresentativeFragmentTestStateCreateInfoNV {}
unsafe impl Sync for PipelineRepresentativeFragmentTestStateCreateInfoNV {}
impl default::Default for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            representative_fragment_test_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRepresentativeFragmentTestStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "representative_fragment_test_enable",
                &self.representative_fragment_test_enable,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub exclusive_scissor: Bool32,
}
unsafe impl Send for PhysicalDeviceExclusiveScissorFeaturesNV {}
unsafe impl Sync for PhysicalDeviceExclusiveScissorFeaturesNV {}
impl default::Default for PhysicalDeviceExclusiveScissorFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            p_next: ptr::null_mut(),
            exclusive_scissor: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExclusiveScissorFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExclusiveScissorFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("exclusive_scissor", &self.exclusive_scissor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub exclusive_scissor_count: u32,
    pub p_exclusive_scissors: *const Rect2D,
}
unsafe impl Send for PipelineViewportExclusiveScissorStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportExclusiveScissorStateCreateInfoNV {}
impl default::Default for PipelineViewportExclusiveScissorStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            exclusive_scissor_count: u32::default(),
            p_exclusive_scissors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportExclusiveScissorStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportExclusiveScissorStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("exclusive_scissor_count", &self.exclusive_scissor_count)
            .field("p_exclusive_scissors", &self.p_exclusive_scissors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub corner_sampled_image: Bool32,
}
unsafe impl Send for PhysicalDeviceCornerSampledImageFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCornerSampledImageFeaturesNV {}
impl default::Default for PhysicalDeviceCornerSampledImageFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            p_next: ptr::null_mut(),
            corner_sampled_image: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCornerSampledImageFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCornerSampledImageFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("corner_sampled_image", &self.corner_sampled_image)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub compute_derivative_group_quads: Bool32,
    pub compute_derivative_group_linear: Bool32,
}
unsafe impl Send for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
unsafe impl Sync for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
impl default::Default for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
            p_next: ptr::null_mut(),
            compute_derivative_group_quads: Bool32::default(),
            compute_derivative_group_linear: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceComputeShaderDerivativesFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compute_derivative_group_quads", &self.compute_derivative_group_quads)
            .field("compute_derivative_group_linear", &self.compute_derivative_group_linear)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_barycentric: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {}
unsafe impl Sync for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {}
impl default::Default for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
            p_next: ptr::null_mut(),
            fragment_shader_barycentric: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShaderBarycentricFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_shader_barycentric", &self.fragment_shader_barycentric)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_footprint: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderImageFootprintFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShaderImageFootprintFeaturesNV {}
impl default::Default for PhysicalDeviceShaderImageFootprintFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            p_next: ptr::null_mut(),
            image_footprint: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderImageFootprintFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderImageFootprintFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_footprint", &self.image_footprint)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dedicated_allocation_image_aliasing: Bool32,
}
unsafe impl Send for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
impl default::Default for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            p_next: ptr::null_mut(),
            dedicated_allocation_image_aliasing: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "dedicated_allocation_image_aliasing",
                &self.dedicated_allocation_image_aliasing,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShadingRatePaletteNV {
    pub shading_rate_palette_entry_count: u32,
    pub p_shading_rate_palette_entries: *const ShadingRatePaletteEntryNV,
}
unsafe impl Send for ShadingRatePaletteNV {}
unsafe impl Sync for ShadingRatePaletteNV {}
impl default::Default for ShadingRatePaletteNV {
    fn default() -> Self {
        Self {
            shading_rate_palette_entry_count: u32::default(),
            p_shading_rate_palette_entries: ptr::null(),
        }
    }
}
impl fmt::Debug for ShadingRatePaletteNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShadingRatePaletteNV")
            .field(
                "shading_rate_palette_entry_count",
                &self.shading_rate_palette_entry_count,
            )
            .field("p_shading_rate_palette_entries", &self.p_shading_rate_palette_entries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_image_enable: Bool32,
    pub viewport_count: u32,
    pub p_shading_rate_palettes: *const ShadingRatePaletteNV,
}
unsafe impl Send for PipelineViewportShadingRateImageStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportShadingRateImageStateCreateInfoNV {}
impl default::Default for PipelineViewportShadingRateImageStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            shading_rate_image_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_shading_rate_palettes: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportShadingRateImageStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportShadingRateImageStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_image_enable", &self.shading_rate_image_enable)
            .field("viewport_count", &self.viewport_count)
            .field("p_shading_rate_palettes", &self.p_shading_rate_palettes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShadingRateImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_image: Bool32,
    pub shading_rate_coarse_sample_order: Bool32,
}
unsafe impl Send for PhysicalDeviceShadingRateImageFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShadingRateImageFeaturesNV {}
impl default::Default for PhysicalDeviceShadingRateImageFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            p_next: ptr::null_mut(),
            shading_rate_image: Bool32::default(),
            shading_rate_coarse_sample_order: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShadingRateImageFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShadingRateImageFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_image", &self.shading_rate_image)
            .field(
                "shading_rate_coarse_sample_order",
                &self.shading_rate_coarse_sample_order,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShadingRateImagePropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_texel_size: Extent2D,
    pub shading_rate_palette_size: u32,
    pub shading_rate_max_coarse_samples: u32,
}
unsafe impl Send for PhysicalDeviceShadingRateImagePropertiesNV {}
unsafe impl Sync for PhysicalDeviceShadingRateImagePropertiesNV {}
impl default::Default for PhysicalDeviceShadingRateImagePropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shading_rate_texel_size: Extent2D::default(),
            shading_rate_palette_size: u32::default(),
            shading_rate_max_coarse_samples: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShadingRateImagePropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShadingRateImagePropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_texel_size", &self.shading_rate_texel_size)
            .field("shading_rate_palette_size", &self.shading_rate_palette_size)
            .field("shading_rate_max_coarse_samples", &self.shading_rate_max_coarse_samples)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub invocation_mask: Bool32,
}
unsafe impl Send for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
unsafe impl Sync for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
impl default::Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            p_next: ptr::null_mut(),
            invocation_mask: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInvocationMaskFeaturesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("invocation_mask", &self.invocation_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct CoarseSampleLocationNV {
    pub pixel_x: u32,
    pub pixel_y: u32,
    pub sample: u32,
}
impl default::Default for CoarseSampleLocationNV {
    fn default() -> Self {
        Self {
            pixel_x: u32::default(),
            pixel_y: u32::default(),
            sample: u32::default(),
        }
    }
}
impl fmt::Debug for CoarseSampleLocationNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CoarseSampleLocationNV")
            .field("pixel_x", &self.pixel_x)
            .field("pixel_y", &self.pixel_y)
            .field("sample", &self.sample)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoarseSampleOrderCustomNV {
    pub shading_rate: ShadingRatePaletteEntryNV,
    pub sample_count: u32,
    pub sample_location_count: u32,
    pub p_sample_locations: *const CoarseSampleLocationNV,
}
unsafe impl Send for CoarseSampleOrderCustomNV {}
unsafe impl Sync for CoarseSampleOrderCustomNV {}
impl default::Default for CoarseSampleOrderCustomNV {
    fn default() -> Self {
        Self {
            shading_rate: ShadingRatePaletteEntryNV::default(),
            sample_count: u32::default(),
            sample_location_count: u32::default(),
            p_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for CoarseSampleOrderCustomNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CoarseSampleOrderCustomNV")
            .field("shading_rate", &self.shading_rate)
            .field("sample_count", &self.sample_count)
            .field("sample_location_count", &self.sample_location_count)
            .field("p_sample_locations", &self.p_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_order_type: CoarseSampleOrderTypeNV,
    pub custom_sample_order_count: u32,
    pub p_custom_sample_orders: *const CoarseSampleOrderCustomNV,
}
unsafe impl Send for PipelineViewportCoarseSampleOrderStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportCoarseSampleOrderStateCreateInfoNV {}
impl default::Default for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            sample_order_type: CoarseSampleOrderTypeNV::default(),
            custom_sample_order_count: u32::default(),
            p_custom_sample_orders: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportCoarseSampleOrderStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_order_type", &self.sample_order_type)
            .field("custom_sample_order_count", &self.custom_sample_order_count)
            .field("p_custom_sample_orders", &self.p_custom_sample_orders)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMeshShaderFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
}
unsafe impl Send for PhysicalDeviceMeshShaderFeaturesNV {}
unsafe impl Sync for PhysicalDeviceMeshShaderFeaturesNV {}
impl default::Default for PhysicalDeviceMeshShaderFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            p_next: ptr::null_mut(),
            task_shader: Bool32::default(),
            mesh_shader: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMeshShaderFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMeshShaderFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("task_shader", &self.task_shader)
            .field("mesh_shader", &self.mesh_shader)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMeshShaderPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_draw_mesh_tasks_count: u32,
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3],
    pub max_task_total_memory_size: u32,
    pub max_task_output_count: u32,
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3],
    pub max_mesh_total_memory_size: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
}
unsafe impl Send for PhysicalDeviceMeshShaderPropertiesNV {}
unsafe impl Sync for PhysicalDeviceMeshShaderPropertiesNV {}
impl default::Default for PhysicalDeviceMeshShaderPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_draw_mesh_tasks_count: u32::default(),
            max_task_work_group_invocations: u32::default(),
            max_task_work_group_size: [u32::default(); 3],
            max_task_total_memory_size: u32::default(),
            max_task_output_count: u32::default(),
            max_mesh_work_group_invocations: u32::default(),
            max_mesh_work_group_size: [u32::default(); 3],
            max_mesh_total_memory_size: u32::default(),
            max_mesh_output_vertices: u32::default(),
            max_mesh_output_primitives: u32::default(),
            max_mesh_multiview_view_count: u32::default(),
            mesh_output_per_vertex_granularity: u32::default(),
            mesh_output_per_primitive_granularity: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMeshShaderPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMeshShaderPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_draw_mesh_tasks_count", &self.max_draw_mesh_tasks_count)
            .field("max_task_work_group_invocations", &self.max_task_work_group_invocations)
            .field("max_task_work_group_size", &self.max_task_work_group_size)
            .field("max_task_total_memory_size", &self.max_task_total_memory_size)
            .field("max_task_output_count", &self.max_task_output_count)
            .field("max_mesh_work_group_invocations", &self.max_mesh_work_group_invocations)
            .field("max_mesh_work_group_size", &self.max_mesh_work_group_size)
            .field("max_mesh_total_memory_size", &self.max_mesh_total_memory_size)
            .field("max_mesh_output_vertices", &self.max_mesh_output_vertices)
            .field("max_mesh_output_primitives", &self.max_mesh_output_primitives)
            .field("max_mesh_multiview_view_count", &self.max_mesh_multiview_view_count)
            .field(
                "mesh_output_per_vertex_granularity",
                &self.mesh_output_per_vertex_granularity,
            )
            .field(
                "mesh_output_per_primitive_granularity",
                &self.mesh_output_per_primitive_granularity,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DrawMeshTasksIndirectCommandNV {
    pub task_count: u32,
    pub first_task: u32,
}
impl default::Default for DrawMeshTasksIndirectCommandNV {
    fn default() -> Self {
        Self {
            task_count: u32::default(),
            first_task: u32::default(),
        }
    }
}
impl fmt::Debug for DrawMeshTasksIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawMeshTasksIndirectCommandNV")
            .field("task_count", &self.task_count)
            .field("first_task", &self.first_task)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
}
unsafe impl Send for RayTracingShaderGroupCreateInfoNV {}
unsafe impl Sync for RayTracingShaderGroupCreateInfoNV {}
impl default::Default for RayTracingShaderGroupCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
            p_next: ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
        }
    }
}
impl fmt::Debug for RayTracingShaderGroupCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingShaderGroupCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("general_shader", &self.general_shader)
            .field("closest_hit_shader", &self.closest_hit_shader)
            .field("any_hit_shader", &self.any_hit_shader)
            .field("intersection_shader", &self.intersection_shader)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingShaderGroupCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub p_shader_group_capture_replay_handle: *const c_void,
}
unsafe impl Send for RayTracingShaderGroupCreateInfoKHR {}
unsafe impl Sync for RayTracingShaderGroupCreateInfoKHR {}
impl default::Default for RayTracingShaderGroupCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
            p_next: ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
            p_shader_group_capture_replay_handle: ptr::null(),
        }
    }
}
impl fmt::Debug for RayTracingShaderGroupCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingShaderGroupCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("general_shader", &self.general_shader)
            .field("closest_hit_shader", &self.closest_hit_shader)
            .field("any_hit_shader", &self.any_hit_shader)
            .field("intersection_shader", &self.intersection_shader)
            .field(
                "p_shader_group_capture_replay_handle",
                &self.p_shader_group_capture_replay_handle,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoNV,
    pub max_recursion_depth: u32,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for RayTracingPipelineCreateInfoNV {}
unsafe impl Sync for RayTracingPipelineCreateInfoNV {}
impl default::Default for RayTracingPipelineCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ptr::null(),
            group_count: u32::default(),
            p_groups: ptr::null(),
            max_recursion_depth: u32::default(),
            layout: None,
            base_pipeline_handle: None,
            base_pipeline_index: i32::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field("max_recursion_depth", &self.max_recursion_depth)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoKHR,
    pub max_pipeline_ray_recursion_depth: u32,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR,
    pub p_library_interface: *const RayTracingPipelineInterfaceCreateInfoKHR,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for RayTracingPipelineCreateInfoKHR {}
unsafe impl Sync for RayTracingPipelineCreateInfoKHR {}
impl default::Default for RayTracingPipelineCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ptr::null(),
            group_count: u32::default(),
            p_groups: ptr::null(),
            max_pipeline_ray_recursion_depth: u32::default(),
            p_library_info: ptr::null(),
            p_library_interface: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: None,
            base_pipeline_handle: None,
            base_pipeline_index: i32::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field(
                "max_pipeline_ray_recursion_depth",
                &self.max_pipeline_ray_recursion_depth,
            )
            .field("p_library_info", &self.p_library_info)
            .field("p_library_interface", &self.p_library_interface)
            .field("p_dynamic_state", &self.p_dynamic_state)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryTrianglesNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: Option<Buffer>,
    pub vertex_offset: DeviceSize,
    pub vertex_count: u32,
    pub vertex_stride: DeviceSize,
    pub vertex_format: Format,
    pub index_data: Option<Buffer>,
    pub index_offset: DeviceSize,
    pub index_count: u32,
    pub index_type: IndexType,
    /// Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
    pub transform_data: Option<Buffer>,
    pub transform_offset: DeviceSize,
}
unsafe impl Send for GeometryTrianglesNV {}
unsafe impl Sync for GeometryTrianglesNV {}
impl default::Default for GeometryTrianglesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_TRIANGLES_NV,
            p_next: ptr::null(),
            vertex_data: None,
            vertex_offset: DeviceSize::default(),
            vertex_count: u32::default(),
            vertex_stride: DeviceSize::default(),
            vertex_format: Format::default(),
            index_data: None,
            index_offset: DeviceSize::default(),
            index_count: u32::default(),
            index_type: IndexType::default(),
            transform_data: None,
            transform_offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for GeometryTrianglesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryTrianglesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &self.vertex_data)
            .field("vertex_offset", &self.vertex_offset)
            .field("vertex_count", &self.vertex_count)
            .field("vertex_stride", &self.vertex_stride)
            .field("vertex_format", &self.vertex_format)
            .field("index_data", &self.index_data)
            .field("index_offset", &self.index_offset)
            .field("index_count", &self.index_count)
            .field("index_type", &self.index_type)
            .field("transform_data", &self.transform_data)
            .field("transform_offset", &self.transform_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryAABBNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aabb_data: Option<Buffer>,
    pub num_aab_bs: u32,
    /// Stride in bytes between AABBs
    pub stride: u32,
    /// Offset in bytes of the first AABB in aabbData
    pub offset: DeviceSize,
}
unsafe impl Send for GeometryAABBNV {}
unsafe impl Sync for GeometryAABBNV {}
impl default::Default for GeometryAABBNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_AABB_NV,
            p_next: ptr::null(),
            aabb_data: None,
            num_aab_bs: u32::default(),
            stride: u32::default(),
            offset: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for GeometryAABBNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryAABBNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("aabb_data", &self.aabb_data)
            .field("num_aab_bs", &self.num_aab_bs)
            .field("stride", &self.stride)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryDataNV {
    pub triangles: GeometryTrianglesNV,
    pub aabbs: GeometryAABBNV,
}
impl default::Default for GeometryDataNV {
    fn default() -> Self {
        Self {
            triangles: GeometryTrianglesNV::default(),
            aabbs: GeometryAABBNV::default(),
        }
    }
}
impl fmt::Debug for GeometryDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryDataNV")
            .field("triangles", &self.triangles)
            .field("aabbs", &self.aabbs)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: GeometryDataNV,
    pub flags: GeometryFlagsKHR,
}
unsafe impl Send for GeometryNV {}
unsafe impl Sync for GeometryNV {}
impl default::Default for GeometryNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_NV,
            p_next: ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: GeometryDataNV::default(),
            flags: GeometryFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for GeometryNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &self.geometry)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeNV,
    pub flags: BuildAccelerationStructureFlagsNV,
    pub instance_count: u32,
    pub geometry_count: u32,
    pub p_geometries: *const GeometryNV,
}
unsafe impl Send for AccelerationStructureInfoNV {}
unsafe impl Sync for AccelerationStructureInfoNV {}
impl default::Default for AccelerationStructureInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_INFO_NV,
            p_next: ptr::null(),
            ty: AccelerationStructureTypeNV::default(),
            flags: BuildAccelerationStructureFlagsNV::default(),
            instance_count: u32::default(),
            geometry_count: u32::default(),
            p_geometries: ptr::null(),
        }
    }
}
impl fmt::Debug for AccelerationStructureInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("instance_count", &self.instance_count)
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compacted_size: DeviceSize,
    pub info: AccelerationStructureInfoNV,
}
unsafe impl Send for AccelerationStructureCreateInfoNV {}
unsafe impl Sync for AccelerationStructureCreateInfoNV {}
impl default::Default for AccelerationStructureCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            p_next: ptr::null(),
            compacted_size: DeviceSize::default(),
            info: AccelerationStructureInfoNV::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compacted_size", &self.compacted_size)
            .field("info", &self.info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindAccelerationStructureMemoryInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: Option<AccelerationStructureNV>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
unsafe impl Send for BindAccelerationStructureMemoryInfoNV {}
unsafe impl Sync for BindAccelerationStructureMemoryInfoNV {}
impl default::Default for BindAccelerationStructureMemoryInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
            p_next: ptr::null(),
            acceleration_structure: None,
            memory: None,
            memory_offset: DeviceSize::default(),
            device_index_count: u32::default(),
            p_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BindAccelerationStructureMemoryInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindAccelerationStructureMemoryInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetAccelerationStructureKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureKHR,
}
unsafe impl Send for WriteDescriptorSetAccelerationStructureKHR {}
unsafe impl Sync for WriteDescriptorSetAccelerationStructureKHR {}
impl default::Default for WriteDescriptorSetAccelerationStructureKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            p_next: ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetAccelerationStructureKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetAccelerationStructureKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_count", &self.acceleration_structure_count)
            .field("p_acceleration_structures", &self.p_acceleration_structures)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetAccelerationStructureNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureNV,
}
unsafe impl Send for WriteDescriptorSetAccelerationStructureNV {}
unsafe impl Sync for WriteDescriptorSetAccelerationStructureNV {}
impl default::Default for WriteDescriptorSetAccelerationStructureNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
            p_next: ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetAccelerationStructureNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetAccelerationStructureNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_count", &self.acceleration_structure_count)
            .field("p_acceleration_structures", &self.p_acceleration_structures)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureMemoryRequirementsTypeNV,
    pub acceleration_structure: Option<AccelerationStructureNV>,
}
unsafe impl Send for AccelerationStructureMemoryRequirementsInfoNV {}
unsafe impl Sync for AccelerationStructureMemoryRequirementsInfoNV {}
impl default::Default for AccelerationStructureMemoryRequirementsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: ptr::null(),
            ty: AccelerationStructureMemoryRequirementsTypeNV::default(),
            acceleration_structure: None,
        }
    }
}
impl fmt::Debug for AccelerationStructureMemoryRequirementsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMemoryRequirementsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("acceleration_structure", &self.acceleration_structure)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub acceleration_structure: Bool32,
    pub acceleration_structure_capture_replay: Bool32,
    pub acceleration_structure_indirect_build: Bool32,
    pub acceleration_structure_host_commands: Bool32,
    pub descriptor_binding_acceleration_structure_update_after_bind: Bool32,
}
unsafe impl Send for PhysicalDeviceAccelerationStructureFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceAccelerationStructureFeaturesKHR {}
impl default::Default for PhysicalDeviceAccelerationStructureFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            acceleration_structure: Bool32::default(),
            acceleration_structure_capture_replay: Bool32::default(),
            acceleration_structure_indirect_build: Bool32::default(),
            acceleration_structure_host_commands: Bool32::default(),
            descriptor_binding_acceleration_structure_update_after_bind: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceAccelerationStructureFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceAccelerationStructureFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .field(
                "acceleration_structure_capture_replay",
                &self.acceleration_structure_capture_replay,
            )
            .field(
                "acceleration_structure_indirect_build",
                &self.acceleration_structure_indirect_build,
            )
            .field(
                "acceleration_structure_host_commands",
                &self.acceleration_structure_host_commands,
            )
            .field(
                "descriptor_binding_acceleration_structure_update_after_bind",
                &self.descriptor_binding_acceleration_structure_update_after_bind,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_pipeline: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect: Bool32,
    pub ray_traversal_primitive_culling: Bool32,
}
unsafe impl Send for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
impl default::Default for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            ray_tracing_pipeline: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32::default(),
            ray_tracing_pipeline_trace_rays_indirect: Bool32::default(),
            ray_traversal_primitive_culling: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPipelineFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_tracing_pipeline", &self.ray_tracing_pipeline)
            .field(
                "ray_tracing_pipeline_shader_group_handle_capture_replay",
                &self.ray_tracing_pipeline_shader_group_handle_capture_replay,
            )
            .field(
                "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed",
                &self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            )
            .field(
                "ray_tracing_pipeline_trace_rays_indirect",
                &self.ray_tracing_pipeline_trace_rays_indirect,
            )
            .field("ray_traversal_primitive_culling", &self.ray_traversal_primitive_culling)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_query: Bool32,
}
unsafe impl Send for PhysicalDeviceRayQueryFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceRayQueryFeaturesKHR {}
impl default::Default for PhysicalDeviceRayQueryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            ray_query: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayQueryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayQueryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_query", &self.ray_query)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_primitive_count: u64,
    pub max_per_stage_descriptor_acceleration_structures: u32,
    pub max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    pub max_descriptor_set_acceleration_structures: u32,
    pub max_descriptor_set_update_after_bind_acceleration_structures: u32,
    pub min_acceleration_structure_scratch_offset_alignment: u32,
}
unsafe impl Send for PhysicalDeviceAccelerationStructurePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceAccelerationStructurePropertiesKHR {}
impl default::Default for PhysicalDeviceAccelerationStructurePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_primitive_count: u64::default(),
            max_per_stage_descriptor_acceleration_structures: u32::default(),
            max_per_stage_descriptor_update_after_bind_acceleration_structures: u32::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
            max_descriptor_set_update_after_bind_acceleration_structures: u32::default(),
            min_acceleration_structure_scratch_offset_alignment: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceAccelerationStructurePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceAccelerationStructurePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_geometry_count", &self.max_geometry_count)
            .field("max_instance_count", &self.max_instance_count)
            .field("max_primitive_count", &self.max_primitive_count)
            .field(
                "max_per_stage_descriptor_acceleration_structures",
                &self.max_per_stage_descriptor_acceleration_structures,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_acceleration_structures",
                &self.max_per_stage_descriptor_update_after_bind_acceleration_structures,
            )
            .field(
                "max_descriptor_set_acceleration_structures",
                &self.max_descriptor_set_acceleration_structures,
            )
            .field(
                "max_descriptor_set_update_after_bind_acceleration_structures",
                &self.max_descriptor_set_update_after_bind_acceleration_structures,
            )
            .field(
                "min_acceleration_structure_scratch_offset_alignment",
                &self.min_acceleration_structure_scratch_offset_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_ray_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub shader_group_handle_capture_replay_size: u32,
    pub max_ray_dispatch_invocation_count: u32,
    pub shader_group_handle_alignment: u32,
    pub max_ray_hit_attribute_size: u32,
}
unsafe impl Send for PhysicalDeviceRayTracingPipelinePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceRayTracingPipelinePropertiesKHR {}
impl default::Default for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_ray_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            shader_group_handle_capture_replay_size: u32::default(),
            max_ray_dispatch_invocation_count: u32::default(),
            shader_group_handle_alignment: u32::default(),
            max_ray_hit_attribute_size: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPipelinePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_group_handle_size", &self.shader_group_handle_size)
            .field("max_ray_recursion_depth", &self.max_ray_recursion_depth)
            .field("max_shader_group_stride", &self.max_shader_group_stride)
            .field("shader_group_base_alignment", &self.shader_group_base_alignment)
            .field(
                "shader_group_handle_capture_replay_size",
                &self.shader_group_handle_capture_replay_size,
            )
            .field(
                "max_ray_dispatch_invocation_count",
                &self.max_ray_dispatch_invocation_count,
            )
            .field("shader_group_handle_alignment", &self.shader_group_handle_alignment)
            .field("max_ray_hit_attribute_size", &self.max_ray_hit_attribute_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_triangle_count: u64,
    pub max_descriptor_set_acceleration_structures: u32,
}
unsafe impl Send for PhysicalDeviceRayTracingPropertiesNV {}
unsafe impl Sync for PhysicalDeviceRayTracingPropertiesNV {}
impl default::Default for PhysicalDeviceRayTracingPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_triangle_count: u64::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_group_handle_size", &self.shader_group_handle_size)
            .field("max_recursion_depth", &self.max_recursion_depth)
            .field("max_shader_group_stride", &self.max_shader_group_stride)
            .field("shader_group_base_alignment", &self.shader_group_base_alignment)
            .field("max_geometry_count", &self.max_geometry_count)
            .field("max_instance_count", &self.max_instance_count)
            .field("max_triangle_count", &self.max_triangle_count)
            .field(
                "max_descriptor_set_acceleration_structures",
                &self.max_descriptor_set_acceleration_structures,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct StridedDeviceAddressRegionKHR {
    pub device_address: DeviceAddress,
    pub stride: DeviceSize,
    pub size: DeviceSize,
}
impl default::Default for StridedDeviceAddressRegionKHR {
    fn default() -> Self {
        Self {
            device_address: DeviceAddress::default(),
            stride: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for StridedDeviceAddressRegionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("StridedDeviceAddressRegionKHR")
            .field("device_address", &self.device_address)
            .field("stride", &self.stride)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct TraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl default::Default for TraceRaysIndirectCommandKHR {
    fn default() -> Self {
        Self {
            width: u32::default(),
            height: u32::default(),
            depth: u32::default(),
        }
    }
}
impl fmt::Debug for TraceRaysIndirectCommandKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TraceRaysIndirectCommandKHR")
            .field("width", &self.width)
            .field("height", &self.height)
            .field("depth", &self.depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DrmFormatModifierPropertiesListEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierPropertiesEXT,
}
unsafe impl Send for DrmFormatModifierPropertiesListEXT {}
unsafe impl Sync for DrmFormatModifierPropertiesListEXT {}
impl default::Default for DrmFormatModifierPropertiesListEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierPropertiesListEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesListEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field(
                "p_drm_format_modifier_properties",
                &self.p_drm_format_modifier_properties,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DrmFormatModifierPropertiesEXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags,
}
impl default::Default for DrmFormatModifierPropertiesEXT {
    fn default() -> Self {
        Self {
            drm_format_modifier: u64::default(),
            drm_format_modifier_plane_count: u32::default(),
            drm_format_modifier_tiling_features: FormatFeatureFlags::default(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesEXT")
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field(
                "drm_format_modifier_tiling_features",
                &self.drm_format_modifier_tiling_features,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
unsafe impl Send for PhysicalDeviceImageDrmFormatModifierInfoEXT {}
unsafe impl Sync for PhysicalDeviceImageDrmFormatModifierInfoEXT {}
impl default::Default for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier: u64::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageDrmFormatModifierInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierListCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifiers: *const u64,
}
unsafe impl Send for ImageDrmFormatModifierListCreateInfoEXT {}
unsafe impl Sync for ImageDrmFormatModifierListCreateInfoEXT {}
impl default::Default for ImageDrmFormatModifierListCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifiers: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierListCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierListCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field("p_drm_format_modifiers", &self.p_drm_format_modifiers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub p_plane_layouts: *const SubresourceLayout,
}
unsafe impl Send for ImageDrmFormatModifierExplicitCreateInfoEXT {}
unsafe impl Sync for ImageDrmFormatModifierExplicitCreateInfoEXT {}
impl default::Default for ImageDrmFormatModifierExplicitCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier: u64::default(),
            drm_format_modifier_plane_count: u32::default(),
            p_plane_layouts: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierExplicitCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierExplicitCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field("p_plane_layouts", &self.p_plane_layouts)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier: u64,
}
unsafe impl Send for ImageDrmFormatModifierPropertiesEXT {}
unsafe impl Sync for ImageDrmFormatModifierPropertiesEXT {}
impl default::Default for ImageDrmFormatModifierPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier: u64::default(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageStencilUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stencil_usage: ImageUsageFlags,
}
unsafe impl Send for ImageStencilUsageCreateInfo {}
unsafe impl Sync for ImageStencilUsageCreateInfo {}
impl default::Default for ImageStencilUsageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO,
            p_next: ptr::null(),
            stencil_usage: ImageUsageFlags::default(),
        }
    }
}
impl fmt::Debug for ImageStencilUsageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageStencilUsageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_usage", &self.stencil_usage)
            .finish()
    }
}
pub type ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryOverallocationCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub overallocation_behavior: MemoryOverallocationBehaviorAMD,
}
unsafe impl Send for DeviceMemoryOverallocationCreateInfoAMD {}
unsafe impl Sync for DeviceMemoryOverallocationCreateInfoAMD {}
impl default::Default for DeviceMemoryOverallocationCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            p_next: ptr::null(),
            overallocation_behavior: MemoryOverallocationBehaviorAMD::default(),
        }
    }
}
impl fmt::Debug for DeviceMemoryOverallocationCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryOverallocationCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("overallocation_behavior", &self.overallocation_behavior)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map: Bool32,
    pub fragment_density_map_dynamic: Bool32,
    pub fragment_density_map_non_subsampled_images: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
impl default::Default for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_density_map: Bool32::default(),
            fragment_density_map_dynamic: Bool32::default(),
            fragment_density_map_non_subsampled_images: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map", &self.fragment_density_map)
            .field("fragment_density_map_dynamic", &self.fragment_density_map_dynamic)
            .field(
                "fragment_density_map_non_subsampled_images",
                &self.fragment_density_map_non_subsampled_images,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_deferred: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
impl default::Default for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_density_map_deferred: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMap2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map_deferred", &self.fragment_density_map_deferred)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_density_texel_size: Extent2D,
    pub max_fragment_density_texel_size: Extent2D,
    pub fragment_density_invocations: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapPropertiesEXT {}
impl default::Default for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            min_fragment_density_texel_size: Extent2D::default(),
            max_fragment_density_texel_size: Extent2D::default(),
            fragment_density_invocations: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_fragment_density_texel_size", &self.min_fragment_density_texel_size)
            .field("max_fragment_density_texel_size", &self.max_fragment_density_texel_size)
            .field("fragment_density_invocations", &self.fragment_density_invocations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subsampled_loads: Bool32,
    pub subsampled_coarse_reconstruction_early_access: Bool32,
    pub max_subsampled_array_layers: u32,
    pub max_descriptor_set_subsampled_samplers: u32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
impl default::Default for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            subsampled_loads: Bool32::default(),
            subsampled_coarse_reconstruction_early_access: Bool32::default(),
            max_subsampled_array_layers: u32::default(),
            max_descriptor_set_subsampled_samplers: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMap2PropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subsampled_loads", &self.subsampled_loads)
            .field(
                "subsampled_coarse_reconstruction_early_access",
                &self.subsampled_coarse_reconstruction_early_access,
            )
            .field("max_subsampled_array_layers", &self.max_subsampled_array_layers)
            .field(
                "max_descriptor_set_subsampled_samplers",
                &self.max_descriptor_set_subsampled_samplers,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassFragmentDensityMapCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_map_attachment: AttachmentReference,
}
unsafe impl Send for RenderPassFragmentDensityMapCreateInfoEXT {}
unsafe impl Sync for RenderPassFragmentDensityMapCreateInfoEXT {}
impl default::Default for RenderPassFragmentDensityMapCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            p_next: ptr::null(),
            fragment_density_map_attachment: AttachmentReference::default(),
        }
    }
}
impl fmt::Debug for RenderPassFragmentDensityMapCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassFragmentDensityMapCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map_attachment", &self.fragment_density_map_attachment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceScalarBlockLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub scalar_block_layout: Bool32,
}
unsafe impl Send for PhysicalDeviceScalarBlockLayoutFeatures {}
unsafe impl Sync for PhysicalDeviceScalarBlockLayoutFeatures {}
impl default::Default for PhysicalDeviceScalarBlockLayoutFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            p_next: ptr::null_mut(),
            scalar_block_layout: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceScalarBlockLayoutFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceScalarBlockLayoutFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("scalar_block_layout", &self.scalar_block_layout)
            .finish()
    }
}
pub type PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceProtectedCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Represents if surface can be protected
    pub supports_protected: Bool32,
}
unsafe impl Send for SurfaceProtectedCapabilitiesKHR {}
unsafe impl Sync for SurfaceProtectedCapabilitiesKHR {}
impl default::Default for SurfaceProtectedCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR,
            p_next: ptr::null(),
            supports_protected: Bool32::default(),
        }
    }
}
impl fmt::Debug for SurfaceProtectedCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceProtectedCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supports_protected", &self.supports_protected)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub uniform_buffer_standard_layout: Bool32,
}
unsafe impl Send for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
unsafe impl Sync for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
impl default::Default for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            p_next: ptr::null_mut(),
            uniform_buffer_standard_layout: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceUniformBufferStandardLayoutFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("uniform_buffer_standard_layout", &self.uniform_buffer_standard_layout)
            .finish()
    }
}
pub type PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_enable: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthClipEnableFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDepthClipEnableFeaturesEXT {}
impl default::Default for PhysicalDeviceDepthClipEnableFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            depth_clip_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthClipEnableFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthClipEnableFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_clip_enable", &self.depth_clip_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Reserved
    pub flags: PipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depth_clip_enable: Bool32,
}
unsafe impl Send for PipelineRasterizationDepthClipStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationDepthClipStateCreateInfoEXT {}
impl default::Default for PipelineRasterizationDepthClipStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: PipelineRasterizationDepthClipStateCreateFlagsEXT::default(),
            depth_clip_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationDepthClipStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationDepthClipStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_clip_enable", &self.depth_clip_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub heap_budget: [DeviceSize; MAX_MEMORY_HEAPS],
    pub heap_usage: [DeviceSize; MAX_MEMORY_HEAPS],
}
unsafe impl Send for PhysicalDeviceMemoryBudgetPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceMemoryBudgetPropertiesEXT {}
impl default::Default for PhysicalDeviceMemoryBudgetPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            heap_budget: [DeviceSize::default(); MAX_MEMORY_HEAPS],
            heap_usage: [DeviceSize::default(); MAX_MEMORY_HEAPS],
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryBudgetPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryBudgetPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("heap_budget", &self.heap_budget)
            .field("heap_usage", &self.heap_usage)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_priority: Bool32,
}
unsafe impl Send for PhysicalDeviceMemoryPriorityFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceMemoryPriorityFeaturesEXT {}
impl default::Default for PhysicalDeviceMemoryPriorityFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            memory_priority: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryPriorityFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryPriorityFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_priority", &self.memory_priority)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryPriorityAllocateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub priority: f32,
}
unsafe impl Send for MemoryPriorityAllocateInfoEXT {}
unsafe impl Sync for MemoryPriorityAllocateInfoEXT {}
impl default::Default for MemoryPriorityAllocateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            p_next: ptr::null(),
            priority: f32::default(),
        }
    }
}
impl fmt::Debug for MemoryPriorityAllocateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryPriorityAllocateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("priority", &self.priority)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pageable_device_local_memory: Bool32,
}
unsafe impl Send for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
impl default::Default for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            pageable_device_local_memory: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pageable_device_local_memory", &self.pageable_device_local_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBufferDeviceAddressFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
unsafe impl Send for PhysicalDeviceBufferDeviceAddressFeatures {}
unsafe impl Sync for PhysicalDeviceBufferDeviceAddressFeatures {}
impl default::Default for PhysicalDeviceBufferDeviceAddressFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            p_next: ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBufferDeviceAddressFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBufferDeviceAddressFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .finish()
    }
}
pub type PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
unsafe impl Send for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
impl default::Default for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBufferDeviceAddressFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .finish()
    }
}
pub type PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferDeviceAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
}
unsafe impl Send for BufferDeviceAddressInfo {}
unsafe impl Sync for BufferDeviceAddressInfo {}
impl default::Default for BufferDeviceAddressInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_DEVICE_ADDRESS_INFO,
            p_next: ptr::null(),
            buffer: None,
        }
    }
}
impl fmt::Debug for BufferDeviceAddressInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferDeviceAddressInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
pub type BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferOpaqueCaptureAddressCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
unsafe impl Send for BufferOpaqueCaptureAddressCreateInfo {}
unsafe impl Sync for BufferOpaqueCaptureAddressCreateInfo {}
impl default::Default for BufferOpaqueCaptureAddressCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            p_next: ptr::null(),
            opaque_capture_address: u64::default(),
        }
    }
}
impl fmt::Debug for BufferOpaqueCaptureAddressCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferOpaqueCaptureAddressCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("opaque_capture_address", &self.opaque_capture_address)
            .finish()
    }
}
pub type BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferDeviceAddressCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_address: DeviceAddress,
}
unsafe impl Send for BufferDeviceAddressCreateInfoEXT {}
unsafe impl Sync for BufferDeviceAddressCreateInfoEXT {}
impl default::Default for BufferDeviceAddressCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            p_next: ptr::null(),
            device_address: DeviceAddress::default(),
        }
    }
}
impl fmt::Debug for BufferDeviceAddressCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferDeviceAddressCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_address", &self.device_address)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageViewImageFormatInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_view_type: ImageViewType,
}
unsafe impl Send for PhysicalDeviceImageViewImageFormatInfoEXT {}
unsafe impl Sync for PhysicalDeviceImageViewImageFormatInfoEXT {}
impl default::Default for PhysicalDeviceImageViewImageFormatInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            p_next: ptr::null_mut(),
            image_view_type: ImageViewType::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageViewImageFormatInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageViewImageFormatInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view_type", &self.image_view_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FilterCubicImageViewImageFormatPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
    pub filter_cubic: Bool32,
    /// The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
    pub filter_cubic_minmax: Bool32,
}
unsafe impl Send for FilterCubicImageViewImageFormatPropertiesEXT {}
unsafe impl Sync for FilterCubicImageViewImageFormatPropertiesEXT {}
impl default::Default for FilterCubicImageViewImageFormatPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            filter_cubic: Bool32::default(),
            filter_cubic_minmax: Bool32::default(),
        }
    }
}
impl fmt::Debug for FilterCubicImageViewImageFormatPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FilterCubicImageViewImageFormatPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("filter_cubic", &self.filter_cubic)
            .field("filter_cubic_minmax", &self.filter_cubic_minmax)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImagelessFramebufferFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub imageless_framebuffer: Bool32,
}
unsafe impl Send for PhysicalDeviceImagelessFramebufferFeatures {}
unsafe impl Sync for PhysicalDeviceImagelessFramebufferFeatures {}
impl default::Default for PhysicalDeviceImagelessFramebufferFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            p_next: ptr::null_mut(),
            imageless_framebuffer: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImagelessFramebufferFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImagelessFramebufferFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("imageless_framebuffer", &self.imageless_framebuffer)
            .finish()
    }
}
pub type PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferAttachmentsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_image_info_count: u32,
    pub p_attachment_image_infos: *const FramebufferAttachmentImageInfo,
}
unsafe impl Send for FramebufferAttachmentsCreateInfo {}
unsafe impl Sync for FramebufferAttachmentsCreateInfo {}
impl default::Default for FramebufferAttachmentsCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            p_next: ptr::null(),
            attachment_image_info_count: u32::default(),
            p_attachment_image_infos: ptr::null(),
        }
    }
}
impl fmt::Debug for FramebufferAttachmentsCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferAttachmentsCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_image_info_count", &self.attachment_image_info_count)
            .field("p_attachment_image_infos", &self.p_attachment_image_infos)
            .finish()
    }
}
pub type FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferAttachmentImageInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image creation flags
    pub flags: ImageCreateFlags,
    /// Image usage flags
    pub usage: ImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layer_count: u32,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
unsafe impl Send for FramebufferAttachmentImageInfo {}
unsafe impl Sync for FramebufferAttachmentImageInfo {}
impl default::Default for FramebufferAttachmentImageInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
            p_next: ptr::null(),
            flags: ImageCreateFlags::default(),
            usage: ImageUsageFlags::default(),
            width: u32::default(),
            height: u32::default(),
            layer_count: u32::default(),
            view_format_count: u32::default(),
            p_view_formats: ptr::null(),
        }
    }
}
impl fmt::Debug for FramebufferAttachmentImageInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferAttachmentImageInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("usage", &self.usage)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("layer_count", &self.layer_count)
            .field("view_format_count", &self.view_format_count)
            .field("p_view_formats", &self.p_view_formats)
            .finish()
    }
}
pub type FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassAttachmentBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
}
unsafe impl Send for RenderPassAttachmentBeginInfo {}
unsafe impl Sync for RenderPassAttachmentBeginInfo {}
impl default::Default for RenderPassAttachmentBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            p_next: ptr::null(),
            attachment_count: u32::default(),
            p_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassAttachmentBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassAttachmentBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .finish()
    }
}
pub type RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texture_compression_astc_hdr: Bool32,
}
unsafe impl Send for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {}
impl default::Default for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
            p_next: ptr::null_mut(),
            texture_compression_astc_hdr: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("texture_compression_astc_hdr", &self.texture_compression_astc_hdr)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
}
unsafe impl Send for PhysicalDeviceCooperativeMatrixFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCooperativeMatrixFeaturesNV {}
impl default::Default for PhysicalDeviceCooperativeMatrixFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            p_next: ptr::null_mut(),
            cooperative_matrix: Bool32::default(),
            cooperative_matrix_robust_buffer_access: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCooperativeMatrixFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCooperativeMatrixFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("cooperative_matrix", &self.cooperative_matrix)
            .field(
                "cooperative_matrix_robust_buffer_access",
                &self.cooperative_matrix_robust_buffer_access,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
}
unsafe impl Send for PhysicalDeviceCooperativeMatrixPropertiesNV {}
unsafe impl Sync for PhysicalDeviceCooperativeMatrixPropertiesNV {}
impl default::Default for PhysicalDeviceCooperativeMatrixPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            cooperative_matrix_supported_stages: ShaderStageFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCooperativeMatrixPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCooperativeMatrixPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "cooperative_matrix_supported_stages",
                &self.cooperative_matrix_supported_stages,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub m_size: u32,
    pub n_size: u32,
    pub k_size: u32,
    pub a_type: ComponentTypeNV,
    pub b_type: ComponentTypeNV,
    pub c_type: ComponentTypeNV,
    pub d_type: ComponentTypeNV,
    pub scope: ScopeNV,
}
unsafe impl Send for CooperativeMatrixPropertiesNV {}
unsafe impl Sync for CooperativeMatrixPropertiesNV {}
impl default::Default for CooperativeMatrixPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            m_size: u32::default(),
            n_size: u32::default(),
            k_size: u32::default(),
            a_type: ComponentTypeNV::default(),
            b_type: ComponentTypeNV::default(),
            c_type: ComponentTypeNV::default(),
            d_type: ComponentTypeNV::default(),
            scope: ScopeNV::default(),
        }
    }
}
impl fmt::Debug for CooperativeMatrixPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CooperativeMatrixPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("m_size", &self.m_size)
            .field("n_size", &self.n_size)
            .field("k_size", &self.k_size)
            .field("a_type", &self.a_type)
            .field("b_type", &self.b_type)
            .field("c_type", &self.c_type)
            .field("d_type", &self.d_type)
            .field("scope", &self.scope)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr_image_arrays: Bool32,
}
unsafe impl Send for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
impl default::Default for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            ycbcr_image_arrays: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceYcbcrImageArraysFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ycbcr_image_arrays", &self.ycbcr_image_arrays)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewHandleInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub descriptor_type: DescriptorType,
    pub sampler: Option<Sampler>,
}
unsafe impl Send for ImageViewHandleInfoNVX {}
unsafe impl Sync for ImageViewHandleInfoNVX {}
impl default::Default for ImageViewHandleInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_HANDLE_INFO_NVX,
            p_next: ptr::null(),
            image_view: None,
            descriptor_type: DescriptorType::default(),
            sampler: None,
        }
    }
}
impl fmt::Debug for ImageViewHandleInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewHandleInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("descriptor_type", &self.descriptor_type)
            .field("sampler", &self.sampler)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewAddressPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
}
unsafe impl Send for ImageViewAddressPropertiesNVX {}
unsafe impl Sync for ImageViewAddressPropertiesNVX {}
impl default::Default for ImageViewAddressPropertiesNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
            p_next: ptr::null_mut(),
            device_address: DeviceAddress::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for ImageViewAddressPropertiesNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewAddressPropertiesNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_address", &self.device_address)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCreationFeedbackEXT {
    pub flags: PipelineCreationFeedbackFlagsEXT,
    pub duration: u64,
}
impl default::Default for PipelineCreationFeedbackEXT {
    fn default() -> Self {
        Self {
            flags: PipelineCreationFeedbackFlagsEXT::default(),
            duration: u64::default(),
        }
    }
}
impl fmt::Debug for PipelineCreationFeedbackEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCreationFeedbackEXT")
            .field("flags", &self.flags)
            .field("duration", &self.duration)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCreationFeedbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Output pipeline creation feedback.
    pub p_pipeline_creation_feedback: *mut PipelineCreationFeedbackEXT,
    pub pipeline_stage_creation_feedback_count: u32,
    /// One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
    pub p_pipeline_stage_creation_feedbacks: *mut PipelineCreationFeedbackEXT,
}
unsafe impl Send for PipelineCreationFeedbackCreateInfoEXT {}
unsafe impl Sync for PipelineCreationFeedbackCreateInfoEXT {}
impl default::Default for PipelineCreationFeedbackCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            p_pipeline_creation_feedback: ptr::null_mut(),
            pipeline_stage_creation_feedback_count: u32::default(),
            p_pipeline_stage_creation_feedbacks: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PipelineCreationFeedbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCreationFeedbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_pipeline_creation_feedback", &self.p_pipeline_creation_feedback)
            .field(
                "pipeline_stage_creation_feedback_count",
                &self.pipeline_stage_creation_feedback_count,
            )
            .field(
                "p_pipeline_stage_creation_feedbacks",
                &self.p_pipeline_stage_creation_feedbacks,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFullScreenExclusiveInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive: FullScreenExclusiveEXT,
}
unsafe impl Send for SurfaceFullScreenExclusiveInfoEXT {}
unsafe impl Sync for SurfaceFullScreenExclusiveInfoEXT {}
impl default::Default for SurfaceFullScreenExclusiveInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            p_next: ptr::null_mut(),
            full_screen_exclusive: FullScreenExclusiveEXT::default(),
        }
    }
}
impl fmt::Debug for SurfaceFullScreenExclusiveInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFullScreenExclusiveInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("full_screen_exclusive", &self.full_screen_exclusive)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFullScreenExclusiveWin32InfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub hmonitor: HMONITOR,
}
unsafe impl Send for SurfaceFullScreenExclusiveWin32InfoEXT {}
unsafe impl Sync for SurfaceFullScreenExclusiveWin32InfoEXT {}
impl default::Default for SurfaceFullScreenExclusiveWin32InfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            p_next: ptr::null(),
            hmonitor: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for SurfaceFullScreenExclusiveWin32InfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFullScreenExclusiveWin32InfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("hmonitor", &self.hmonitor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive_supported: Bool32,
}
unsafe impl Send for SurfaceCapabilitiesFullScreenExclusiveEXT {}
unsafe impl Sync for SurfaceCapabilitiesFullScreenExclusiveEXT {}
impl default::Default for SurfaceCapabilitiesFullScreenExclusiveEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            p_next: ptr::null_mut(),
            full_screen_exclusive_supported: Bool32::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilitiesFullScreenExclusiveEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilitiesFullScreenExclusiveEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("full_screen_exclusive_supported", &self.full_screen_exclusive_supported)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePerformanceQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// performance counters supported in query pools
    pub performance_counter_query_pools: Bool32,
    /// performance counters from multiple query pools can be accessed in the same primary command buffer
    pub performance_counter_multiple_query_pools: Bool32,
}
unsafe impl Send for PhysicalDevicePerformanceQueryFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePerformanceQueryFeaturesKHR {}
impl default::Default for PhysicalDevicePerformanceQueryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            performance_counter_query_pools: Bool32::default(),
            performance_counter_multiple_query_pools: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePerformanceQueryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePerformanceQueryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("performance_counter_query_pools", &self.performance_counter_query_pools)
            .field(
                "performance_counter_multiple_query_pools",
                &self.performance_counter_multiple_query_pools,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePerformanceQueryPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
    pub allow_command_buffer_query_copies: Bool32,
}
unsafe impl Send for PhysicalDevicePerformanceQueryPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePerformanceQueryPropertiesKHR {}
impl default::Default for PhysicalDevicePerformanceQueryPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            allow_command_buffer_query_copies: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePerformanceQueryPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePerformanceQueryPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "allow_command_buffer_query_copies",
                &self.allow_command_buffer_query_copies,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceCounterKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub unit: PerformanceCounterUnitKHR,
    pub scope: PerformanceCounterScopeKHR,
    pub storage: PerformanceCounterStorageKHR,
    pub uuid: [u8; UUID_SIZE],
}
unsafe impl Send for PerformanceCounterKHR {}
unsafe impl Sync for PerformanceCounterKHR {}
impl default::Default for PerformanceCounterKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_COUNTER_KHR,
            p_next: ptr::null_mut(),
            unit: PerformanceCounterUnitKHR::default(),
            scope: PerformanceCounterScopeKHR::default(),
            storage: PerformanceCounterStorageKHR::default(),
            uuid: [u8::default(); UUID_SIZE],
        }
    }
}
impl fmt::Debug for PerformanceCounterKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("unit", &self.unit)
            .field("scope", &self.scope)
            .field("storage", &self.storage)
            .field("uuid", &self.uuid)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceCounterDescriptionKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: PerformanceCounterDescriptionFlagsKHR,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub category: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
unsafe impl Send for PerformanceCounterDescriptionKHR {}
unsafe impl Sync for PerformanceCounterDescriptionKHR {}
impl default::Default for PerformanceCounterDescriptionKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR,
            p_next: ptr::null_mut(),
            flags: PerformanceCounterDescriptionFlagsKHR::default(),
            name: [c_char::default(); MAX_DESCRIPTION_SIZE],
            category: [c_char::default(); MAX_DESCRIPTION_SIZE],
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
        }
    }
}
impl fmt::Debug for PerformanceCounterDescriptionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterDescriptionKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("category", &unsafe { CStr::from_ptr(self.category.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolPerformanceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub counter_index_count: u32,
    pub p_counter_indices: *const u32,
}
unsafe impl Send for QueryPoolPerformanceCreateInfoKHR {}
unsafe impl Sync for QueryPoolPerformanceCreateInfoKHR {}
impl default::Default for QueryPoolPerformanceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            queue_family_index: u32::default(),
            counter_index_count: u32::default(),
            p_counter_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for QueryPoolPerformanceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolPerformanceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("queue_family_index", &self.queue_family_index)
            .field("counter_index_count", &self.counter_index_count)
            .field("p_counter_indices", &self.p_counter_indices)
            .finish()
    }
}
///  Union of all the possible return types a counter result could return
#[repr(C)]
#[derive(Copy, Clone)]
pub union PerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
impl default::Default for PerformanceCounterResultKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PerformanceCounterResultKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterResultKHR")
            .field("int32", unsafe { &self.int32 })
            .field("int64", unsafe { &self.int64 })
            .field("uint32", unsafe { &self.uint32 })
            .field("uint64", unsafe { &self.uint64 })
            .field("float32", unsafe { &self.float32 })
            .field("float64", unsafe { &self.float64 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AcquireProfilingLockInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Acquire profiling lock flags
    pub flags: AcquireProfilingLockFlagsKHR,
    pub timeout: u64,
}
unsafe impl Send for AcquireProfilingLockInfoKHR {}
unsafe impl Sync for AcquireProfilingLockInfoKHR {}
impl default::Default for AcquireProfilingLockInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACQUIRE_PROFILING_LOCK_INFO_KHR,
            p_next: ptr::null(),
            flags: AcquireProfilingLockFlagsKHR::default(),
            timeout: u64::default(),
        }
    }
}
impl fmt::Debug for AcquireProfilingLockInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AcquireProfilingLockInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("timeout", &self.timeout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceQuerySubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Index for which counter pass to submit
    pub counter_pass_index: u32,
}
unsafe impl Send for PerformanceQuerySubmitInfoKHR {}
unsafe impl Sync for PerformanceQuerySubmitInfoKHR {}
impl default::Default for PerformanceQuerySubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            counter_pass_index: u32::default(),
        }
    }
}
impl fmt::Debug for PerformanceQuerySubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceQuerySubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("counter_pass_index", &self.counter_pass_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeadlessSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: HeadlessSurfaceCreateFlagsEXT,
}
unsafe impl Send for HeadlessSurfaceCreateInfoEXT {}
unsafe impl Sync for HeadlessSurfaceCreateInfoEXT {}
impl default::Default for HeadlessSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::HEADLESS_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: HeadlessSurfaceCreateFlagsEXT::default(),
        }
    }
}
impl fmt::Debug for HeadlessSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("HeadlessSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: Bool32,
}
unsafe impl Send for PhysicalDeviceCoverageReductionModeFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCoverageReductionModeFeaturesNV {}
impl default::Default for PhysicalDeviceCoverageReductionModeFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            p_next: ptr::null_mut(),
            coverage_reduction_mode: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCoverageReductionModeFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCoverageReductionModeFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageReductionStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageReductionStateCreateFlagsNV,
    pub coverage_reduction_mode: CoverageReductionModeNV,
}
unsafe impl Send for PipelineCoverageReductionStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageReductionStateCreateInfoNV {}
impl default::Default for PipelineCoverageReductionStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: PipelineCoverageReductionStateCreateFlagsNV::default(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
        }
    }
}
impl fmt::Debug for PipelineCoverageReductionStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageReductionStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferMixedSamplesCombinationNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub rasterization_samples: SampleCountFlags,
    pub depth_stencil_samples: SampleCountFlags,
    pub color_samples: SampleCountFlags,
}
unsafe impl Send for FramebufferMixedSamplesCombinationNV {}
unsafe impl Sync for FramebufferMixedSamplesCombinationNV {}
impl default::Default for FramebufferMixedSamplesCombinationNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
            p_next: ptr::null_mut(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
            rasterization_samples: SampleCountFlags::default(),
            depth_stencil_samples: SampleCountFlags::default(),
            color_samples: SampleCountFlags::default(),
        }
    }
}
impl fmt::Debug for FramebufferMixedSamplesCombinationNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferMixedSamplesCombinationNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .field("rasterization_samples", &self.rasterization_samples)
            .field("depth_stencil_samples", &self.depth_stencil_samples)
            .field("color_samples", &self.color_samples)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_functions2: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
unsafe impl Sync for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
impl default::Default for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            p_next: ptr::null_mut(),
            shader_integer_functions2: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_integer_functions2", &self.shader_integer_functions2)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub value_float: f32,
    pub value_bool: Bool32,
    pub value_string: *const c_char,
}
unsafe impl Send for PerformanceValueDataINTEL {}
unsafe impl Sync for PerformanceValueDataINTEL {}
impl default::Default for PerformanceValueDataINTEL {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PerformanceValueDataINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueDataINTEL")
            .field("value32", unsafe { &self.value32 })
            .field("value64", unsafe { &self.value64 })
            .field("value_float", unsafe { &self.value_float })
            .field("value_bool", unsafe { &self.value_bool })
            .field("value_string", unsafe { &self.value_string })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceValueINTEL {
    pub ty: PerformanceValueTypeINTEL,
    pub data: PerformanceValueDataINTEL,
}
impl default::Default for PerformanceValueINTEL {
    fn default() -> Self {
        Self {
            ty: PerformanceValueTypeINTEL::default(),
            data: PerformanceValueDataINTEL::default(),
        }
    }
}
impl fmt::Debug for PerformanceValueINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueINTEL")
            .field("ty", &self.ty)
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InitializePerformanceApiInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for InitializePerformanceApiInfoINTEL {}
unsafe impl Sync for InitializePerformanceApiInfoINTEL {}
impl default::Default for InitializePerformanceApiInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::INITIALIZE_PERFORMANCE_API_INFO_INTEL,
            p_next: ptr::null(),
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for InitializePerformanceApiInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InitializePerformanceApiInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolPerformanceQueryCreateInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub performance_counters_sampling: QueryPoolSamplingModeINTEL,
}
unsafe impl Send for QueryPoolPerformanceQueryCreateInfoINTEL {}
unsafe impl Sync for QueryPoolPerformanceQueryCreateInfoINTEL {}
impl default::Default for QueryPoolPerformanceQueryCreateInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            p_next: ptr::null(),
            performance_counters_sampling: QueryPoolSamplingModeINTEL::default(),
        }
    }
}
impl fmt::Debug for QueryPoolPerformanceQueryCreateInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolPerformanceQueryCreateInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("performance_counters_sampling", &self.performance_counters_sampling)
            .finish()
    }
}
pub type QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u64,
}
unsafe impl Send for PerformanceMarkerInfoINTEL {}
unsafe impl Sync for PerformanceMarkerInfoINTEL {}
impl default::Default for PerformanceMarkerInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_MARKER_INFO_INTEL,
            p_next: ptr::null(),
            marker: u64::default(),
        }
    }
}
impl fmt::Debug for PerformanceMarkerInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceMarkerInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("marker", &self.marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceStreamMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u32,
}
unsafe impl Send for PerformanceStreamMarkerInfoINTEL {}
unsafe impl Sync for PerformanceStreamMarkerInfoINTEL {}
impl default::Default for PerformanceStreamMarkerInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_STREAM_MARKER_INFO_INTEL,
            p_next: ptr::null(),
            marker: u32::default(),
        }
    }
}
impl fmt::Debug for PerformanceStreamMarkerInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceStreamMarkerInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("marker", &self.marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceOverrideInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceOverrideTypeINTEL,
    pub enable: Bool32,
    pub parameter: u64,
}
unsafe impl Send for PerformanceOverrideInfoINTEL {}
unsafe impl Sync for PerformanceOverrideInfoINTEL {}
impl default::Default for PerformanceOverrideInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_OVERRIDE_INFO_INTEL,
            p_next: ptr::null(),
            ty: PerformanceOverrideTypeINTEL::default(),
            enable: Bool32::default(),
            parameter: u64::default(),
        }
    }
}
impl fmt::Debug for PerformanceOverrideInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceOverrideInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("enable", &self.enable)
            .field("parameter", &self.parameter)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceConfigurationAcquireInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceConfigurationTypeINTEL,
}
unsafe impl Send for PerformanceConfigurationAcquireInfoINTEL {}
unsafe impl Sync for PerformanceConfigurationAcquireInfoINTEL {}
impl default::Default for PerformanceConfigurationAcquireInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
            p_next: ptr::null(),
            ty: PerformanceConfigurationTypeINTEL::default(),
        }
    }
}
impl fmt::Debug for PerformanceConfigurationAcquireInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceConfigurationAcquireInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderClockFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_clock: Bool32,
    pub shader_device_clock: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderClockFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderClockFeaturesKHR {}
impl default::Default for PhysicalDeviceShaderClockFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_subgroup_clock: Bool32::default(),
            shader_device_clock: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderClockFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderClockFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_subgroup_clock", &self.shader_subgroup_clock)
            .field("shader_device_clock", &self.shader_device_clock)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub index_type_uint8: Bool32,
}
unsafe impl Send for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
impl default::Default for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
            p_next: ptr::null_mut(),
            index_type_uint8: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceIndexTypeUint8FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("index_type_uint8", &self.index_type_uint8)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_count: u32,
    pub shader_warps_per_sm: u32,
}
unsafe impl Send for PhysicalDeviceShaderSMBuiltinsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceShaderSMBuiltinsPropertiesNV {}
impl default::Default for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shader_sm_count: u32::default(),
            shader_warps_per_sm: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSMBuiltinsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_sm_count", &self.shader_sm_count)
            .field("shader_warps_per_sm", &self.shader_warps_per_sm)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_builtins: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
impl default::Default for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            p_next: ptr::null_mut(),
            shader_sm_builtins: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSMBuiltinsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_sm_builtins", &self.shader_sm_builtins)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub fragment_shader_sample_interlock: Bool32,
    pub fragment_shader_pixel_interlock: Bool32,
    pub fragment_shader_shading_rate_interlock: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
impl default::Default for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_shader_sample_interlock: Bool32::default(),
            fragment_shader_pixel_interlock: Bool32::default(),
            fragment_shader_shading_rate_interlock: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShaderInterlockFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "fragment_shader_sample_interlock",
                &self.fragment_shader_sample_interlock,
            )
            .field("fragment_shader_pixel_interlock", &self.fragment_shader_pixel_interlock)
            .field(
                "fragment_shader_shading_rate_interlock",
                &self.fragment_shader_shading_rate_interlock,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub separate_depth_stencil_layouts: Bool32,
}
unsafe impl Send for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
unsafe impl Sync for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
impl default::Default for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            p_next: ptr::null_mut(),
            separate_depth_stencil_layouts: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSeparateDepthStencilLayoutsFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("separate_depth_stencil_layouts", &self.separate_depth_stencil_layouts)
            .finish()
    }
}
pub type PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentReferenceStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_layout: ImageLayout,
}
unsafe impl Send for AttachmentReferenceStencilLayout {}
unsafe impl Sync for AttachmentReferenceStencilLayout {}
impl default::Default for AttachmentReferenceStencilLayout {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            p_next: ptr::null_mut(),
            stencil_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for AttachmentReferenceStencilLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReferenceStencilLayout")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_layout", &self.stencil_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_topology_list_restart: Bool32,
    pub primitive_topology_patch_list_restart: Bool32,
}
unsafe impl Send for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
impl default::Default for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            p_next: ptr::null_mut(),
            primitive_topology_list_restart: Bool32::default(),
            primitive_topology_patch_list_restart: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("primitive_topology_list_restart", &self.primitive_topology_list_restart)
            .field(
                "primitive_topology_patch_list_restart",
                &self.primitive_topology_patch_list_restart,
            )
            .finish()
    }
}
pub type AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentDescriptionStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_initial_layout: ImageLayout,
    pub stencil_final_layout: ImageLayout,
}
unsafe impl Send for AttachmentDescriptionStencilLayout {}
unsafe impl Sync for AttachmentDescriptionStencilLayout {}
impl default::Default for AttachmentDescriptionStencilLayout {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            p_next: ptr::null_mut(),
            stencil_initial_layout: ImageLayout::default(),
            stencil_final_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for AttachmentDescriptionStencilLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescriptionStencilLayout")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_initial_layout", &self.stencil_initial_layout)
            .field("stencil_final_layout", &self.stencil_final_layout)
            .finish()
    }
}
pub type AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_executable_info: Bool32,
}
unsafe impl Send for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
impl default::Default for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            p_next: ptr::null_mut(),
            pipeline_executable_info: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePipelineExecutablePropertiesFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_executable_info", &self.pipeline_executable_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Option<Pipeline>,
}
unsafe impl Send for PipelineInfoKHR {}
unsafe impl Sync for PipelineInfoKHR {}
impl default::Default for PipelineInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_INFO_KHR,
            p_next: ptr::null(),
            pipeline: None,
        }
    }
}
impl fmt::Debug for PipelineInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline", &self.pipeline)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutablePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stages: ShaderStageFlags,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub subgroup_size: u32,
}
unsafe impl Send for PipelineExecutablePropertiesKHR {}
unsafe impl Sync for PipelineExecutablePropertiesKHR {}
impl default::Default for PipelineExecutablePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            stages: ShaderStageFlags::default(),
            name: [c_char::default(); MAX_DESCRIPTION_SIZE],
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
            subgroup_size: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutablePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutablePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stages", &self.stages)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("subgroup_size", &self.subgroup_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Option<Pipeline>,
    pub executable_index: u32,
}
unsafe impl Send for PipelineExecutableInfoKHR {}
unsafe impl Sync for PipelineExecutableInfoKHR {}
impl default::Default for PipelineExecutableInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_INFO_KHR,
            p_next: ptr::null(),
            pipeline: None,
            executable_index: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutableInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline", &self.pipeline)
            .field("executable_index", &self.executable_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PipelineExecutableStatisticValueKHR {
    pub b32: Bool32,
    pub i64: i64,
    pub u64: u64,
    pub f64: f64,
}
impl default::Default for PipelineExecutableStatisticValueKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PipelineExecutableStatisticValueKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticValueKHR")
            .field("b32", unsafe { &self.b32 })
            .field("i64", unsafe { &self.i64 })
            .field("u64", unsafe { &self.u64 })
            .field("f64", unsafe { &self.f64 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableStatisticKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub format: PipelineExecutableStatisticFormatKHR,
    pub value: PipelineExecutableStatisticValueKHR,
}
unsafe impl Send for PipelineExecutableStatisticKHR {}
unsafe impl Sync for PipelineExecutableStatisticKHR {}
impl default::Default for PipelineExecutableStatisticKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_STATISTIC_KHR,
            p_next: ptr::null_mut(),
            name: [c_char::default(); MAX_DESCRIPTION_SIZE],
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
            format: PipelineExecutableStatisticFormatKHR::default(),
            value: PipelineExecutableStatisticValueKHR::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutableStatisticKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("format", &self.format)
            .field("value", &self.value)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableInternalRepresentationKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub is_text: Bool32,
    pub data_size: usize,
    pub p_data: *mut c_void,
}
unsafe impl Send for PipelineExecutableInternalRepresentationKHR {}
unsafe impl Sync for PipelineExecutableInternalRepresentationKHR {}
impl default::Default for PipelineExecutableInternalRepresentationKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
            p_next: ptr::null_mut(),
            name: [c_char::default(); MAX_DESCRIPTION_SIZE],
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
            is_text: Bool32::default(),
            data_size: usize::default(),
            p_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PipelineExecutableInternalRepresentationKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInternalRepresentationKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("is_text", &self.is_text)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_demote_to_helper_invocation: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {}
impl default::Default for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_demote_to_helper_invocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_demote_to_helper_invocation",
                &self.shader_demote_to_helper_invocation,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texel_buffer_alignment: Bool32,
}
unsafe impl Send for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
impl default::Default for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            texel_buffer_alignment: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTexelBufferAlignmentFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("texel_buffer_alignment", &self.texel_buffer_alignment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
}
unsafe impl Send for PhysicalDeviceTexelBufferAlignmentPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceTexelBufferAlignmentPropertiesEXT {}
impl default::Default for PhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            storage_texel_buffer_offset_single_texel_alignment: Bool32::default(),
            uniform_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTexelBufferAlignmentPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "storage_texel_buffer_offset_alignment_bytes",
                &self.storage_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "storage_texel_buffer_offset_single_texel_alignment",
                &self.storage_texel_buffer_offset_single_texel_alignment,
            )
            .field(
                "uniform_texel_buffer_offset_alignment_bytes",
                &self.uniform_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "uniform_texel_buffer_offset_single_texel_alignment",
                &self.uniform_texel_buffer_offset_single_texel_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupSizeControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
}
unsafe impl Send for PhysicalDeviceSubgroupSizeControlFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceSubgroupSizeControlFeaturesEXT {}
impl default::Default for PhysicalDeviceSubgroupSizeControlFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
            p_next: ptr::null_mut(),
            subgroup_size_control: Bool32::default(),
            compute_full_subgroups: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupSizeControlFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupSizeControlFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subgroup_size_control", &self.subgroup_size_control)
            .field("compute_full_subgroups", &self.compute_full_subgroups)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupSizeControlPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The minimum subgroup size supported by this device
    pub min_subgroup_size: u32,
    /// The maximum subgroup size supported by this device
    pub max_subgroup_size: u32,
    /// The maximum number of subgroups supported in a workgroup
    pub max_compute_workgroup_subgroups: u32,
    /// The shader stages that support specifying a subgroup size
    pub required_subgroup_size_stages: ShaderStageFlags,
}
unsafe impl Send for PhysicalDeviceSubgroupSizeControlPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceSubgroupSizeControlPropertiesEXT {}
impl default::Default for PhysicalDeviceSubgroupSizeControlPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            min_subgroup_size: u32::default(),
            max_subgroup_size: u32::default(),
            max_compute_workgroup_subgroups: u32::default(),
            required_subgroup_size_stages: ShaderStageFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupSizeControlPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupSizeControlPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_subgroup_size", &self.min_subgroup_size)
            .field("max_subgroup_size", &self.max_subgroup_size)
            .field("max_compute_workgroup_subgroups", &self.max_compute_workgroup_subgroups)
            .field("required_subgroup_size_stages", &self.required_subgroup_size_stages)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub required_subgroup_size: u32,
}
unsafe impl Send for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {}
unsafe impl Sync for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {}
impl default::Default for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
            p_next: ptr::null_mut(),
            required_subgroup_size: u32::default(),
        }
    }
}
impl fmt::Debug for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("required_subgroup_size", &self.required_subgroup_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassShadingPipelineCreateInfoHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
}
unsafe impl Send for SubpassShadingPipelineCreateInfoHUAWEI {}
unsafe impl Sync for SubpassShadingPipelineCreateInfoHUAWEI {}
impl default::Default for SubpassShadingPipelineCreateInfoHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            p_next: ptr::null_mut(),
            render_pass: None,
            subpass: u32::default(),
        }
    }
}
impl fmt::Debug for SubpassShadingPipelineCreateInfoHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassShadingPipelineCreateInfoHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
}
unsafe impl Send for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
unsafe impl Sync for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
impl default::Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            p_next: ptr::null_mut(),
            max_subpass_shading_workgroup_size_aspect_ratio: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubpassShadingPropertiesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_subpass_shading_workgroup_size_aspect_ratio",
                &self.max_subpass_shading_workgroup_size_aspect_ratio,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryOpaqueCaptureAddressAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
unsafe impl Send for MemoryOpaqueCaptureAddressAllocateInfo {}
unsafe impl Sync for MemoryOpaqueCaptureAddressAllocateInfo {}
impl default::Default for MemoryOpaqueCaptureAddressAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            p_next: ptr::null(),
            opaque_capture_address: u64::default(),
        }
    }
}
impl fmt::Debug for MemoryOpaqueCaptureAddressAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryOpaqueCaptureAddressAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("opaque_capture_address", &self.opaque_capture_address)
            .finish()
    }
}
pub type MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryOpaqueCaptureAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
}
unsafe impl Send for DeviceMemoryOpaqueCaptureAddressInfo {}
unsafe impl Sync for DeviceMemoryOpaqueCaptureAddressInfo {}
impl default::Default for DeviceMemoryOpaqueCaptureAddressInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
            p_next: ptr::null(),
            memory: None,
        }
    }
}
impl fmt::Debug for DeviceMemoryOpaqueCaptureAddressInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryOpaqueCaptureAddressInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .finish()
    }
}
pub type DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLineRasterizationFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rectangular_lines: Bool32,
    pub bresenham_lines: Bool32,
    pub smooth_lines: Bool32,
    pub stippled_rectangular_lines: Bool32,
    pub stippled_bresenham_lines: Bool32,
    pub stippled_smooth_lines: Bool32,
}
unsafe impl Send for PhysicalDeviceLineRasterizationFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceLineRasterizationFeaturesEXT {}
impl default::Default for PhysicalDeviceLineRasterizationFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
            p_next: ptr::null_mut(),
            rectangular_lines: Bool32::default(),
            bresenham_lines: Bool32::default(),
            smooth_lines: Bool32::default(),
            stippled_rectangular_lines: Bool32::default(),
            stippled_bresenham_lines: Bool32::default(),
            stippled_smooth_lines: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLineRasterizationFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLineRasterizationFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("rectangular_lines", &self.rectangular_lines)
            .field("bresenham_lines", &self.bresenham_lines)
            .field("smooth_lines", &self.smooth_lines)
            .field("stippled_rectangular_lines", &self.stippled_rectangular_lines)
            .field("stippled_bresenham_lines", &self.stippled_bresenham_lines)
            .field("stippled_smooth_lines", &self.stippled_smooth_lines)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLineRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub line_sub_pixel_precision_bits: u32,
}
unsafe impl Send for PhysicalDeviceLineRasterizationPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceLineRasterizationPropertiesEXT {}
impl default::Default for PhysicalDeviceLineRasterizationPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            line_sub_pixel_precision_bits: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLineRasterizationPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLineRasterizationPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("line_sub_pixel_precision_bits", &self.line_sub_pixel_precision_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationLineStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub line_rasterization_mode: LineRasterizationModeEXT,
    pub stippled_line_enable: Bool32,
    pub line_stipple_factor: u32,
    pub line_stipple_pattern: u16,
}
unsafe impl Send for PipelineRasterizationLineStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationLineStateCreateInfoEXT {}
impl default::Default for PipelineRasterizationLineStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            line_rasterization_mode: LineRasterizationModeEXT::default(),
            stippled_line_enable: Bool32::default(),
            line_stipple_factor: u32::default(),
            line_stipple_pattern: u16::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationLineStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationLineStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("line_rasterization_mode", &self.line_rasterization_mode)
            .field("stippled_line_enable", &self.stippled_line_enable)
            .field("line_stipple_factor", &self.line_stipple_factor)
            .field("line_stipple_pattern", &self.line_stipple_pattern)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePipelineCreationCacheControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_creation_cache_control: Bool32,
}
unsafe impl Send for PhysicalDevicePipelineCreationCacheControlFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePipelineCreationCacheControlFeaturesEXT {}
impl default::Default for PhysicalDevicePipelineCreationCacheControlFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT,
            p_next: ptr::null_mut(),
            pipeline_creation_cache_control: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePipelineCreationCacheControlFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePipelineCreationCacheControlFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_creation_cache_control", &self.pipeline_creation_cache_control)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan11Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit integer/floating-point variables supported in BufferBlock
    pub storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in BufferBlock and Block
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in PushConstant
    pub storage_push_constant16: Bool32,
    /// 16-bit integer/floating-point variables supported in shader inputs and outputs
    pub storage_input_output16: Bool32,
    /// Multiple views in a renderpass
    pub multiview: Bool32,
    /// Multiple views in a renderpass w/ geometry shader
    pub multiview_geometry_shader: Bool32,
    /// Multiple views in a renderpass w/ tessellation shader
    pub multiview_tessellation_shader: Bool32,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub protected_memory: Bool32,
    /// Sampler color conversion supported
    pub sampler_ycbcr_conversion: Bool32,
    pub shader_draw_parameters: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkan11Features {}
unsafe impl Sync for PhysicalDeviceVulkan11Features {}
impl default::Default for PhysicalDeviceVulkan11Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
            protected_memory: Bool32::default(),
            sampler_ycbcr_conversion: Bool32::default(),
            shader_draw_parameters: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan11Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan11Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer16_bit_access", &self.storage_buffer16_bit_access)
            .field(
                "uniform_and_storage_buffer16_bit_access",
                &self.uniform_and_storage_buffer16_bit_access,
            )
            .field("storage_push_constant16", &self.storage_push_constant16)
            .field("storage_input_output16", &self.storage_input_output16)
            .field("multiview", &self.multiview)
            .field("multiview_geometry_shader", &self.multiview_geometry_shader)
            .field("multiview_tessellation_shader", &self.multiview_tessellation_shader)
            .field(
                "variable_pointers_storage_buffer",
                &self.variable_pointers_storage_buffer,
            )
            .field("variable_pointers", &self.variable_pointers)
            .field("protected_memory", &self.protected_memory)
            .field("sampler_ycbcr_conversion", &self.sampler_ycbcr_conversion)
            .field("shader_draw_parameters", &self.shader_draw_parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan11Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
    /// The size of a subgroup for this queue.
    pub subgroup_size: u32,
    /// Bitfield of what shader stages support subgroup operations
    pub subgroup_supported_stages: ShaderStageFlags,
    /// Bitfield of what subgroup operations are supported.
    pub subgroup_supported_operations: SubgroupFeatureFlags,
    /// Flag to specify whether quad operations are available in all stages.
    pub subgroup_quad_operations_in_all_stages: Bool32,
    pub point_clipping_behavior: PointClippingBehavior,
    /// max number of views in a subpass
    pub max_multiview_view_count: u32,
    /// max instance index for a draw in a multiview subpass
    pub max_multiview_instance_index: u32,
    pub protected_no_fault: Bool32,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceVulkan11Properties {}
unsafe impl Sync for PhysicalDeviceVulkan11Properties {}
impl default::Default for PhysicalDeviceVulkan11Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            p_next: ptr::null_mut(),
            device_uuid: [u8::default(); UUID_SIZE],
            driver_uuid: [u8::default(); UUID_SIZE],
            device_luid: [u8::default(); LUID_SIZE],
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
            subgroup_size: u32::default(),
            subgroup_supported_stages: ShaderStageFlags::default(),
            subgroup_supported_operations: SubgroupFeatureFlags::default(),
            subgroup_quad_operations_in_all_stages: Bool32::default(),
            point_clipping_behavior: PointClippingBehavior::default(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
            protected_no_fault: Bool32::default(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan11Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan11Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_uuid", &self.device_uuid)
            .field("driver_uuid", &self.driver_uuid)
            .field("device_luid", &self.device_luid)
            .field("device_node_mask", &self.device_node_mask)
            .field("device_luid_valid", &self.device_luid_valid)
            .field("subgroup_size", &self.subgroup_size)
            .field("subgroup_supported_stages", &self.subgroup_supported_stages)
            .field("subgroup_supported_operations", &self.subgroup_supported_operations)
            .field(
                "subgroup_quad_operations_in_all_stages",
                &self.subgroup_quad_operations_in_all_stages,
            )
            .field("point_clipping_behavior", &self.point_clipping_behavior)
            .field("max_multiview_view_count", &self.max_multiview_view_count)
            .field("max_multiview_instance_index", &self.max_multiview_instance_index)
            .field("protected_no_fault", &self.protected_no_fault)
            .field("max_per_set_descriptors", &self.max_per_set_descriptors)
            .field("max_memory_allocation_size", &self.max_memory_allocation_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan12Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_mirror_clamp_to_edge: Bool32,
    pub draw_indirect_count: Bool32,
    /// 8-bit integer variables supported in StorageBuffer
    pub storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in StorageBuffer and Uniform
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in PushConstant
    pub storage_push_constant8: Bool32,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    /// 16-bit floats (halfs) in shaders
    pub shader_float16: Bool32,
    /// 8-bit integers in shaders
    pub shader_int8: Bool32,
    pub descriptor_indexing: Bool32,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub sampler_filter_minmax: Bool32,
    pub scalar_block_layout: Bool32,
    pub imageless_framebuffer: Bool32,
    pub uniform_buffer_standard_layout: Bool32,
    pub shader_subgroup_extended_types: Bool32,
    pub separate_depth_stencil_layouts: Bool32,
    pub host_query_reset: Bool32,
    pub timeline_semaphore: Bool32,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub shader_output_viewport_index: Bool32,
    pub shader_output_layer: Bool32,
    pub subgroup_broadcast_dynamic_id: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkan12Features {}
unsafe impl Sync for PhysicalDeviceVulkan12Features {}
impl default::Default for PhysicalDeviceVulkan12Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            p_next: ptr::null_mut(),
            sampler_mirror_clamp_to_edge: Bool32::default(),
            draw_indirect_count: Bool32::default(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
            descriptor_indexing: Bool32::default(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
            sampler_filter_minmax: Bool32::default(),
            scalar_block_layout: Bool32::default(),
            imageless_framebuffer: Bool32::default(),
            uniform_buffer_standard_layout: Bool32::default(),
            shader_subgroup_extended_types: Bool32::default(),
            separate_depth_stencil_layouts: Bool32::default(),
            host_query_reset: Bool32::default(),
            timeline_semaphore: Bool32::default(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
            shader_output_viewport_index: Bool32::default(),
            shader_output_layer: Bool32::default(),
            subgroup_broadcast_dynamic_id: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan12Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sampler_mirror_clamp_to_edge", &self.sampler_mirror_clamp_to_edge)
            .field("draw_indirect_count", &self.draw_indirect_count)
            .field("storage_buffer8_bit_access", &self.storage_buffer8_bit_access)
            .field(
                "uniform_and_storage_buffer8_bit_access",
                &self.uniform_and_storage_buffer8_bit_access,
            )
            .field("storage_push_constant8", &self.storage_push_constant8)
            .field("shader_buffer_int64_atomics", &self.shader_buffer_int64_atomics)
            .field("shader_shared_int64_atomics", &self.shader_shared_int64_atomics)
            .field("shader_float16", &self.shader_float16)
            .field("shader_int8", &self.shader_int8)
            .field("descriptor_indexing", &self.descriptor_indexing)
            .field(
                "shader_input_attachment_array_dynamic_indexing",
                &self.shader_input_attachment_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_dynamic_indexing",
                &self.shader_uniform_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_dynamic_indexing",
                &self.shader_storage_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing",
                &self.shader_uniform_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing",
                &self.shader_sampled_image_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing",
                &self.shader_storage_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing",
                &self.shader_storage_image_array_non_uniform_indexing,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing",
                &self.shader_input_attachment_array_non_uniform_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_non_uniform_indexing",
                &self.shader_uniform_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_non_uniform_indexing",
                &self.shader_storage_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "descriptor_binding_uniform_buffer_update_after_bind",
                &self.descriptor_binding_uniform_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_sampled_image_update_after_bind",
                &self.descriptor_binding_sampled_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_image_update_after_bind",
                &self.descriptor_binding_storage_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_buffer_update_after_bind",
                &self.descriptor_binding_storage_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_uniform_texel_buffer_update_after_bind",
                &self.descriptor_binding_uniform_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_texel_buffer_update_after_bind",
                &self.descriptor_binding_storage_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_update_unused_while_pending",
                &self.descriptor_binding_update_unused_while_pending,
            )
            .field(
                "descriptor_binding_partially_bound",
                &self.descriptor_binding_partially_bound,
            )
            .field(
                "descriptor_binding_variable_descriptor_count",
                &self.descriptor_binding_variable_descriptor_count,
            )
            .field("runtime_descriptor_array", &self.runtime_descriptor_array)
            .field("sampler_filter_minmax", &self.sampler_filter_minmax)
            .field("scalar_block_layout", &self.scalar_block_layout)
            .field("imageless_framebuffer", &self.imageless_framebuffer)
            .field("uniform_buffer_standard_layout", &self.uniform_buffer_standard_layout)
            .field("shader_subgroup_extended_types", &self.shader_subgroup_extended_types)
            .field("separate_depth_stencil_layouts", &self.separate_depth_stencil_layouts)
            .field("host_query_reset", &self.host_query_reset)
            .field("timeline_semaphore", &self.timeline_semaphore)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .field("vulkan_memory_model", &self.vulkan_memory_model)
            .field(
                "vulkan_memory_model_device_scope",
                &self.vulkan_memory_model_device_scope,
            )
            .field(
                "vulkan_memory_model_availability_visibility_chains",
                &self.vulkan_memory_model_availability_visibility_chains,
            )
            .field("shader_output_viewport_index", &self.shader_output_viewport_index)
            .field("shader_output_layer", &self.shader_output_layer)
            .field("subgroup_broadcast_dynamic_id", &self.subgroup_broadcast_dynamic_id)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan12Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float16: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float32: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float64: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float16: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float32: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float64: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float16: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float32: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float64: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float16: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float32: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float64: Bool32,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    /// supported depth resolve modes
    pub supported_depth_resolve_modes: ResolveModeFlags,
    /// supported stencil resolve modes
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    /// depth and stencil resolve modes can be set independently if one of them is none
    pub independent_resolve_none: Bool32,
    /// depth and stencil resolve modes can be set independently
    pub independent_resolve: Bool32,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub max_timeline_semaphore_value_difference: u64,
    pub framebuffer_integer_color_sample_counts: SampleCountFlags,
}
unsafe impl Send for PhysicalDeviceVulkan12Properties {}
unsafe impl Sync for PhysicalDeviceVulkan12Properties {}
impl default::Default for PhysicalDeviceVulkan12Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            p_next: ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: [c_char::default(); MAX_DRIVER_NAME_SIZE],
            driver_info: [c_char::default(); MAX_DRIVER_INFO_SIZE],
            conformance_version: ConformanceVersion::default(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
            max_timeline_semaphore_value_difference: u64::default(),
            framebuffer_integer_color_sample_counts: SampleCountFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan12Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe { CStr::from_ptr(self.driver_name.as_ptr()) })
            .field("driver_info", &unsafe { CStr::from_ptr(self.driver_info.as_ptr()) })
            .field("conformance_version", &self.conformance_version)
            .field("denorm_behavior_independence", &self.denorm_behavior_independence)
            .field("rounding_mode_independence", &self.rounding_mode_independence)
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field("shader_denorm_preserve_float16", &self.shader_denorm_preserve_float16)
            .field("shader_denorm_preserve_float32", &self.shader_denorm_preserve_float32)
            .field("shader_denorm_preserve_float64", &self.shader_denorm_preserve_float64)
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field("quad_divergent_implicit_lod", &self.quad_divergent_implicit_lod)
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .field("supported_depth_resolve_modes", &self.supported_depth_resolve_modes)
            .field("supported_stencil_resolve_modes", &self.supported_stencil_resolve_modes)
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .field(
                "framebuffer_integer_color_sample_counts",
                &self.framebuffer_integer_color_sample_counts,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCompilerControlCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compiler_control_flags: PipelineCompilerControlFlagsAMD,
}
unsafe impl Send for PipelineCompilerControlCreateInfoAMD {}
unsafe impl Sync for PipelineCompilerControlCreateInfoAMD {}
impl default::Default for PipelineCompilerControlCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
            p_next: ptr::null(),
            compiler_control_flags: PipelineCompilerControlFlagsAMD::default(),
        }
    }
}
impl fmt::Debug for PipelineCompilerControlCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCompilerControlCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compiler_control_flags", &self.compiler_control_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_coherent_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceCoherentMemoryFeaturesAMD {}
unsafe impl Sync for PhysicalDeviceCoherentMemoryFeaturesAMD {}
impl default::Default for PhysicalDeviceCoherentMemoryFeaturesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            p_next: ptr::null_mut(),
            device_coherent_memory: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCoherentMemoryFeaturesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCoherentMemoryFeaturesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_coherent_memory", &self.device_coherent_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceToolPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub version: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub purposes: ToolPurposeFlagsEXT,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub layer: [c_char; MAX_EXTENSION_NAME_SIZE],
}
unsafe impl Send for PhysicalDeviceToolPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceToolPropertiesEXT {}
impl default::Default for PhysicalDeviceToolPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            name: [c_char::default(); MAX_EXTENSION_NAME_SIZE],
            version: [c_char::default(); MAX_EXTENSION_NAME_SIZE],
            purposes: ToolPurposeFlagsEXT::default(),
            description: [c_char::default(); MAX_DESCRIPTION_SIZE],
            layer: [c_char::default(); MAX_EXTENSION_NAME_SIZE],
        }
    }
}
impl fmt::Debug for PhysicalDeviceToolPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceToolPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("version", &unsafe { CStr::from_ptr(self.version.as_ptr()) })
            .field("purposes", &self.purposes)
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("layer", &unsafe { CStr::from_ptr(self.layer.as_ptr()) })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerCustomBorderColorCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub custom_border_color: ClearColorValue,
    pub format: Format,
}
unsafe impl Send for SamplerCustomBorderColorCreateInfoEXT {}
unsafe impl Sync for SamplerCustomBorderColorCreateInfoEXT {}
impl default::Default for SamplerCustomBorderColorCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            p_next: ptr::null(),
            custom_border_color: ClearColorValue::default(),
            format: Format::default(),
        }
    }
}
impl fmt::Debug for SamplerCustomBorderColorCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCustomBorderColorCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_color", &self.custom_border_color)
            .field("format", &self.format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_custom_border_color_samplers: u32,
}
unsafe impl Send for PhysicalDeviceCustomBorderColorPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceCustomBorderColorPropertiesEXT {}
impl default::Default for PhysicalDeviceCustomBorderColorPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_custom_border_color_samplers: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCustomBorderColorPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCustomBorderColorPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_custom_border_color_samplers",
                &self.max_custom_border_color_samplers,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub custom_border_colors: Bool32,
    pub custom_border_color_without_format: Bool32,
}
unsafe impl Send for PhysicalDeviceCustomBorderColorFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceCustomBorderColorFeaturesEXT {}
impl default::Default for PhysicalDeviceCustomBorderColorFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            p_next: ptr::null_mut(),
            custom_border_colors: Bool32::default(),
            custom_border_color_without_format: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCustomBorderColorFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCustomBorderColorFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_colors", &self.custom_border_colors)
            .field(
                "custom_border_color_without_format",
                &self.custom_border_color_without_format,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerBorderColorComponentMappingCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub components: ComponentMapping,
    pub srgb: Bool32,
}
unsafe impl Send for SamplerBorderColorComponentMappingCreateInfoEXT {}
unsafe impl Sync for SamplerBorderColorComponentMappingCreateInfoEXT {}
impl default::Default for SamplerBorderColorComponentMappingCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            p_next: ptr::null(),
            components: ComponentMapping::default(),
            srgb: Bool32::default(),
        }
    }
}
impl fmt::Debug for SamplerBorderColorComponentMappingCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerBorderColorComponentMappingCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("components", &self.components)
            .field("srgb", &self.srgb)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub border_color_swizzle: Bool32,
    pub border_color_swizzle_from_image: Bool32,
}
unsafe impl Send for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
impl default::Default for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            border_color_swizzle: Bool32::default(),
            border_color_swizzle_from_image: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBorderColorSwizzleFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("border_color_swizzle", &self.border_color_swizzle)
            .field("border_color_swizzle_from_image", &self.border_color_swizzle_from_image)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceOrHostAddressKHR {
    pub device_address: DeviceAddress,
    pub host_address: *mut c_void,
}
unsafe impl Send for DeviceOrHostAddressKHR {}
unsafe impl Sync for DeviceOrHostAddressKHR {}
impl default::Default for DeviceOrHostAddressKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for DeviceOrHostAddressKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceOrHostAddressKHR")
            .field("device_address", unsafe { &self.device_address })
            .field("host_address", unsafe { &self.host_address })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceOrHostAddressConstKHR {
    pub device_address: DeviceAddress,
    pub host_address: *const c_void,
}
unsafe impl Send for DeviceOrHostAddressConstKHR {}
unsafe impl Sync for DeviceOrHostAddressConstKHR {}
impl default::Default for DeviceOrHostAddressConstKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for DeviceOrHostAddressConstKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceOrHostAddressConstKHR")
            .field("device_address", unsafe { &self.device_address })
            .field("host_address", unsafe { &self.host_address })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryTrianglesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_format: Format,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub vertex_stride: DeviceSize,
    pub max_vertex: u32,
    pub index_type: IndexType,
    pub index_data: DeviceOrHostAddressConstKHR,
    pub transform_data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryTrianglesDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryTrianglesDataKHR {}
impl default::Default for AccelerationStructureGeometryTrianglesDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            p_next: ptr::null(),
            vertex_format: Format::default(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
            vertex_stride: DeviceSize::default(),
            max_vertex: u32::default(),
            index_type: IndexType::default(),
            index_data: DeviceOrHostAddressConstKHR::default(),
            transform_data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryTrianglesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryTrianglesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_format", &self.vertex_format)
            .field("vertex_data", &self.vertex_data)
            .field("vertex_stride", &self.vertex_stride)
            .field("max_vertex", &self.max_vertex)
            .field("index_type", &self.index_type)
            .field("index_data", &self.index_data)
            .field("transform_data", &self.transform_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryAabbsDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data: DeviceOrHostAddressConstKHR,
    pub stride: DeviceSize,
}
unsafe impl Send for AccelerationStructureGeometryAabbsDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryAabbsDataKHR {}
impl default::Default for AccelerationStructureGeometryAabbsDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
            p_next: ptr::null(),
            data: DeviceOrHostAddressConstKHR::default(),
            stride: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryAabbsDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryAabbsDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data", &self.data)
            .field("stride", &self.stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryInstancesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub array_of_pointers: Bool32,
    pub data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryInstancesDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryInstancesDataKHR {}
impl default::Default for AccelerationStructureGeometryInstancesDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
            p_next: ptr::null(),
            array_of_pointers: Bool32::default(),
            data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryInstancesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryInstancesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("array_of_pointers", &self.array_of_pointers)
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureGeometryDataKHR {
    pub triangles: AccelerationStructureGeometryTrianglesDataKHR,
    pub aabbs: AccelerationStructureGeometryAabbsDataKHR,
    pub instances: AccelerationStructureGeometryInstancesDataKHR,
}
impl default::Default for AccelerationStructureGeometryDataKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for AccelerationStructureGeometryDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryDataKHR")
            .field("triangles", unsafe { &self.triangles })
            .field("aabbs", unsafe { &self.aabbs })
            .field("instances", unsafe { &self.instances })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: AccelerationStructureGeometryDataKHR,
    pub flags: GeometryFlagsKHR,
}
unsafe impl Send for AccelerationStructureGeometryKHR {}
unsafe impl Sync for AccelerationStructureGeometryKHR {}
impl default::Default for AccelerationStructureGeometryKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            p_next: ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: AccelerationStructureGeometryDataKHR::default(),
            flags: GeometryFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &self.geometry)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureBuildGeometryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeKHR,
    pub flags: BuildAccelerationStructureFlagsKHR,
    pub mode: BuildAccelerationStructureModeKHR,
    pub src_acceleration_structure: Option<AccelerationStructureKHR>,
    pub dst_acceleration_structure: Option<AccelerationStructureKHR>,
    pub geometry_count: u32,
    pub p_geometries: *const AccelerationStructureGeometryKHR,
    pub pp_geometries: *const *const AccelerationStructureGeometryKHR,
    pub scratch_data: DeviceOrHostAddressKHR,
}
unsafe impl Send for AccelerationStructureBuildGeometryInfoKHR {}
unsafe impl Sync for AccelerationStructureBuildGeometryInfoKHR {}
impl default::Default for AccelerationStructureBuildGeometryInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
            p_next: ptr::null(),
            ty: AccelerationStructureTypeKHR::default(),
            flags: BuildAccelerationStructureFlagsKHR::default(),
            mode: BuildAccelerationStructureModeKHR::default(),
            src_acceleration_structure: None,
            dst_acceleration_structure: None,
            geometry_count: u32::default(),
            p_geometries: ptr::null(),
            pp_geometries: ptr::null(),
            scratch_data: DeviceOrHostAddressKHR::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureBuildGeometryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildGeometryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("mode", &self.mode)
            .field("src_acceleration_structure", &self.src_acceleration_structure)
            .field("dst_acceleration_structure", &self.dst_acceleration_structure)
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .field("pp_geometries", &self.pp_geometries)
            .field("scratch_data", &self.scratch_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureBuildRangeInfoKHR {
    pub primitive_count: u32,
    pub primitive_offset: u32,
    pub first_vertex: u32,
    pub transform_offset: u32,
}
impl default::Default for AccelerationStructureBuildRangeInfoKHR {
    fn default() -> Self {
        Self {
            primitive_count: u32::default(),
            primitive_offset: u32::default(),
            first_vertex: u32::default(),
            transform_offset: u32::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureBuildRangeInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildRangeInfoKHR")
            .field("primitive_count", &self.primitive_count)
            .field("primitive_offset", &self.primitive_offset)
            .field("first_vertex", &self.first_vertex)
            .field("transform_offset", &self.transform_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_flags: AccelerationStructureCreateFlagsKHR,
    pub buffer: Option<Buffer>,
    /// Specified in bytes
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: AccelerationStructureTypeKHR,
    pub device_address: DeviceAddress,
}
unsafe impl Send for AccelerationStructureCreateInfoKHR {}
unsafe impl Sync for AccelerationStructureCreateInfoKHR {}
impl default::Default for AccelerationStructureCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            create_flags: AccelerationStructureCreateFlagsKHR::default(),
            buffer: None,
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            ty: AccelerationStructureTypeKHR::default(),
            device_address: DeviceAddress::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("create_flags", &self.create_flags)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .field("ty", &self.ty)
            .field("device_address", &self.device_address)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AabbPositionsKHR {
    pub min_x: f32,
    pub min_y: f32,
    pub min_z: f32,
    pub max_x: f32,
    pub max_y: f32,
    pub max_z: f32,
}
impl default::Default for AabbPositionsKHR {
    fn default() -> Self {
        Self {
            min_x: f32::default(),
            min_y: f32::default(),
            min_z: f32::default(),
            max_x: f32::default(),
            max_y: f32::default(),
            max_z: f32::default(),
        }
    }
}
impl fmt::Debug for AabbPositionsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AabbPositionsKHR")
            .field("min_x", &self.min_x)
            .field("min_y", &self.min_y)
            .field("min_z", &self.min_z)
            .field("max_x", &self.max_x)
            .field("max_y", &self.max_y)
            .field("max_z", &self.max_z)
            .finish()
    }
}
pub type AabbPositionsNV = AabbPositionsKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TransformMatrixKHR {
    pub matrix: [f32; 12],
}
impl default::Default for TransformMatrixKHR {
    fn default() -> Self {
        Self {
            matrix: [f32::default(); 12],
        }
    }
}
impl fmt::Debug for TransformMatrixKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TransformMatrixKHR")
            .field("matrix", &self.matrix)
            .finish()
    }
}
pub type TransformMatrixNV = TransformMatrixKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureInstanceKHR {
    pub transform: TransformMatrixKHR,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl default::Default for AccelerationStructureInstanceKHR {
    fn default() -> Self {
        Self {
            transform: TransformMatrixKHR::default(),
            instance_custom_index_and_mask: u32::default(),
            instance_shader_binding_table_record_offset_and_flags: u32::default(),
            acceleration_structure_reference: u64::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureInstanceKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureInstanceKHR")
            .field("transform", &self.transform)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
pub type AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureDeviceAddressInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: Option<AccelerationStructureKHR>,
}
unsafe impl Send for AccelerationStructureDeviceAddressInfoKHR {}
unsafe impl Sync for AccelerationStructureDeviceAddressInfoKHR {}
impl default::Default for AccelerationStructureDeviceAddressInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
            p_next: ptr::null(),
            acceleration_structure: None,
        }
    }
}
impl fmt::Debug for AccelerationStructureDeviceAddressInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureDeviceAddressInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureVersionInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_version_data: *const u8,
}
unsafe impl Send for AccelerationStructureVersionInfoKHR {}
unsafe impl Sync for AccelerationStructureVersionInfoKHR {}
impl default::Default for AccelerationStructureVersionInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
            p_next: ptr::null(),
            p_version_data: ptr::null(),
        }
    }
}
impl fmt::Debug for AccelerationStructureVersionInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureVersionInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_version_data", &self.p_version_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyAccelerationStructureInfoKHR {}
unsafe impl Sync for CopyAccelerationStructureInfoKHR {}
impl default::Default for CopyAccelerationStructureInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: ptr::null(),
            src: None,
            dst: None,
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
impl fmt::Debug for CopyAccelerationStructureInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyAccelerationStructureToMemoryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyAccelerationStructureToMemoryInfoKHR {}
unsafe impl Sync for CopyAccelerationStructureToMemoryInfoKHR {}
impl default::Default for CopyAccelerationStructureToMemoryInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
            p_next: ptr::null(),
            src: None,
            dst: DeviceOrHostAddressKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
impl fmt::Debug for CopyAccelerationStructureToMemoryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureToMemoryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyMemoryToAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyMemoryToAccelerationStructureInfoKHR {}
unsafe impl Sync for CopyMemoryToAccelerationStructureInfoKHR {}
impl default::Default for CopyMemoryToAccelerationStructureInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: ptr::null(),
            src: DeviceOrHostAddressConstKHR::default(),
            dst: None,
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
impl fmt::Debug for CopyMemoryToAccelerationStructureInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMemoryToAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineInterfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_pipeline_ray_payload_size: u32,
    pub max_pipeline_ray_hit_attribute_size: u32,
}
unsafe impl Send for RayTracingPipelineInterfaceCreateInfoKHR {}
unsafe impl Sync for RayTracingPipelineInterfaceCreateInfoKHR {}
impl default::Default for RayTracingPipelineInterfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            max_pipeline_ray_payload_size: u32::default(),
            max_pipeline_ray_hit_attribute_size: u32::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineInterfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineInterfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_pipeline_ray_payload_size", &self.max_pipeline_ray_payload_size)
            .field(
                "max_pipeline_ray_hit_attribute_size",
                &self.max_pipeline_ray_hit_attribute_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineLibraryCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub library_count: u32,
    pub p_libraries: *const Pipeline,
}
unsafe impl Send for PipelineLibraryCreateInfoKHR {}
unsafe impl Sync for PipelineLibraryCreateInfoKHR {}
impl default::Default for PipelineLibraryCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_LIBRARY_CREATE_INFO_KHR,
            p_next: ptr::null(),
            library_count: u32::default(),
            p_libraries: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineLibraryCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineLibraryCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("library_count", &self.library_count)
            .field("p_libraries", &self.p_libraries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state: Bool32,
}
unsafe impl Send for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
impl default::Default for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            extended_dynamic_state: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExtendedDynamicStateFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("extended_dynamic_state", &self.extended_dynamic_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state2: Bool32,
    pub extended_dynamic_state2_logic_op: Bool32,
    pub extended_dynamic_state2_patch_control_points: Bool32,
}
unsafe impl Send for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
impl default::Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            extended_dynamic_state2: Bool32::default(),
            extended_dynamic_state2_logic_op: Bool32::default(),
            extended_dynamic_state2_patch_control_points: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExtendedDynamicState2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("extended_dynamic_state2", &self.extended_dynamic_state2)
            .field(
                "extended_dynamic_state2_logic_op",
                &self.extended_dynamic_state2_logic_op,
            )
            .field(
                "extended_dynamic_state2_patch_control_points",
                &self.extended_dynamic_state2_patch_control_points,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassTransformBeginInfoQCOM {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
unsafe impl Send for RenderPassTransformBeginInfoQCOM {}
unsafe impl Sync for RenderPassTransformBeginInfoQCOM {}
impl default::Default for RenderPassTransformBeginInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
            p_next: ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for RenderPassTransformBeginInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassTransformBeginInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyCommandTransformInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
unsafe impl Send for CopyCommandTransformInfoQCOM {}
unsafe impl Sync for CopyCommandTransformInfoQCOM {}
impl default::Default for CopyCommandTransformInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_COMMAND_TRANSFORM_INFO_QCOM,
            p_next: ptr::null(),
            transform: SurfaceTransformFlagsKHR::default(),
        }
    }
}
impl fmt::Debug for CopyCommandTransformInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyCommandTransformInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub render_area: Rect2D,
}
unsafe impl Send for CommandBufferInheritanceRenderPassTransformInfoQCOM {}
unsafe impl Sync for CommandBufferInheritanceRenderPassTransformInfoQCOM {}
impl default::Default for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
            p_next: ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
            render_area: Rect2D::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceRenderPassTransformInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .field("render_area", &self.render_area)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub diagnostics_config: Bool32,
}
unsafe impl Send for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
impl default::Default for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            p_next: ptr::null_mut(),
            diagnostics_config: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDiagnosticsConfigFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("diagnostics_config", &self.diagnostics_config)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceDiagnosticsConfigCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceDiagnosticsConfigFlagsNV,
}
unsafe impl Send for DeviceDiagnosticsConfigCreateInfoNV {}
unsafe impl Sync for DeviceDiagnosticsConfigCreateInfoNV {}
impl default::Default for DeviceDiagnosticsConfigCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: DeviceDiagnosticsConfigFlagsNV::default(),
        }
    }
}
impl fmt::Debug for DeviceDiagnosticsConfigCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDiagnosticsConfigCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_zero_initialize_workgroup_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {}
impl default::Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_zero_initialize_workgroup_memory",
                &self.shader_zero_initialize_workgroup_memory,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_uniform_control_flow: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
impl default::Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_subgroup_uniform_control_flow: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_subgroup_uniform_control_flow",
                &self.shader_subgroup_uniform_control_flow,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRobustness2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_buffer_access2: Bool32,
    pub robust_image_access2: Bool32,
    pub null_descriptor: Bool32,
}
unsafe impl Send for PhysicalDeviceRobustness2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceRobustness2FeaturesEXT {}
impl default::Default for PhysicalDeviceRobustness2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            robust_buffer_access2: Bool32::default(),
            robust_image_access2: Bool32::default(),
            null_descriptor: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRobustness2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRobustness2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_buffer_access2", &self.robust_buffer_access2)
            .field("robust_image_access2", &self.robust_image_access2)
            .field("null_descriptor", &self.null_descriptor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRobustness2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_storage_buffer_access_size_alignment: DeviceSize,
    pub robust_uniform_buffer_access_size_alignment: DeviceSize,
}
unsafe impl Send for PhysicalDeviceRobustness2PropertiesEXT {}
unsafe impl Sync for PhysicalDeviceRobustness2PropertiesEXT {}
impl default::Default for PhysicalDeviceRobustness2PropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            robust_storage_buffer_access_size_alignment: DeviceSize::default(),
            robust_uniform_buffer_access_size_alignment: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRobustness2PropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRobustness2PropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "robust_storage_buffer_access_size_alignment",
                &self.robust_storage_buffer_access_size_alignment,
            )
            .field(
                "robust_uniform_buffer_access_size_alignment",
                &self.robust_uniform_buffer_access_size_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageRobustnessFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
}
unsafe impl Send for PhysicalDeviceImageRobustnessFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImageRobustnessFeaturesEXT {}
impl default::Default for PhysicalDeviceImageRobustnessFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            robust_image_access: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageRobustnessFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageRobustnessFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_image_access", &self.robust_image_access)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub workgroup_memory_explicit_layout: Bool32,
    pub workgroup_memory_explicit_layout_scalar_block_layout: Bool32,
    pub workgroup_memory_explicit_layout8_bit_access: Bool32,
    pub workgroup_memory_explicit_layout16_bit_access: Bool32,
}
unsafe impl Send for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
impl default::Default for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            p_next: ptr::null_mut(),
            workgroup_memory_explicit_layout: Bool32::default(),
            workgroup_memory_explicit_layout_scalar_block_layout: Bool32::default(),
            workgroup_memory_explicit_layout8_bit_access: Bool32::default(),
            workgroup_memory_explicit_layout16_bit_access: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "workgroup_memory_explicit_layout",
                &self.workgroup_memory_explicit_layout,
            )
            .field(
                "workgroup_memory_explicit_layout_scalar_block_layout",
                &self.workgroup_memory_explicit_layout_scalar_block_layout,
            )
            .field(
                "workgroup_memory_explicit_layout8_bit_access",
                &self.workgroup_memory_explicit_layout8_bit_access,
            )
            .field(
                "workgroup_memory_explicit_layout16_bit_access",
                &self.workgroup_memory_explicit_layout16_bit_access,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub constant_alpha_color_blend_factors: Bool32,
    pub events: Bool32,
    pub image_view_format_reinterpretation: Bool32,
    pub image_view_format_swizzle: Bool32,
    pub image_view2_d_on3_d_image: Bool32,
    pub multisample_array_image: Bool32,
    pub mutable_comparison_samplers: Bool32,
    pub point_polygons: Bool32,
    pub sampler_mip_lod_bias: Bool32,
    pub separate_stencil_mask_ref: Bool32,
    pub shader_sample_rate_interpolation_functions: Bool32,
    pub tessellation_isolines: Bool32,
    pub tessellation_point_mode: Bool32,
    pub triangle_fans: Bool32,
    pub vertex_attribute_access_beyond_stride: Bool32,
}
unsafe impl Send for PhysicalDevicePortabilitySubsetFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePortabilitySubsetFeaturesKHR {}
impl default::Default for PhysicalDevicePortabilitySubsetFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            p_next: ptr::null_mut(),
            constant_alpha_color_blend_factors: Bool32::default(),
            events: Bool32::default(),
            image_view_format_reinterpretation: Bool32::default(),
            image_view_format_swizzle: Bool32::default(),
            image_view2_d_on3_d_image: Bool32::default(),
            multisample_array_image: Bool32::default(),
            mutable_comparison_samplers: Bool32::default(),
            point_polygons: Bool32::default(),
            sampler_mip_lod_bias: Bool32::default(),
            separate_stencil_mask_ref: Bool32::default(),
            shader_sample_rate_interpolation_functions: Bool32::default(),
            tessellation_isolines: Bool32::default(),
            tessellation_point_mode: Bool32::default(),
            triangle_fans: Bool32::default(),
            vertex_attribute_access_beyond_stride: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePortabilitySubsetFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePortabilitySubsetFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "constant_alpha_color_blend_factors",
                &self.constant_alpha_color_blend_factors,
            )
            .field("events", &self.events)
            .field(
                "image_view_format_reinterpretation",
                &self.image_view_format_reinterpretation,
            )
            .field("image_view_format_swizzle", &self.image_view_format_swizzle)
            .field("image_view2_d_on3_d_image", &self.image_view2_d_on3_d_image)
            .field("multisample_array_image", &self.multisample_array_image)
            .field("mutable_comparison_samplers", &self.mutable_comparison_samplers)
            .field("point_polygons", &self.point_polygons)
            .field("sampler_mip_lod_bias", &self.sampler_mip_lod_bias)
            .field("separate_stencil_mask_ref", &self.separate_stencil_mask_ref)
            .field(
                "shader_sample_rate_interpolation_functions",
                &self.shader_sample_rate_interpolation_functions,
            )
            .field("tessellation_isolines", &self.tessellation_isolines)
            .field("tessellation_point_mode", &self.tessellation_point_mode)
            .field("triangle_fans", &self.triangle_fans)
            .field(
                "vertex_attribute_access_beyond_stride",
                &self.vertex_attribute_access_beyond_stride,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_vertex_input_binding_stride_alignment: u32,
}
unsafe impl Send for PhysicalDevicePortabilitySubsetPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePortabilitySubsetPropertiesKHR {}
impl default::Default for PhysicalDevicePortabilitySubsetPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            min_vertex_input_binding_stride_alignment: u32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePortabilitySubsetPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePortabilitySubsetPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_vertex_input_binding_stride_alignment",
                &self.min_vertex_input_binding_stride_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice4444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_a4r4g4b4: Bool32,
    pub format_a4b4g4r4: Bool32,
}
unsafe impl Send for PhysicalDevice4444FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDevice4444FormatsFeaturesEXT {}
impl default::Default for PhysicalDevice4444FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            format_a4r4g4b4: Bool32::default(),
            format_a4b4g4r4: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice4444FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice4444FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_a4r4g4b4", &self.format_a4r4g4b4)
            .field("format_a4b4g4r4", &self.format_a4b4g4r4)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_shading: Bool32,
}
unsafe impl Send for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
unsafe impl Sync for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
impl default::Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            p_next: ptr::null_mut(),
            subpass_shading: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubpassShadingFeaturesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subpass_shading", &self.subpass_shading)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCopy2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Specified in bytes
    pub src_offset: DeviceSize,
    /// Specified in bytes
    pub dst_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
}
unsafe impl Send for BufferCopy2KHR {}
unsafe impl Sync for BufferCopy2KHR {}
impl default::Default for BufferCopy2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COPY_2_KHR,
            p_next: ptr::null(),
            src_offset: DeviceSize::default(),
            dst_offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BufferCopy2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCopy2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_offset", &self.src_offset)
            .field("dst_offset", &self.dst_offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCopy2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub extent: Extent3D,
}
unsafe impl Send for ImageCopy2KHR {}
unsafe impl Sync for ImageCopy2KHR {}
impl default::Default for ImageCopy2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_COPY_2_KHR,
            p_next: ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for ImageCopy2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCopy2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageBlit2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offsets: [Offset3D; 2],
}
unsafe impl Send for ImageBlit2KHR {}
unsafe impl Sync for ImageBlit2KHR {}
impl default::Default for ImageBlit2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_BLIT_2_KHR,
            p_next: ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: [Offset3D::default(); 2],
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: [Offset3D::default(); 2],
        }
    }
}
impl fmt::Debug for ImageBlit2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageBlit2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offsets", &self.src_offsets)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offsets", &self.dst_offsets)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferImageCopy2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Specified in bytes
    pub buffer_offset: DeviceSize,
    /// Specified in texels
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_extent: Extent3D,
}
unsafe impl Send for BufferImageCopy2KHR {}
unsafe impl Sync for BufferImageCopy2KHR {}
impl default::Default for BufferImageCopy2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_IMAGE_COPY_2_KHR,
            p_next: ptr::null(),
            buffer_offset: DeviceSize::default(),
            buffer_row_length: u32::default(),
            buffer_image_height: u32::default(),
            image_subresource: ImageSubresourceLayers::default(),
            image_offset: Offset3D::default(),
            image_extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for BufferImageCopy2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferImageCopy2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_offset", &self.buffer_offset)
            .field("buffer_row_length", &self.buffer_row_length)
            .field("buffer_image_height", &self.buffer_image_height)
            .field("image_subresource", &self.image_subresource)
            .field("image_offset", &self.image_offset)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageResolve2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
unsafe impl Send for ImageResolve2KHR {}
unsafe impl Sync for ImageResolve2KHR {}
impl default::Default for ImageResolve2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_RESOLVE_2_KHR,
            p_next: ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
impl fmt::Debug for ImageResolve2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageResolve2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyBufferInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Option<Buffer>,
    pub dst_buffer: Option<Buffer>,
    pub region_count: u32,
    pub p_regions: *const BufferCopy2KHR,
}
unsafe impl Send for CopyBufferInfo2KHR {}
unsafe impl Sync for CopyBufferInfo2KHR {}
impl default::Default for CopyBufferInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_BUFFER_INFO_2_KHR,
            p_next: ptr::null(),
            src_buffer: None,
            dst_buffer: None,
            region_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyBufferInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyBufferInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyImageInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageCopy2KHR,
}
unsafe impl Send for CopyImageInfo2KHR {}
unsafe impl Sync for CopyImageInfo2KHR {}
impl default::Default for CopyImageInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_IMAGE_INFO_2_KHR,
            p_next: ptr::null(),
            src_image: None,
            src_image_layout: ImageLayout::default(),
            dst_image: None,
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyImageInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyImageInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BlitImageInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageBlit2KHR,
    pub filter: Filter,
}
unsafe impl Send for BlitImageInfo2KHR {}
unsafe impl Sync for BlitImageInfo2KHR {}
impl default::Default for BlitImageInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BLIT_IMAGE_INFO_2_KHR,
            p_next: ptr::null(),
            src_image: None,
            src_image_layout: ImageLayout::default(),
            dst_image: None,
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ptr::null(),
            filter: Filter::default(),
        }
    }
}
impl fmt::Debug for BlitImageInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BlitImageInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .field("filter", &self.filter)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyBufferToImageInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Option<Buffer>,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2KHR,
}
unsafe impl Send for CopyBufferToImageInfo2KHR {}
unsafe impl Sync for CopyBufferToImageInfo2KHR {}
impl default::Default for CopyBufferToImageInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_BUFFER_TO_IMAGE_INFO_2_KHR,
            p_next: ptr::null(),
            src_buffer: None,
            dst_image: None,
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyBufferToImageInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyBufferToImageInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyImageToBufferInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_buffer: Option<Buffer>,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2KHR,
}
unsafe impl Send for CopyImageToBufferInfo2KHR {}
unsafe impl Sync for CopyImageToBufferInfo2KHR {}
impl default::Default for CopyImageToBufferInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_IMAGE_TO_BUFFER_INFO_2_KHR,
            p_next: ptr::null(),
            src_image: None,
            src_image_layout: ImageLayout::default(),
            dst_buffer: None,
            region_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyImageToBufferInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyImageToBufferInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResolveImageInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageResolve2KHR,
}
unsafe impl Send for ResolveImageInfo2KHR {}
unsafe impl Sync for ResolveImageInfo2KHR {}
impl default::Default for ResolveImageInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RESOLVE_IMAGE_INFO_2_KHR,
            p_next: ptr::null(),
            src_image: None,
            src_image_layout: ImageLayout::default(),
            dst_image: None,
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for ResolveImageInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ResolveImageInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_image_int64_atomics: Bool32,
    pub sparse_image_int64_atomics: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
impl default::Default for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_image_int64_atomics: Bool32::default(),
            sparse_image_int64_atomics: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderImageAtomicInt64FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_image_int64_atomics", &self.shader_image_int64_atomics)
            .field("sparse_image_int64_atomics", &self.sparse_image_int64_atomics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_fragment_shading_rate_attachment: *const AttachmentReference2,
    pub shading_rate_attachment_texel_size: Extent2D,
}
unsafe impl Send for FragmentShadingRateAttachmentInfoKHR {}
unsafe impl Sync for FragmentShadingRateAttachmentInfoKHR {}
impl default::Default for FragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: ptr::null(),
            p_fragment_shading_rate_attachment: ptr::null(),
            shading_rate_attachment_texel_size: Extent2D::default(),
        }
    }
}
impl fmt::Debug for FragmentShadingRateAttachmentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FragmentShadingRateAttachmentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "p_fragment_shading_rate_attachment",
                &self.p_fragment_shading_rate_attachment,
            )
            .field(
                "shading_rate_attachment_texel_size",
                &self.shading_rate_attachment_texel_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineFragmentShadingRateStateCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_size: Extent2D,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
unsafe impl Send for PipelineFragmentShadingRateStateCreateInfoKHR {}
unsafe impl Sync for PipelineFragmentShadingRateStateCreateInfoKHR {}
impl default::Default for PipelineFragmentShadingRateStateCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            fragment_size: Extent2D::default(),
            combiner_ops: [FragmentShadingRateCombinerOpKHR::default(); 2],
        }
    }
}
impl fmt::Debug for PipelineFragmentShadingRateStateCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineFragmentShadingRateStateCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_size", &self.fragment_size)
            .field("combiner_ops", &self.combiner_ops)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_fragment_shading_rate: Bool32,
    pub primitive_fragment_shading_rate: Bool32,
    pub attachment_fragment_shading_rate: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
impl default::Default for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            pipeline_fragment_shading_rate: Bool32::default(),
            primitive_fragment_shading_rate: Bool32::default(),
            attachment_fragment_shading_rate: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_fragment_shading_rate", &self.pipeline_fragment_shading_rate)
            .field("primitive_fragment_shading_rate", &self.primitive_fragment_shading_rate)
            .field(
                "attachment_fragment_shading_rate",
                &self.attachment_fragment_shading_rate,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    pub primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    pub layered_shading_rate_attachments: Bool32,
    pub fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    pub max_fragment_size: Extent2D,
    pub max_fragment_size_aspect_ratio: u32,
    pub max_fragment_shading_rate_coverage_samples: u32,
    pub max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    pub fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    pub fragment_shading_rate_with_sample_mask: Bool32,
    pub fragment_shading_rate_with_shader_sample_mask: Bool32,
    pub fragment_shading_rate_with_conservative_rasterization: Bool32,
    pub fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    pub fragment_shading_rate_with_custom_sample_locations: Bool32,
    pub fragment_shading_rate_strict_multiply_combiner: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRatePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRatePropertiesKHR {}
impl default::Default for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            min_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32::default(),
            primitive_fragment_shading_rate_with_multiple_viewports: Bool32::default(),
            layered_shading_rate_attachments: Bool32::default(),
            fragment_shading_rate_non_trivial_combiner_ops: Bool32::default(),
            max_fragment_size: Extent2D::default(),
            max_fragment_size_aspect_ratio: u32::default(),
            max_fragment_shading_rate_coverage_samples: u32::default(),
            max_fragment_shading_rate_rasterization_samples: SampleCountFlags::default(),
            fragment_shading_rate_with_shader_depth_stencil_writes: Bool32::default(),
            fragment_shading_rate_with_sample_mask: Bool32::default(),
            fragment_shading_rate_with_shader_sample_mask: Bool32::default(),
            fragment_shading_rate_with_conservative_rasterization: Bool32::default(),
            fragment_shading_rate_with_fragment_shader_interlock: Bool32::default(),
            fragment_shading_rate_with_custom_sample_locations: Bool32::default(),
            fragment_shading_rate_strict_multiply_combiner: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRatePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_fragment_shading_rate_attachment_texel_size",
                &self.min_fragment_shading_rate_attachment_texel_size,
            )
            .field(
                "max_fragment_shading_rate_attachment_texel_size",
                &self.max_fragment_shading_rate_attachment_texel_size,
            )
            .field(
                "max_fragment_shading_rate_attachment_texel_size_aspect_ratio",
                &self.max_fragment_shading_rate_attachment_texel_size_aspect_ratio,
            )
            .field(
                "primitive_fragment_shading_rate_with_multiple_viewports",
                &self.primitive_fragment_shading_rate_with_multiple_viewports,
            )
            .field(
                "layered_shading_rate_attachments",
                &self.layered_shading_rate_attachments,
            )
            .field(
                "fragment_shading_rate_non_trivial_combiner_ops",
                &self.fragment_shading_rate_non_trivial_combiner_ops,
            )
            .field("max_fragment_size", &self.max_fragment_size)
            .field("max_fragment_size_aspect_ratio", &self.max_fragment_size_aspect_ratio)
            .field(
                "max_fragment_shading_rate_coverage_samples",
                &self.max_fragment_shading_rate_coverage_samples,
            )
            .field(
                "max_fragment_shading_rate_rasterization_samples",
                &self.max_fragment_shading_rate_rasterization_samples,
            )
            .field(
                "fragment_shading_rate_with_shader_depth_stencil_writes",
                &self.fragment_shading_rate_with_shader_depth_stencil_writes,
            )
            .field(
                "fragment_shading_rate_with_sample_mask",
                &self.fragment_shading_rate_with_sample_mask,
            )
            .field(
                "fragment_shading_rate_with_shader_sample_mask",
                &self.fragment_shading_rate_with_shader_sample_mask,
            )
            .field(
                "fragment_shading_rate_with_conservative_rasterization",
                &self.fragment_shading_rate_with_conservative_rasterization,
            )
            .field(
                "fragment_shading_rate_with_fragment_shader_interlock",
                &self.fragment_shading_rate_with_fragment_shader_interlock,
            )
            .field(
                "fragment_shading_rate_with_custom_sample_locations",
                &self.fragment_shading_rate_with_custom_sample_locations,
            )
            .field(
                "fragment_shading_rate_strict_multiply_combiner",
                &self.fragment_shading_rate_strict_multiply_combiner,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_counts: SampleCountFlags,
    pub fragment_size: Extent2D,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateKHR {}
impl default::Default for PhysicalDeviceFragmentShadingRateKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
            p_next: ptr::null_mut(),
            sample_counts: SampleCountFlags::default(),
            fragment_size: Extent2D::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_counts", &self.sample_counts)
            .field("fragment_size", &self.fragment_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderTerminateInvocationFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_terminate_invocation: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {}
impl default::Default for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_terminate_invocation: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderTerminateInvocationFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_terminate_invocation", &self.shader_terminate_invocation)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shading_rate_enums: Bool32,
    pub supersample_fragment_shading_rates: Bool32,
    pub no_invocation_fragment_shading_rates: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
impl default::Default for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            p_next: ptr::null_mut(),
            fragment_shading_rate_enums: Bool32::default(),
            supersample_fragment_shading_rates: Bool32::default(),
            no_invocation_fragment_shading_rates: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateEnumsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_shading_rate_enums", &self.fragment_shading_rate_enums)
            .field(
                "supersample_fragment_shading_rates",
                &self.supersample_fragment_shading_rates,
            )
            .field(
                "no_invocation_fragment_shading_rates",
                &self.no_invocation_fragment_shading_rates,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_fragment_shading_rate_invocation_count: SampleCountFlags,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {}
impl default::Default for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_fragment_shading_rate_invocation_count: SampleCountFlags::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateEnumsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_fragment_shading_rate_invocation_count",
                &self.max_fragment_shading_rate_invocation_count,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_type: FragmentShadingRateTypeNV,
    pub shading_rate: FragmentShadingRateNV,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
unsafe impl Send for PipelineFragmentShadingRateEnumStateCreateInfoNV {}
unsafe impl Sync for PipelineFragmentShadingRateEnumStateCreateInfoNV {}
impl default::Default for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            shading_rate_type: FragmentShadingRateTypeNV::default(),
            shading_rate: FragmentShadingRateNV::default(),
            combiner_ops: [FragmentShadingRateCombinerOpKHR::default(); 2],
        }
    }
}
impl fmt::Debug for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineFragmentShadingRateEnumStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_type", &self.shading_rate_type)
            .field("shading_rate", &self.shading_rate)
            .field("combiner_ops", &self.combiner_ops)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureBuildSizesInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_size: DeviceSize,
    pub update_scratch_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
}
unsafe impl Send for AccelerationStructureBuildSizesInfoKHR {}
unsafe impl Sync for AccelerationStructureBuildSizesInfoKHR {}
impl default::Default for AccelerationStructureBuildSizesInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
            p_next: ptr::null(),
            acceleration_structure_size: DeviceSize::default(),
            update_scratch_size: DeviceSize::default(),
            build_scratch_size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureBuildSizesInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildSizesInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_size", &self.acceleration_structure_size)
            .field("update_scratch_size", &self.update_scratch_size)
            .field("build_scratch_size", &self.build_scratch_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub mutable_descriptor_type: Bool32,
}
unsafe impl Send for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
unsafe impl Sync for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
impl default::Default for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE,
            p_next: ptr::null_mut(),
            mutable_descriptor_type: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMutableDescriptorTypeFeaturesVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mutable_descriptor_type", &self.mutable_descriptor_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MutableDescriptorTypeListVALVE {
    pub descriptor_type_count: u32,
    pub p_descriptor_types: *const DescriptorType,
}
unsafe impl Send for MutableDescriptorTypeListVALVE {}
unsafe impl Sync for MutableDescriptorTypeListVALVE {}
impl default::Default for MutableDescriptorTypeListVALVE {
    fn default() -> Self {
        Self {
            descriptor_type_count: u32::default(),
            p_descriptor_types: ptr::null(),
        }
    }
}
impl fmt::Debug for MutableDescriptorTypeListVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MutableDescriptorTypeListVALVE")
            .field("descriptor_type_count", &self.descriptor_type_count)
            .field("p_descriptor_types", &self.p_descriptor_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MutableDescriptorTypeCreateInfoVALVE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mutable_descriptor_type_list_count: u32,
    pub p_mutable_descriptor_type_lists: *const MutableDescriptorTypeListVALVE,
}
unsafe impl Send for MutableDescriptorTypeCreateInfoVALVE {}
unsafe impl Sync for MutableDescriptorTypeCreateInfoVALVE {}
impl default::Default for MutableDescriptorTypeCreateInfoVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE,
            p_next: ptr::null(),
            mutable_descriptor_type_list_count: u32::default(),
            p_mutable_descriptor_type_lists: ptr::null(),
        }
    }
}
impl fmt::Debug for MutableDescriptorTypeCreateInfoVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MutableDescriptorTypeCreateInfoVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "mutable_descriptor_type_list_count",
                &self.mutable_descriptor_type_list_count,
            )
            .field("p_mutable_descriptor_type_lists", &self.p_mutable_descriptor_type_lists)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthClipControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_control: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthClipControlFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDepthClipControlFeaturesEXT {}
impl default::Default for PhysicalDeviceDepthClipControlFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            p_next: ptr::null_mut(),
            depth_clip_control: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthClipControlFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthClipControlFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_clip_control", &self.depth_clip_control)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportDepthClipControlCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub negative_one_to_one: Bool32,
}
unsafe impl Send for PipelineViewportDepthClipControlCreateInfoEXT {}
unsafe impl Sync for PipelineViewportDepthClipControlCreateInfoEXT {}
impl default::Default for PipelineViewportDepthClipControlCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            p_next: ptr::null(),
            negative_one_to_one: Bool32::default(),
        }
    }
}
impl fmt::Debug for PipelineViewportDepthClipControlCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportDepthClipControlCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("negative_one_to_one", &self.negative_one_to_one)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_input_dynamic_state: Bool32,
}
unsafe impl Send for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
impl default::Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            vertex_input_dynamic_state: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexInputDynamicStateFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_input_dynamic_state", &self.vertex_input_dynamic_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_rdma: Bool32,
}
unsafe impl Send for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
unsafe impl Sync for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
impl default::Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
            p_next: ptr::null_mut(),
            external_memory_rdma: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalMemoryRDMAFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_rdma", &self.external_memory_rdma)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VertexInputBindingDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
    pub divisor: u32,
}
unsafe impl Send for VertexInputBindingDescription2EXT {}
unsafe impl Sync for VertexInputBindingDescription2EXT {}
impl default::Default for VertexInputBindingDescription2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
            p_next: ptr::null_mut(),
            binding: u32::default(),
            stride: u32::default(),
            input_rate: VertexInputRate::default(),
            divisor: u32::default(),
        }
    }
}
impl fmt::Debug for VertexInputBindingDescription2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDescription2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("binding", &self.binding)
            .field("stride", &self.stride)
            .field("input_rate", &self.input_rate)
            .field("divisor", &self.divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VertexInputAttributeDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// location of the shader vertex attrib
    pub location: u32,
    /// Vertex buffer binding id
    pub binding: u32,
    /// format of source data
    pub format: Format,
    /// Offset of first element in bytes from base of vertex
    pub offset: u32,
}
unsafe impl Send for VertexInputAttributeDescription2EXT {}
unsafe impl Sync for VertexInputAttributeDescription2EXT {}
impl default::Default for VertexInputAttributeDescription2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
            p_next: ptr::null_mut(),
            location: u32::default(),
            binding: u32::default(),
            format: Format::default(),
            offset: u32::default(),
        }
    }
}
impl fmt::Debug for VertexInputAttributeDescription2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputAttributeDescription2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("location", &self.location)
            .field("binding", &self.binding)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub color_write_enable: Bool32,
}
unsafe impl Send for PhysicalDeviceColorWriteEnableFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceColorWriteEnableFeaturesEXT {}
impl default::Default for PhysicalDeviceColorWriteEnableFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            color_write_enable: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceColorWriteEnableFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceColorWriteEnableFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_write_enable", &self.color_write_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorWriteCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// # of pAttachments
    pub attachment_count: u32,
    pub p_color_write_enables: *const Bool32,
}
unsafe impl Send for PipelineColorWriteCreateInfoEXT {}
unsafe impl Sync for PipelineColorWriteCreateInfoEXT {}
impl default::Default for PipelineColorWriteCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            attachment_count: u32::default(),
            p_color_write_enables: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineColorWriteCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorWriteCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_count", &self.attachment_count)
            .field("p_color_write_enables", &self.p_color_write_enables)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryBarrier2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2KHR,
    pub src_access_mask: AccessFlags2KHR,
    pub dst_stage_mask: PipelineStageFlags2KHR,
    pub dst_access_mask: AccessFlags2KHR,
}
unsafe impl Send for MemoryBarrier2KHR {}
unsafe impl Sync for MemoryBarrier2KHR {}
impl default::Default for MemoryBarrier2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_BARRIER_2_KHR,
            p_next: ptr::null(),
            src_stage_mask: PipelineStageFlags2KHR::default(),
            src_access_mask: AccessFlags2KHR::default(),
            dst_stage_mask: PipelineStageFlags2KHR::default(),
            dst_access_mask: AccessFlags2KHR::default(),
        }
    }
}
impl fmt::Debug for MemoryBarrier2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryBarrier2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryBarrier2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2KHR,
    pub src_access_mask: AccessFlags2KHR,
    pub dst_stage_mask: PipelineStageFlags2KHR,
    pub dst_access_mask: AccessFlags2KHR,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Option<Image>,
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageMemoryBarrier2KHR {}
unsafe impl Sync for ImageMemoryBarrier2KHR {}
impl default::Default for ImageMemoryBarrier2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_BARRIER_2_KHR,
            p_next: ptr::null(),
            src_stage_mask: PipelineStageFlags2KHR::default(),
            src_access_mask: AccessFlags2KHR::default(),
            dst_stage_mask: PipelineStageFlags2KHR::default(),
            dst_access_mask: AccessFlags2KHR::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: None,
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
impl fmt::Debug for ImageMemoryBarrier2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryBarrier2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("old_layout", &self.old_layout)
            .field("new_layout", &self.new_layout)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("image", &self.image)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryBarrier2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2KHR,
    pub src_access_mask: AccessFlags2KHR,
    pub dst_stage_mask: PipelineStageFlags2KHR,
    pub dst_access_mask: AccessFlags2KHR,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
unsafe impl Send for BufferMemoryBarrier2KHR {}
unsafe impl Sync for BufferMemoryBarrier2KHR {}
impl default::Default for BufferMemoryBarrier2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_BARRIER_2_KHR,
            p_next: ptr::null(),
            src_stage_mask: PipelineStageFlags2KHR::default(),
            src_access_mask: AccessFlags2KHR::default(),
            dst_stage_mask: PipelineStageFlags2KHR::default(),
            dst_access_mask: AccessFlags2KHR::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: None,
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
impl fmt::Debug for BufferMemoryBarrier2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryBarrier2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DependencyInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dependency_flags: DependencyFlags,
    pub memory_barrier_count: u32,
    pub p_memory_barriers: *const MemoryBarrier2KHR,
    pub buffer_memory_barrier_count: u32,
    pub p_buffer_memory_barriers: *const BufferMemoryBarrier2KHR,
    pub image_memory_barrier_count: u32,
    pub p_image_memory_barriers: *const ImageMemoryBarrier2KHR,
}
unsafe impl Send for DependencyInfoKHR {}
unsafe impl Sync for DependencyInfoKHR {}
impl default::Default for DependencyInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEPENDENCY_INFO_KHR,
            p_next: ptr::null(),
            dependency_flags: DependencyFlags::default(),
            memory_barrier_count: u32::default(),
            p_memory_barriers: ptr::null(),
            buffer_memory_barrier_count: u32::default(),
            p_buffer_memory_barriers: ptr::null(),
            image_memory_barrier_count: u32::default(),
            p_image_memory_barriers: ptr::null(),
        }
    }
}
impl fmt::Debug for DependencyInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DependencyInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dependency_flags", &self.dependency_flags)
            .field("memory_barrier_count", &self.memory_barrier_count)
            .field("p_memory_barriers", &self.p_memory_barriers)
            .field("buffer_memory_barrier_count", &self.buffer_memory_barrier_count)
            .field("p_buffer_memory_barriers", &self.p_buffer_memory_barriers)
            .field("image_memory_barrier_count", &self.image_memory_barrier_count)
            .field("p_image_memory_barriers", &self.p_image_memory_barriers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreSubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
    pub stage_mask: PipelineStageFlags2KHR,
    pub device_index: u32,
}
unsafe impl Send for SemaphoreSubmitInfoKHR {}
unsafe impl Sync for SemaphoreSubmitInfoKHR {}
impl default::Default for SemaphoreSubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            semaphore: None,
            value: u64::default(),
            stage_mask: PipelineStageFlags2KHR::default(),
            device_index: u32::default(),
        }
    }
}
impl fmt::Debug for SemaphoreSubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreSubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("value", &self.value)
            .field("stage_mask", &self.stage_mask)
            .field("device_index", &self.device_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferSubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_buffer: Option<CommandBuffer>,
    pub device_mask: u32,
}
unsafe impl Send for CommandBufferSubmitInfoKHR {}
unsafe impl Sync for CommandBufferSubmitInfoKHR {}
impl default::Default for CommandBufferSubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            command_buffer: None,
            device_mask: u32::default(),
        }
    }
}
impl fmt::Debug for CommandBufferSubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferSubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("command_buffer", &self.command_buffer)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubmitInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubmitFlagsKHR,
    pub wait_semaphore_info_count: u32,
    pub p_wait_semaphore_infos: *const SemaphoreSubmitInfoKHR,
    pub command_buffer_info_count: u32,
    pub p_command_buffer_infos: *const CommandBufferSubmitInfoKHR,
    pub signal_semaphore_info_count: u32,
    pub p_signal_semaphore_infos: *const SemaphoreSubmitInfoKHR,
}
unsafe impl Send for SubmitInfo2KHR {}
unsafe impl Sync for SubmitInfo2KHR {}
impl default::Default for SubmitInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBMIT_INFO_2_KHR,
            p_next: ptr::null(),
            flags: SubmitFlagsKHR::default(),
            wait_semaphore_info_count: u32::default(),
            p_wait_semaphore_infos: ptr::null(),
            command_buffer_info_count: u32::default(),
            p_command_buffer_infos: ptr::null(),
            signal_semaphore_info_count: u32::default(),
            p_signal_semaphore_infos: ptr::null(),
        }
    }
}
impl fmt::Debug for SubmitInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubmitInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("wait_semaphore_info_count", &self.wait_semaphore_info_count)
            .field("p_wait_semaphore_infos", &self.p_wait_semaphore_infos)
            .field("command_buffer_info_count", &self.command_buffer_info_count)
            .field("p_command_buffer_infos", &self.p_command_buffer_infos)
            .field("signal_semaphore_info_count", &self.signal_semaphore_info_count)
            .field("p_signal_semaphore_infos", &self.p_signal_semaphore_infos)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyCheckpointProperties2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags2KHR,
}
unsafe impl Send for QueueFamilyCheckpointProperties2NV {}
unsafe impl Sync for QueueFamilyCheckpointProperties2NV {}
impl default::Default for QueueFamilyCheckpointProperties2NV {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV,
            p_next: ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags2KHR::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyCheckpointProperties2NV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyCheckpointProperties2NV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("checkpoint_execution_stage_mask", &self.checkpoint_execution_stage_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CheckpointData2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags2KHR,
    pub p_checkpoint_marker: *mut c_void,
}
unsafe impl Send for CheckpointData2NV {}
unsafe impl Sync for CheckpointData2NV {}
impl default::Default for CheckpointData2NV {
    fn default() -> Self {
        Self {
            s_type: StructureType::CHECKPOINT_DATA_2_NV,
            p_next: ptr::null_mut(),
            stage: PipelineStageFlags2KHR::default(),
            p_checkpoint_marker: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for CheckpointData2NV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CheckpointData2NV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage", &self.stage)
            .field("p_checkpoint_marker", &self.p_checkpoint_marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSynchronization2FeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub synchronization2: Bool32,
}
unsafe impl Send for PhysicalDeviceSynchronization2FeaturesKHR {}
unsafe impl Sync for PhysicalDeviceSynchronization2FeaturesKHR {}
impl default::Default for PhysicalDeviceSynchronization2FeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR,
            p_next: ptr::null_mut(),
            synchronization2: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSynchronization2FeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSynchronization2FeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("synchronization2", &self.synchronization2)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inherited_viewport_scissor2_d: Bool32,
}
unsafe impl Send for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
unsafe impl Sync for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
impl default::Default for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            p_next: ptr::null_mut(),
            inherited_viewport_scissor2_d: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInheritedViewportScissorFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("inherited_viewport_scissor2_d", &self.inherited_viewport_scissor2_d)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceViewportScissorInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_scissor2_d: Bool32,
    pub viewport_depth_count: u32,
    pub p_viewport_depths: *const Viewport,
}
unsafe impl Send for CommandBufferInheritanceViewportScissorInfoNV {}
unsafe impl Sync for CommandBufferInheritanceViewportScissorInfoNV {}
impl default::Default for CommandBufferInheritanceViewportScissorInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
            p_next: ptr::null(),
            viewport_scissor2_d: Bool32::default(),
            viewport_depth_count: u32::default(),
            p_viewport_depths: ptr::null(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceViewportScissorInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceViewportScissorInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("viewport_scissor2_d", &self.viewport_scissor2_d)
            .field("viewport_depth_count", &self.viewport_depth_count)
            .field("p_viewport_depths", &self.p_viewport_depths)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr2plane444_formats: Bool32,
}
unsafe impl Send for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
impl default::Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            ycbcr2plane444_formats: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ycbcr2plane444_formats", &self.ycbcr2plane444_formats)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProvokingVertexFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_last: Bool32,
    pub transform_feedback_preserves_provoking_vertex: Bool32,
}
unsafe impl Send for PhysicalDeviceProvokingVertexFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceProvokingVertexFeaturesEXT {}
impl default::Default for PhysicalDeviceProvokingVertexFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            p_next: ptr::null_mut(),
            provoking_vertex_last: Bool32::default(),
            transform_feedback_preserves_provoking_vertex: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProvokingVertexFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProvokingVertexFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("provoking_vertex_last", &self.provoking_vertex_last)
            .field(
                "transform_feedback_preserves_provoking_vertex",
                &self.transform_feedback_preserves_provoking_vertex,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProvokingVertexPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_mode_per_pipeline: Bool32,
    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
}
unsafe impl Send for PhysicalDeviceProvokingVertexPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceProvokingVertexPropertiesEXT {}
impl default::Default for PhysicalDeviceProvokingVertexPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            provoking_vertex_mode_per_pipeline: Bool32::default(),
            transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProvokingVertexPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProvokingVertexPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "provoking_vertex_mode_per_pipeline",
                &self.provoking_vertex_mode_per_pipeline,
            )
            .field(
                "transform_feedback_preserves_triangle_fan_provoking_vertex",
                &self.transform_feedback_preserves_triangle_fan_provoking_vertex,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub provoking_vertex_mode: ProvokingVertexModeEXT,
}
unsafe impl Send for PipelineRasterizationProvokingVertexStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationProvokingVertexStateCreateInfoEXT {}
impl default::Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            provoking_vertex_mode: ProvokingVertexModeEXT::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationProvokingVertexStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("provoking_vertex_mode", &self.provoking_vertex_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuModuleCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: usize,
    pub p_data: *const c_void,
}
unsafe impl Send for CuModuleCreateInfoNVX {}
unsafe impl Sync for CuModuleCreateInfoNVX {}
impl default::Default for CuModuleCreateInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_MODULE_CREATE_INFO_NVX,
            p_next: ptr::null(),
            data_size: usize::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for CuModuleCreateInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuModuleCreateInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuFunctionCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub module: Option<CuModuleNVX>,
    pub p_name: *const c_char,
}
unsafe impl Send for CuFunctionCreateInfoNVX {}
unsafe impl Sync for CuFunctionCreateInfoNVX {}
impl default::Default for CuFunctionCreateInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_FUNCTION_CREATE_INFO_NVX,
            p_next: ptr::null(),
            module: None,
            p_name: ptr::null(),
        }
    }
}
impl fmt::Debug for CuFunctionCreateInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuFunctionCreateInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("module", &self.module)
            .field("p_name", &self.p_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuLaunchInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub function: Option<CuFunctionNVX>,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub param_count: usize,
    pub p_params: *const *const c_void,
    pub extra_count: usize,
    pub p_extras: *const *const c_void,
}
unsafe impl Send for CuLaunchInfoNVX {}
unsafe impl Sync for CuLaunchInfoNVX {}
impl default::Default for CuLaunchInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_LAUNCH_INFO_NVX,
            p_next: ptr::null(),
            function: None,
            grid_dim_x: u32::default(),
            grid_dim_y: u32::default(),
            grid_dim_z: u32::default(),
            block_dim_x: u32::default(),
            block_dim_y: u32::default(),
            block_dim_z: u32::default(),
            shared_mem_bytes: u32::default(),
            param_count: usize::default(),
            p_params: ptr::null(),
            extra_count: usize::default(),
            p_extras: ptr::null(),
        }
    }
}
impl fmt::Debug for CuLaunchInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuLaunchInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("function", &self.function)
            .field("grid_dim_x", &self.grid_dim_x)
            .field("grid_dim_y", &self.grid_dim_y)
            .field("grid_dim_z", &self.grid_dim_z)
            .field("block_dim_x", &self.block_dim_x)
            .field("block_dim_y", &self.block_dim_y)
            .field("block_dim_z", &self.block_dim_z)
            .field("shared_mem_bytes", &self.shared_mem_bytes)
            .field("param_count", &self.param_count)
            .field("p_params", &self.p_params)
            .field("extra_count", &self.extra_count)
            .field("p_extras", &self.p_extras)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerDotProductFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_dot_product: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerDotProductFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderIntegerDotProductFeaturesKHR {}
impl default::Default for PhysicalDeviceShaderIntegerDotProductFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_integer_dot_product: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerDotProductFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerDotProductFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_integer_dot_product", &self.shader_integer_dot_product)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerDotProductPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerDotProductPropertiesKHR {}
unsafe impl Sync for PhysicalDeviceShaderIntegerDotProductPropertiesKHR {}
impl default::Default for PhysicalDeviceShaderIntegerDotProductPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            integer_dot_product8_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product8_bit_signed_accelerated: Bool32::default(),
            integer_dot_product8_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32::default(),
            integer_dot_product4x8_bit_packed_signed_accelerated: Bool32::default(),
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product16_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product16_bit_signed_accelerated: Bool32::default(),
            integer_dot_product16_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product32_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product32_bit_signed_accelerated: Bool32::default(),
            integer_dot_product32_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product64_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product64_bit_signed_accelerated: Bool32::default(),
            integer_dot_product64_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32::default(),
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerDotProductPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerDotProductPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "integer_dot_product8_bit_unsigned_accelerated",
                &self.integer_dot_product8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product8_bit_signed_accelerated",
                &self.integer_dot_product8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product16_bit_unsigned_accelerated",
                &self.integer_dot_product16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product16_bit_signed_accelerated",
                &self.integer_dot_product16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product32_bit_unsigned_accelerated",
                &self.integer_dot_product32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product32_bit_signed_accelerated",
                &self.integer_dot_product32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product64_bit_unsigned_accelerated",
                &self.integer_dot_product64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product64_bit_signed_accelerated",
                &self.integer_dot_product64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product64_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDrmPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub has_primary: Bool32,
    pub has_render: Bool32,
    pub primary_major: i64,
    pub primary_minor: i64,
    pub render_major: i64,
    pub render_minor: i64,
}
unsafe impl Send for PhysicalDeviceDrmPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceDrmPropertiesEXT {}
impl default::Default for PhysicalDeviceDrmPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            has_primary: Bool32::default(),
            has_render: Bool32::default(),
            primary_major: i64::default(),
            primary_minor: i64::default(),
            render_major: i64::default(),
            render_minor: i64::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDrmPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDrmPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("has_primary", &self.has_primary)
            .field("has_render", &self.has_render)
            .field("primary_major", &self.primary_major)
            .field("primary_minor", &self.primary_minor)
            .field("render_major", &self.render_major)
            .field("render_minor", &self.render_minor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_motion_blur: Bool32,
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
}
unsafe impl Send for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
unsafe impl Sync for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
impl default::Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            p_next: ptr::null_mut(),
            ray_tracing_motion_blur: Bool32::default(),
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingMotionBlurFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_tracing_motion_blur", &self.ray_tracing_motion_blur)
            .field(
                "ray_tracing_motion_blur_pipeline_trace_rays_indirect",
                &self.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            )
            .finish()
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInstanceTypeNV(i32);
impl AccelerationStructureMotionInstanceTypeNV {
    pub const STATIC: Self = Self(0);
    pub const MATRIX_MOTION: Self = Self(1);
    pub const SRT_MOTION: Self = Self(2);
}
impl default::Default for AccelerationStructureMotionInstanceTypeNV {
    fn default() -> Self {
        Self(0)
    }
}
impl fmt::Display for AccelerationStructureMotionInstanceTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STATIC"),
            1 => Some(&"MATRIX_MOTION"),
            2 => Some(&"SRT_MOTION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryMotionTrianglesDataNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryMotionTrianglesDataNV {}
unsafe impl Sync for AccelerationStructureGeometryMotionTrianglesDataNV {}
impl default::Default for AccelerationStructureGeometryMotionTrianglesDataNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
            p_next: ptr::null(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryMotionTrianglesDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryMotionTrianglesDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &self.vertex_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMotionInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_instances: u32,
    pub flags: AccelerationStructureMotionInfoFlagsNV,
}
unsafe impl Send for AccelerationStructureMotionInfoNV {}
unsafe impl Sync for AccelerationStructureMotionInfoNV {}
impl default::Default for AccelerationStructureMotionInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            p_next: ptr::null(),
            max_instances: u32::default(),
            flags: AccelerationStructureMotionInfoFlagsNV::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureMotionInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_instances", &self.max_instances)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
impl default::Default for SRTDataNV {
    fn default() -> Self {
        Self {
            sx: f32::default(),
            a: f32::default(),
            b: f32::default(),
            pvx: f32::default(),
            sy: f32::default(),
            c: f32::default(),
            pvy: f32::default(),
            sz: f32::default(),
            pvz: f32::default(),
            qx: f32::default(),
            qy: f32::default(),
            qz: f32::default(),
            qw: f32::default(),
            tx: f32::default(),
            ty: f32::default(),
            tz: f32::default(),
        }
    }
}
impl fmt::Debug for SRTDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SRTDataNV")
            .field("sx", &self.sx)
            .field("a", &self.a)
            .field("b", &self.b)
            .field("pvx", &self.pvx)
            .field("sy", &self.sy)
            .field("c", &self.c)
            .field("pvy", &self.pvy)
            .field("sz", &self.sz)
            .field("pvz", &self.pvz)
            .field("qx", &self.qx)
            .field("qy", &self.qy)
            .field("qz", &self.qz)
            .field("qw", &self.qw)
            .field("tx", &self.tx)
            .field("ty", &self.ty)
            .field("tz", &self.tz)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureSRTMotionInstanceNV {
    pub transform_t0: SRTDataNV,
    pub transform_t1: SRTDataNV,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl default::Default for AccelerationStructureSRTMotionInstanceNV {
    fn default() -> Self {
        Self {
            transform_t0: SRTDataNV::default(),
            transform_t1: SRTDataNV::default(),
            instance_custom_index_and_mask: u32::default(),
            instance_shader_binding_table_record_offset_and_flags: u32::default(),
            acceleration_structure_reference: u64::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureSRTMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureSRTMotionInstanceNV")
            .field("transform_t0", &self.transform_t0)
            .field("transform_t1", &self.transform_t1)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMatrixMotionInstanceNV {
    pub transform_t0: TransformMatrixKHR,
    pub transform_t1: TransformMatrixKHR,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl default::Default for AccelerationStructureMatrixMotionInstanceNV {
    fn default() -> Self {
        Self {
            transform_t0: TransformMatrixKHR::default(),
            transform_t1: TransformMatrixKHR::default(),
            instance_custom_index_and_mask: u32::default(),
            instance_shader_binding_table_record_offset_and_flags: u32::default(),
            acceleration_structure_reference: u64::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureMatrixMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMatrixMotionInstanceNV")
            .field("transform_t0", &self.transform_t0)
            .field("transform_t1", &self.transform_t1)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureMotionInstanceDataNV {
    pub static_instance: AccelerationStructureInstanceKHR,
    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
}
impl default::Default for AccelerationStructureMotionInstanceDataNV {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for AccelerationStructureMotionInstanceDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceDataNV")
            .field("static_instance", unsafe { &self.static_instance })
            .field("matrix_motion_instance", unsafe { &self.matrix_motion_instance })
            .field("srt_motion_instance", unsafe { &self.srt_motion_instance })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMotionInstanceNV {
    pub ty: AccelerationStructureMotionInstanceTypeNV,
    pub flags: AccelerationStructureMotionInstanceFlagsNV,
    pub data: AccelerationStructureMotionInstanceDataNV,
}
impl default::Default for AccelerationStructureMotionInstanceNV {
    fn default() -> Self {
        Self {
            ty: AccelerationStructureMotionInstanceTypeNV::default(),
            flags: AccelerationStructureMotionInstanceFlagsNV::default(),
            data: AccelerationStructureMotionInstanceDataNV::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceNV")
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("data", &self.data)
            .finish()
    }
}
pub type RemoteAddressNV = *mut c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetRemoteAddressInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetRemoteAddressInfoNV {}
unsafe impl Sync for MemoryGetRemoteAddressInfoNV {}
impl default::Default for MemoryGetRemoteAddressInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
            p_next: ptr::null(),
            memory: None,
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
impl fmt::Debug for MemoryGetRemoteAddressInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetRemoteAddressInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryBufferCollectionFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for ImportMemoryBufferCollectionFUCHSIA {}
unsafe impl Sync for ImportMemoryBufferCollectionFUCHSIA {}
impl default::Default for ImportMemoryBufferCollectionFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
            p_next: ptr::null(),
            collection: None,
            index: u32::default(),
        }
    }
}
impl fmt::Debug for ImportMemoryBufferCollectionFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryBufferCollectionFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionImageCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for BufferCollectionImageCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionImageCreateInfoFUCHSIA {}
impl default::Default for BufferCollectionImageCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection: None,
            index: u32::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionImageCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionImageCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionBufferCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for BufferCollectionBufferCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionBufferCreateInfoFUCHSIA {}
impl default::Default for BufferCollectionBufferCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection: None,
            index: u32::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionBufferCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionBufferCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection_token: zx_handle_t,
}
unsafe impl Send for BufferCollectionCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionCreateInfoFUCHSIA {}
impl default::Default for BufferCollectionCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection_token: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for BufferCollectionCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection_token", &self.collection_token)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionPropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub buffer_count: u32,
    pub create_info_index: u32,
    pub sysmem_pixel_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sysmem_color_space_index: SysmemColorSpaceFUCHSIA,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for BufferCollectionPropertiesFUCHSIA {}
unsafe impl Sync for BufferCollectionPropertiesFUCHSIA {}
impl default::Default for BufferCollectionPropertiesFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
            p_next: ptr::null_mut(),
            memory_type_bits: u32::default(),
            buffer_count: u32::default(),
            create_info_index: u32::default(),
            sysmem_pixel_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sysmem_color_space_index: SysmemColorSpaceFUCHSIA::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionPropertiesFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionPropertiesFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .field("buffer_count", &self.buffer_count)
            .field("create_info_index", &self.create_info_index)
            .field("sysmem_pixel_format", &self.sysmem_pixel_format)
            .field("format_features", &self.format_features)
            .field("sysmem_color_space_index", &self.sysmem_color_space_index)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_info: BufferCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
}
unsafe impl Send for BufferConstraintsInfoFUCHSIA {}
unsafe impl Sync for BufferConstraintsInfoFUCHSIA {}
impl default::Default for BufferConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            create_info: BufferCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
        }
    }
}
impl fmt::Debug for BufferConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("create_info", &self.create_info)
            .field("required_format_features", &self.required_format_features)
            .field("buffer_collection_constraints", &self.buffer_collection_constraints)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SysmemColorSpaceFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_space: u32,
}
unsafe impl Send for SysmemColorSpaceFUCHSIA {}
unsafe impl Sync for SysmemColorSpaceFUCHSIA {}
impl default::Default for SysmemColorSpaceFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::SYSMEM_COLOR_SPACE_FUCHSIA,
            p_next: ptr::null(),
            color_space: u32::default(),
        }
    }
}
impl fmt::Debug for SysmemColorSpaceFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SysmemColorSpaceFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_space", &self.color_space)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_create_info: ImageCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub flags: ImageFormatConstraintsFlagsFUCHSIA,
    pub sysmem_pixel_format: u64,
    pub color_space_count: u32,
    pub p_color_spaces: *const SysmemColorSpaceFUCHSIA,
}
unsafe impl Send for ImageFormatConstraintsInfoFUCHSIA {}
unsafe impl Sync for ImageFormatConstraintsInfoFUCHSIA {}
impl default::Default for ImageFormatConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            image_create_info: ImageCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            flags: ImageFormatConstraintsFlagsFUCHSIA::default(),
            sysmem_pixel_format: u64::default(),
            color_space_count: u32::default(),
            p_color_spaces: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageFormatConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_create_info", &self.image_create_info)
            .field("required_format_features", &self.required_format_features)
            .field("flags", &self.flags)
            .field("sysmem_pixel_format", &self.sysmem_pixel_format)
            .field("color_space_count", &self.color_space_count)
            .field("p_color_spaces", &self.p_color_spaces)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format_constraints_count: u32,
    pub p_format_constraints: *const ImageFormatConstraintsInfoFUCHSIA,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    pub flags: ImageConstraintsInfoFlagsFUCHSIA,
}
unsafe impl Send for ImageConstraintsInfoFUCHSIA {}
unsafe impl Sync for ImageConstraintsInfoFUCHSIA {}
impl default::Default for ImageConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            format_constraints_count: u32::default(),
            p_format_constraints: ptr::null(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
            flags: ImageConstraintsInfoFlagsFUCHSIA::default(),
        }
    }
}
impl fmt::Debug for ImageConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_constraints_count", &self.format_constraints_count)
            .field("p_format_constraints", &self.p_format_constraints)
            .field("buffer_collection_constraints", &self.buffer_collection_constraints)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_buffer_count: u32,
    pub max_buffer_count: u32,
    pub min_buffer_count_for_camping: u32,
    pub min_buffer_count_for_dedicated_slack: u32,
    pub min_buffer_count_for_shared_slack: u32,
}
unsafe impl Send for BufferCollectionConstraintsInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionConstraintsInfoFUCHSIA {}
impl default::Default for BufferCollectionConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            min_buffer_count: u32::default(),
            max_buffer_count: u32::default(),
            min_buffer_count_for_camping: u32::default(),
            min_buffer_count_for_dedicated_slack: u32::default(),
            min_buffer_count_for_shared_slack: u32::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_buffer_count", &self.min_buffer_count)
            .field("max_buffer_count", &self.max_buffer_count)
            .field("min_buffer_count_for_camping", &self.min_buffer_count_for_camping)
            .field(
                "min_buffer_count_for_dedicated_slack",
                &self.min_buffer_count_for_dedicated_slack,
            )
            .field(
                "min_buffer_count_for_shared_slack",
                &self.min_buffer_count_for_shared_slack,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_rgba10x6_without_y_cb_cr_sampler: Bool32,
}
unsafe impl Send for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
impl default::Default for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            format_rgba10x6_without_y_cb_cr_sampler: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRGBA10X6FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "format_rgba10x6_without_y_cb_cr_sampler",
                &self.format_rgba10x6_without_y_cb_cr_sampler,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormatProperties3KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_tiling_features: FormatFeatureFlags2KHR,
    pub optimal_tiling_features: FormatFeatureFlags2KHR,
    pub buffer_features: FormatFeatureFlags2KHR,
}
unsafe impl Send for FormatProperties3KHR {}
unsafe impl Sync for FormatProperties3KHR {}
impl default::Default for FormatProperties3KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FORMAT_PROPERTIES_3_KHR,
            p_next: ptr::null_mut(),
            linear_tiling_features: FormatFeatureFlags2KHR::default(),
            optimal_tiling_features: FormatFeatureFlags2KHR::default(),
            buffer_features: FormatFeatureFlags2KHR::default(),
        }
    }
}
impl fmt::Debug for FormatProperties3KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties3KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("linear_tiling_features", &self.linear_tiling_features)
            .field("optimal_tiling_features", &self.optimal_tiling_features)
            .field("buffer_features", &self.buffer_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DrmFormatModifierPropertiesList2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierProperties2EXT,
}
unsafe impl Send for DrmFormatModifierPropertiesList2EXT {}
unsafe impl Sync for DrmFormatModifierPropertiesList2EXT {}
impl default::Default for DrmFormatModifierPropertiesList2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierPropertiesList2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesList2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field(
                "p_drm_format_modifier_properties",
                &self.p_drm_format_modifier_properties,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DrmFormatModifierProperties2EXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags2KHR,
}
impl default::Default for DrmFormatModifierProperties2EXT {
    fn default() -> Self {
        Self {
            drm_format_modifier: u64::default(),
            drm_format_modifier_plane_count: u32::default(),
            drm_format_modifier_tiling_features: FormatFeatureFlags2KHR::default(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierProperties2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierProperties2EXT")
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field(
                "drm_format_modifier_tiling_features",
                &self.drm_format_modifier_tiling_features,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferFormatProperties2ANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags2KHR,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for AndroidHardwareBufferFormatProperties2ANDROID {}
unsafe impl Sync for AndroidHardwareBufferFormatProperties2ANDROID {}
impl default::Default for AndroidHardwareBufferFormatProperties2ANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            p_next: ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags2KHR::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferFormatProperties2ANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferFormatProperties2ANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("external_format", &self.external_format)
            .field("format_features", &self.format_features)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRenderingCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
}
unsafe impl Send for PipelineRenderingCreateInfoKHR {}
unsafe impl Sync for PipelineRenderingCreateInfoKHR {}
impl default::Default for PipelineRenderingCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RENDERING_CREATE_INFO_KHR,
            p_next: ptr::null(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
        }
    }
}
impl fmt::Debug for PipelineRenderingCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRenderingCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlagsKHR,
    pub render_area: Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const RenderingAttachmentInfoKHR,
    pub p_depth_attachment: *const RenderingAttachmentInfoKHR,
    pub p_stencil_attachment: *const RenderingAttachmentInfoKHR,
}
unsafe impl Send for RenderingInfoKHR {}
unsafe impl Sync for RenderingInfoKHR {}
impl default::Default for RenderingInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_INFO_KHR,
            p_next: ptr::null(),
            flags: RenderingFlagsKHR::default(),
            render_area: Rect2D::default(),
            layer_count: u32::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachments: ptr::null(),
            p_depth_attachment: ptr::null(),
            p_stencil_attachment: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderingInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("render_area", &self.render_area)
            .field("layer_count", &self.layer_count)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_depth_attachment", &self.p_depth_attachment)
            .field("p_stencil_attachment", &self.p_stencil_attachment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub resolve_mode: ResolveModeFlags,
    pub resolve_image_view: Option<ImageView>,
    pub resolve_image_layout: ImageLayout,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub clear_value: ClearValue,
}
unsafe impl Send for RenderingAttachmentInfoKHR {}
unsafe impl Sync for RenderingAttachmentInfoKHR {}
impl default::Default for RenderingAttachmentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_ATTACHMENT_INFO_KHR,
            p_next: ptr::null(),
            image_view: None,
            image_layout: ImageLayout::default(),
            resolve_mode: ResolveModeFlags::default(),
            resolve_image_view: None,
            resolve_image_layout: ImageLayout::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            clear_value: ClearValue::default(),
        }
    }
}
impl fmt::Debug for RenderingAttachmentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingAttachmentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field("resolve_mode", &self.resolve_mode)
            .field("resolve_image_view", &self.resolve_image_view)
            .field("resolve_image_layout", &self.resolve_image_layout)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("clear_value", &self.clear_value)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingFragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub shading_rate_attachment_texel_size: Extent2D,
}
unsafe impl Send for RenderingFragmentShadingRateAttachmentInfoKHR {}
unsafe impl Sync for RenderingFragmentShadingRateAttachmentInfoKHR {}
impl default::Default for RenderingFragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: ptr::null(),
            image_view: None,
            image_layout: ImageLayout::default(),
            shading_rate_attachment_texel_size: Extent2D::default(),
        }
    }
}
impl fmt::Debug for RenderingFragmentShadingRateAttachmentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingFragmentShadingRateAttachmentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field(
                "shading_rate_attachment_texel_size",
                &self.shading_rate_attachment_texel_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingFragmentDensityMapAttachmentInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
}
unsafe impl Send for RenderingFragmentDensityMapAttachmentInfoEXT {}
unsafe impl Sync for RenderingFragmentDensityMapAttachmentInfoEXT {}
impl default::Default for RenderingFragmentDensityMapAttachmentInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            p_next: ptr::null(),
            image_view: None,
            image_layout: ImageLayout::default(),
        }
    }
}
impl fmt::Debug for RenderingFragmentDensityMapAttachmentInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingFragmentDensityMapAttachmentInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDynamicRenderingFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_rendering: Bool32,
}
unsafe impl Send for PhysicalDeviceDynamicRenderingFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceDynamicRenderingFeaturesKHR {}
impl default::Default for PhysicalDeviceDynamicRenderingFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR,
            p_next: ptr::null_mut(),
            dynamic_rendering: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDynamicRenderingFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDynamicRenderingFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dynamic_rendering", &self.dynamic_rendering)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceRenderingInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlagsKHR,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub rasterization_samples: SampleCountFlags,
}
unsafe impl Send for CommandBufferInheritanceRenderingInfoKHR {}
unsafe impl Sync for CommandBufferInheritanceRenderingInfoKHR {}
impl default::Default for CommandBufferInheritanceRenderingInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR,
            p_next: ptr::null(),
            flags: RenderingFlagsKHR::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
            rasterization_samples: SampleCountFlags::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceRenderingInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceRenderingInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .field("rasterization_samples", &self.rasterization_samples)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentSampleCountInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_attachment_count: u32,
    pub p_color_attachment_samples: *const SampleCountFlags,
    pub depth_stencil_attachment_samples: SampleCountFlags,
}
unsafe impl Send for AttachmentSampleCountInfoAMD {}
unsafe impl Sync for AttachmentSampleCountInfoAMD {}
impl default::Default for AttachmentSampleCountInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
            p_next: ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachment_samples: ptr::null(),
            depth_stencil_attachment_samples: SampleCountFlags::default(),
        }
    }
}
impl fmt::Debug for AttachmentSampleCountInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentSampleCountInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_samples", &self.p_color_attachment_samples)
            .field(
                "depth_stencil_attachment_samples",
                &self.depth_stencil_attachment_samples,
            )
            .finish()
    }
}
pub type AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MultiviewPerViewAttributesInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub per_view_attributes: Bool32,
    pub per_view_attributes_position_x_only: Bool32,
}
unsafe impl Send for MultiviewPerViewAttributesInfoNVX {}
unsafe impl Sync for MultiviewPerViewAttributesInfoNVX {}
impl default::Default for MultiviewPerViewAttributesInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            p_next: ptr::null(),
            per_view_attributes: Bool32::default(),
            per_view_attributes_position_x_only: Bool32::default(),
        }
    }
}
impl fmt::Debug for MultiviewPerViewAttributesInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiviewPerViewAttributesInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("per_view_attributes", &self.per_view_attributes)
            .field(
                "per_view_attributes_position_x_only",
                &self.per_view_attributes_position_x_only,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_lod: Bool32,
}
unsafe impl Send for PhysicalDeviceImageViewMinLodFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImageViewMinLodFeaturesEXT {}
impl default::Default for PhysicalDeviceImageViewMinLodFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            p_next: ptr::null_mut(),
            min_lod: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageViewMinLodFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageViewMinLodFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_lod", &self.min_lod)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewMinLodCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_lod: f32,
}
unsafe impl Send for ImageViewMinLodCreateInfoEXT {}
unsafe impl Sync for ImageViewMinLodCreateInfoEXT {}
impl default::Default for ImageViewMinLodCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            p_next: ptr::null(),
            min_lod: f32::default(),
        }
    }
}
impl fmt::Debug for ImageViewMinLodCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewMinLodCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_lod", &self.min_lod)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub rasterization_order_color_attachment_access: Bool32,
    pub rasterization_order_depth_attachment_access: Bool32,
    pub rasterization_order_stencil_attachment_access: Bool32,
}
unsafe impl Send for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {}
unsafe impl Sync for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {}
impl default::Default for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM,
            p_next: ptr::null(),
            rasterization_order_color_attachment_access: Bool32::default(),
            rasterization_order_depth_attachment_access: Bool32::default(),
            rasterization_order_stencil_attachment_access: Bool32::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "rasterization_order_color_attachment_access",
                &self.rasterization_order_color_attachment_access,
            )
            .field(
                "rasterization_order_depth_attachment_access",
                &self.rasterization_order_depth_attachment_access,
            )
            .field(
                "rasterization_order_stencil_attachment_access",
                &self.rasterization_order_stencil_attachment_access,
            )
            .finish()
    }
}
pub type FnCreateInstance = unsafe extern "system" fn(
    p_create_info: *const InstanceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_instance: *mut Instance,
) -> Result;
pub type FnDestroyInstance =
    unsafe extern "system" fn(instance: Option<Instance>, p_allocator: *const AllocationCallbacks);
pub type FnEnumeratePhysicalDevices = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_physical_device_count: *mut u32,
    p_physical_devices: *mut PhysicalDevice,
) -> Result;
pub type FnGetDeviceProcAddr =
    unsafe extern "system" fn(device: Option<Device>, p_name: *const c_char) -> Option<FnVoidFunction>;
pub type FnGetInstanceProcAddr =
    unsafe extern "system" fn(instance: Option<Instance>, p_name: *const c_char) -> Option<FnVoidFunction>;
pub type FnGetPhysicalDeviceProperties =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_properties: *mut PhysicalDeviceProperties);
pub type FnGetPhysicalDeviceQueueFamilyProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_queue_family_property_count: *mut u32,
    p_queue_family_properties: *mut QueueFamilyProperties,
);
pub type FnGetPhysicalDeviceMemoryProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_memory_properties: *mut PhysicalDeviceMemoryProperties,
);
pub type FnGetPhysicalDeviceFeatures =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_features: *mut PhysicalDeviceFeatures);
pub type FnGetPhysicalDeviceFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    p_format_properties: *mut FormatProperties,
);
pub type FnGetPhysicalDeviceImageFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    p_image_format_properties: *mut ImageFormatProperties,
) -> Result;
pub type FnCreateDevice = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_create_info: *const DeviceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_device: *mut Device,
) -> Result;
pub type FnDestroyDevice = unsafe extern "system" fn(device: Option<Device>, p_allocator: *const AllocationCallbacks);
pub type FnEnumerateInstanceVersion = unsafe extern "system" fn(p_api_version: *mut Version) -> Result;
pub type FnEnumerateInstanceLayerProperties =
    unsafe extern "system" fn(p_property_count: *mut u32, p_properties: *mut LayerProperties) -> Result;
pub type FnEnumerateInstanceExtensionProperties = unsafe extern "system" fn(
    p_layer_name: *const c_char,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> Result;
pub type FnEnumerateDeviceLayerProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut LayerProperties,
) -> Result;
pub type FnEnumerateDeviceExtensionProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_layer_name: *const c_char,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> Result;
pub type FnGetDeviceQueue =
    unsafe extern "system" fn(device: Option<Device>, queue_family_index: u32, queue_index: u32, p_queue: *mut Queue);
pub type FnQueueSubmit = unsafe extern "system" fn(
    queue: Option<Queue>,
    submit_count: u32,
    p_submits: *const SubmitInfo,
    fence: Option<Fence>,
) -> Result;
pub type FnQueueWaitIdle = unsafe extern "system" fn(queue: Option<Queue>) -> Result;
pub type FnDeviceWaitIdle = unsafe extern "system" fn(device: Option<Device>) -> Result;
pub type FnAllocateMemory = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const MemoryAllocateInfo,
    p_allocator: *const AllocationCallbacks,
    p_memory: *mut DeviceMemory,
) -> Result;
pub type FnFreeMemory = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnMapMemory = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
    pp_data: *mut *mut c_void,
) -> Result;
pub type FnUnmapMemory = unsafe extern "system" fn(device: Option<Device>, memory: Option<DeviceMemory>);
pub type FnFlushMappedMemoryRanges = unsafe extern "system" fn(
    device: Option<Device>,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> Result;
pub type FnInvalidateMappedMemoryRanges = unsafe extern "system" fn(
    device: Option<Device>,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> Result;
pub type FnGetDeviceMemoryCommitment = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    p_committed_memory_in_bytes: *mut DeviceSize,
);
pub type FnGetBufferMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: Option<Buffer>,
    p_memory_requirements: *mut MemoryRequirements,
);
pub type FnBindBufferMemory = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: Option<Buffer>,
    memory: Option<DeviceMemory>,
    memory_offset: DeviceSize,
) -> Result;
pub type FnGetImageMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_memory_requirements: *mut MemoryRequirements,
);
pub type FnBindImageMemory = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    memory: Option<DeviceMemory>,
    memory_offset: DeviceSize,
) -> Result;
pub type FnGetImageSparseMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements,
);
pub type FnGetPhysicalDeviceSparseImageFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    p_property_count: *mut u32,
    p_properties: *mut SparseImageFormatProperties,
);
pub type FnQueueBindSparse = unsafe extern "system" fn(
    queue: Option<Queue>,
    bind_info_count: u32,
    p_bind_info: *const BindSparseInfo,
    fence: Option<Fence>,
) -> Result;
pub type FnCreateFence = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const FenceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnDestroyFence =
    unsafe extern "system" fn(device: Option<Device>, fence: Option<Fence>, p_allocator: *const AllocationCallbacks);
pub type FnResetFences =
    unsafe extern "system" fn(device: Option<Device>, fence_count: u32, p_fences: *const Fence) -> Result;
pub type FnGetFenceStatus = unsafe extern "system" fn(device: Option<Device>, fence: Option<Fence>) -> Result;
pub type FnWaitForFences = unsafe extern "system" fn(
    device: Option<Device>,
    fence_count: u32,
    p_fences: *const Fence,
    wait_all: Bool32,
    timeout: u64,
) -> Result;
pub type FnCreateSemaphore = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SemaphoreCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_semaphore: *mut Semaphore,
) -> Result;
pub type FnDestroySemaphore = unsafe extern "system" fn(
    device: Option<Device>,
    semaphore: Option<Semaphore>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateEvent = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const EventCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_event: *mut Event,
) -> Result;
pub type FnDestroyEvent =
    unsafe extern "system" fn(device: Option<Device>, event: Option<Event>, p_allocator: *const AllocationCallbacks);
pub type FnGetEventStatus = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnSetEvent = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnResetEvent = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnCreateQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const QueryPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_query_pool: *mut QueryPool,
) -> Result;
pub type FnDestroyQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetQueryPoolResults = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
    data_size: usize,
    p_data: *mut c_void,
    stride: DeviceSize,
    flags: QueryResultFlags,
) -> Result;
pub type FnResetQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
);
pub type FnCreateBuffer = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_buffer: *mut Buffer,
) -> Result;
pub type FnDestroyBuffer =
    unsafe extern "system" fn(device: Option<Device>, buffer: Option<Buffer>, p_allocator: *const AllocationCallbacks);
pub type FnCreateBufferView = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut BufferView,
) -> Result;
pub type FnDestroyBufferView = unsafe extern "system" fn(
    device: Option<Device>,
    buffer_view: Option<BufferView>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateImage = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ImageCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_image: *mut Image,
) -> Result;
pub type FnDestroyImage =
    unsafe extern "system" fn(device: Option<Device>, image: Option<Image>, p_allocator: *const AllocationCallbacks);
pub type FnGetImageSubresourceLayout = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_subresource: *const ImageSubresource,
    p_layout: *mut SubresourceLayout,
);
pub type FnCreateImageView = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ImageViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut ImageView,
) -> Result;
pub type FnDestroyImageView = unsafe extern "system" fn(
    device: Option<Device>,
    image_view: Option<ImageView>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateShaderModule = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ShaderModuleCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_shader_module: *mut ShaderModule,
) -> Result;
pub type FnDestroyShaderModule = unsafe extern "system" fn(
    device: Option<Device>,
    shader_module: Option<ShaderModule>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreatePipelineCache = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PipelineCacheCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_cache: *mut PipelineCache,
) -> Result;
pub type FnDestroyPipelineCache = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPipelineCacheData = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    p_data_size: *mut usize,
    p_data: *mut c_void,
) -> Result;
pub type FnMergePipelineCaches = unsafe extern "system" fn(
    device: Option<Device>,
    dst_cache: Option<PipelineCache>,
    src_cache_count: u32,
    p_src_caches: *const PipelineCache,
) -> Result;
pub type FnCreateGraphicsPipelines = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const GraphicsPipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnCreateComputePipelines = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const ComputePipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = unsafe extern "system" fn(
    device: Option<Device>,
    renderpass: Option<RenderPass>,
    p_max_workgroup_size: *mut Extent2D,
) -> Result;
pub type FnDestroyPipeline = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreatePipelineLayout = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PipelineLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_layout: *mut PipelineLayout,
) -> Result;
pub type FnDestroyPipelineLayout = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_layout: Option<PipelineLayout>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateSampler = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SamplerCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_sampler: *mut Sampler,
) -> Result;
pub type FnDestroySampler = unsafe extern "system" fn(
    device: Option<Device>,
    sampler: Option<Sampler>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateDescriptorSetLayout = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_set_layout: *mut DescriptorSetLayout,
) -> Result;
pub type FnDestroyDescriptorSetLayout = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_set_layout: Option<DescriptorSetLayout>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_descriptor_pool: *mut DescriptorPool,
) -> Result;
pub type FnDestroyDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnResetDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    flags: DescriptorPoolResetFlags,
) -> Result;
pub type FnAllocateDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const DescriptorSetAllocateInfo,
    p_descriptor_sets: *mut DescriptorSet,
) -> Result;
pub type FnFreeDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
) -> Result;
pub type FnUpdateDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_write_count: u32,
    p_descriptor_writes: *const WriteDescriptorSet,
    descriptor_copy_count: u32,
    p_descriptor_copies: *const CopyDescriptorSet,
);
pub type FnCreateFramebuffer = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const FramebufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_framebuffer: *mut Framebuffer,
) -> Result;
pub type FnDestroyFramebuffer = unsafe extern "system" fn(
    device: Option<Device>,
    framebuffer: Option<Framebuffer>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateRenderPass = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const RenderPassCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_render_pass: *mut RenderPass,
) -> Result;
pub type FnDestroyRenderPass = unsafe extern "system" fn(
    device: Option<Device>,
    render_pass: Option<RenderPass>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetRenderAreaGranularity =
    unsafe extern "system" fn(device: Option<Device>, render_pass: Option<RenderPass>, p_granularity: *mut Extent2D);
pub type FnCreateCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CommandPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_command_pool: *mut CommandPool,
) -> Result;
pub type FnDestroyCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnResetCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    flags: CommandPoolResetFlags,
) -> Result;
pub type FnAllocateCommandBuffers = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const CommandBufferAllocateInfo,
    p_command_buffers: *mut CommandBuffer,
) -> Result;
pub type FnFreeCommandBuffers = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
pub type FnBeginCommandBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_begin_info: *const CommandBufferBeginInfo,
) -> Result;
pub type FnEndCommandBuffer = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>) -> Result;
pub type FnResetCommandBuffer =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, flags: CommandBufferResetFlags) -> Result;
pub type FnCmdBindPipeline = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Option<Pipeline>,
);
pub type FnCmdSetViewport = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_viewports: *const Viewport,
);
pub type FnCmdSetScissor = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_scissor: u32,
    scissor_count: u32,
    p_scissors: *const Rect2D,
);
pub type FnCmdSetLineWidth = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, line_width: f32);
pub type FnCmdSetDepthBias = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
);
pub type FnCmdSetBlendConstants =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, blend_constants: *const f32);
pub type FnCmdSetDepthBounds =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, min_depth_bounds: f32, max_depth_bounds: f32);
pub type FnCmdSetStencilCompareMask =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, compare_mask: u32);
pub type FnCmdSetStencilWriteMask =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, write_mask: u32);
pub type FnCmdSetStencilReference =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, reference: u32);
pub type FnCmdBindDescriptorSets = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    layout: Option<PipelineLayout>,
    first_set: u32,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
    dynamic_offset_count: u32,
    p_dynamic_offsets: *const u32,
);
pub type FnCmdBindIndexBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    index_type: IndexType,
);
pub type FnCmdBindVertexBuffers = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
);
pub type FnCmdDraw = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
);
pub type FnCmdDrawIndexed = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
);
pub type FnCmdDrawMultiEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    draw_count: u32,
    p_vertex_info: *const MultiDrawInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
);
pub type FnCmdDrawMultiIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    draw_count: u32,
    p_index_info: *const MultiDrawIndexedInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
    p_vertex_offset: *const i32,
);
pub type FnCmdDrawIndirect = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawIndexedIndirect = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDispatch = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
);
pub type FnCmdDispatchIndirect =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, buffer: Option<Buffer>, offset: DeviceSize);
pub type FnCmdSubpassShadingHUAWEI = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdCopyBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_buffer: Option<Buffer>,
    dst_buffer: Option<Buffer>,
    region_count: u32,
    p_regions: *const BufferCopy,
);
pub type FnCmdCopyImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageCopy,
);
pub type FnCmdBlitImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageBlit,
    filter: Filter,
);
pub type FnCmdCopyBufferToImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_buffer: Option<Buffer>,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
pub type FnCmdCopyImageToBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_buffer: Option<Buffer>,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
pub type FnCmdUpdateBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    data_size: DeviceSize,
    p_data: *const c_void,
);
pub type FnCmdFillBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    size: DeviceSize,
    data: u32,
);
pub type FnCmdClearColorImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image: Option<Image>,
    image_layout: ImageLayout,
    p_color: *const ClearColorValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
pub type FnCmdClearDepthStencilImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image: Option<Image>,
    image_layout: ImageLayout,
    p_depth_stencil: *const ClearDepthStencilValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
pub type FnCmdClearAttachments = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    attachment_count: u32,
    p_attachments: *const ClearAttachment,
    rect_count: u32,
    p_rects: *const ClearRect,
);
pub type FnCmdResolveImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageResolve,
);
pub type FnCmdSetEvent = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags,
);
pub type FnCmdResetEvent = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags,
);
pub type FnCmdWaitEvents = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event_count: u32,
    p_events: *const Event,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
pub type FnCmdPipelineBarrier = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    dependency_flags: DependencyFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
pub type FnCmdBeginQuery = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    flags: QueryControlFlags,
);
pub type FnCmdEndQuery =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, query_pool: Option<QueryPool>, query: u32);
pub type FnCmdBeginConditionalRenderingEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
);
pub type FnCmdEndConditionalRenderingEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdResetQueryPool = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
);
pub type FnCmdWriteTimestamp = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_stage: PipelineStageFlags,
    query_pool: Option<QueryPool>,
    query: u32,
);
pub type FnCmdCopyQueryPoolResults = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
);
pub type FnCmdPushConstants = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    layout: Option<PipelineLayout>,
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
    p_values: *const c_void,
);
pub type FnCmdBeginRenderPass = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_render_pass_begin: *const RenderPassBeginInfo,
    contents: SubpassContents,
);
pub type FnCmdNextSubpass = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, contents: SubpassContents);
pub type FnCmdEndRenderPass = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdExecuteCommands = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
pub type FnCreateAndroidSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const AndroidSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPropertiesKHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPlanePropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPlanePropertiesKHR,
) -> Result;
pub type FnGetDisplayPlaneSupportedDisplaysKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    plane_index: u32,
    p_display_count: *mut u32,
    p_displays: *mut DisplayKHR,
) -> Result;
pub type FnGetDisplayModePropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayModePropertiesKHR,
) -> Result;
pub type FnCreateDisplayModeKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_create_info: *const DisplayModeCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_mode: *mut DisplayModeKHR,
) -> Result;
pub type FnGetDisplayPlaneCapabilitiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    mode: Option<DisplayModeKHR>,
    plane_index: u32,
    p_capabilities: *mut DisplayPlaneCapabilitiesKHR,
) -> Result;
pub type FnCreateDisplayPlaneSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DisplaySurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateSharedSwapchainsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain_count: u32,
    p_create_infos: *const SwapchainCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_swapchains: *mut SwapchainKHR,
) -> Result;
pub type FnDestroySurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    surface: Option<SurfaceKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPhysicalDeviceSurfaceSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    surface: Option<SurfaceKHR>,
    p_supported: *mut Bool32,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceCapabilitiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_capabilities: *mut SurfaceCapabilitiesKHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceFormatsKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_format_count: *mut u32,
    p_surface_formats: *mut SurfaceFormatKHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfacePresentModesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_present_mode_count: *mut u32,
    p_present_modes: *mut PresentModeKHR,
) -> Result;
pub type FnCreateSwapchainKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SwapchainCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_swapchain: *mut SwapchainKHR,
) -> Result;
pub type FnDestroySwapchainKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetSwapchainImagesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_swapchain_image_count: *mut u32,
    p_swapchain_images: *mut Image,
) -> Result;
pub type FnAcquireNextImageKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    timeout: u64,
    semaphore: Option<Semaphore>,
    fence: Option<Fence>,
    p_image_index: *mut u32,
) -> Result;
pub type FnQueuePresentKHR =
    unsafe extern "system" fn(queue: Option<Queue>, p_present_info: *const PresentInfoKHR) -> Result;
pub type FnCreateViSurfaceNN = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const ViSurfaceCreateInfoNN,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateWaylandSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const WaylandSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceWaylandPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    display: *mut wl_display,
) -> Bool32;
pub type FnCreateWin32SurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const Win32SurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceWin32PresentationSupportKHR =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, queue_family_index: u32) -> Bool32;
pub type FnCreateXlibSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const XlibSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceXlibPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    dpy: *mut Display,
    visual_id: VisualID,
) -> Bool32;
pub type FnCreateXcbSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const XcbSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceXcbPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    connection: *mut xcb_connection_t,
    visual_id: xcb_visualid_t,
) -> Bool32;
pub type FnCreateDirectFBSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DirectFBSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceDirectFBPresentationSupportEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    dfb: *mut IDirectFB,
) -> Bool32;
pub type FnCreateImagePipeSurfaceFUCHSIA = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateDebugReportCallbackEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DebugReportCallbackCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_callback: *mut DebugReportCallbackEXT,
) -> Result;
pub type FnDestroyDebugReportCallbackEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    callback: Option<DebugReportCallbackEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDebugReportMessageEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: *const c_char,
    p_message: *const c_char,
);
pub type FnDebugMarkerSetObjectNameEXT =
    unsafe extern "system" fn(device: Option<Device>, p_name_info: *const DebugMarkerObjectNameInfoEXT) -> Result;
pub type FnDebugMarkerSetObjectTagEXT =
    unsafe extern "system" fn(device: Option<Device>, p_tag_info: *const DebugMarkerObjectTagInfoEXT) -> Result;
pub type FnCmdDebugMarkerBeginEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_marker_info: *const DebugMarkerMarkerInfoEXT);
pub type FnCmdDebugMarkerEndEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdDebugMarkerInsertEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_marker_info: *const DebugMarkerMarkerInfoEXT);
pub type FnGetPhysicalDeviceExternalImageFormatPropertiesNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_external_image_format_properties: *mut ExternalImageFormatPropertiesNV,
) -> Result;
pub type FnGetMemoryWin32HandleNV = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnCmdExecuteGeneratedCommandsNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
);
pub type FnCmdPreprocessGeneratedCommandsNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
);
pub type FnCmdBindPipelineShaderGroupNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Option<Pipeline>,
    group_index: u32,
);
pub type FnGetGeneratedCommandsMemoryRequirementsNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoNV,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnCreateIndirectCommandsLayoutNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const IndirectCommandsLayoutCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_indirect_commands_layout: *mut IndirectCommandsLayoutNV,
) -> Result;
pub type FnDestroyIndirectCommandsLayoutNV = unsafe extern "system" fn(
    device: Option<Device>,
    indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPhysicalDeviceFeatures2 =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_features: *mut PhysicalDeviceFeatures2);
pub type FnGetPhysicalDeviceProperties2 =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_properties: *mut PhysicalDeviceProperties2);
pub type FnGetPhysicalDeviceFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    p_format_properties: *mut FormatProperties2,
);
pub type FnGetPhysicalDeviceImageFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
    p_image_format_properties: *mut ImageFormatProperties2,
) -> Result;
pub type FnGetPhysicalDeviceQueueFamilyProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_queue_family_property_count: *mut u32,
    p_queue_family_properties: *mut QueueFamilyProperties2,
);
pub type FnGetPhysicalDeviceMemoryProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_memory_properties: *mut PhysicalDeviceMemoryProperties2,
);
pub type FnGetPhysicalDeviceSparseImageFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    p_property_count: *mut u32,
    p_properties: *mut SparseImageFormatProperties2,
);
pub type FnCmdPushDescriptorSetKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    layout: Option<PipelineLayout>,
    set: u32,
    descriptor_write_count: u32,
    p_descriptor_writes: *const WriteDescriptorSet,
);
pub type FnTrimCommandPool =
    unsafe extern "system" fn(device: Option<Device>, command_pool: Option<CommandPool>, flags: CommandPoolTrimFlags);
pub type FnGetPhysicalDeviceExternalBufferProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
    p_external_buffer_properties: *mut ExternalBufferProperties,
);
pub type FnGetMemoryWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const MemoryGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnGetMemoryWin32HandlePropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    p_memory_win32_handle_properties: *mut MemoryWin32HandlePropertiesKHR,
) -> Result;
pub type FnGetMemoryFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const MemoryGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnGetMemoryFdPropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    fd: c_int,
    p_memory_fd_properties: *mut MemoryFdPropertiesKHR,
) -> Result;
pub type FnGetMemoryZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *mut zx_handle_t,
) -> Result;
pub type FnGetMemoryZirconHandlePropertiesFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    zircon_handle: zx_handle_t,
    p_memory_zircon_handle_properties: *mut MemoryZirconHandlePropertiesFUCHSIA,
) -> Result;
pub type FnGetMemoryRemoteAddressNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
    p_address: *mut RemoteAddressNV,
) -> Result;
pub type FnGetPhysicalDeviceExternalSemaphoreProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
    p_external_semaphore_properties: *mut ExternalSemaphoreProperties,
);
pub type FnGetSemaphoreWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnImportSemaphoreWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_win32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
) -> Result;
pub type FnGetSemaphoreFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const SemaphoreGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnImportSemaphoreFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
) -> Result;
pub type FnGetSemaphoreZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *mut zx_handle_t,
) -> Result;
pub type FnImportSemaphoreZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
) -> Result;
pub type FnGetPhysicalDeviceExternalFenceProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
    p_external_fence_properties: *mut ExternalFenceProperties,
);
pub type FnGetFenceWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const FenceGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnImportFenceWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_fence_win32_handle_info: *const ImportFenceWin32HandleInfoKHR,
) -> Result;
pub type FnGetFenceFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const FenceGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnImportFenceFdKHR =
    unsafe extern "system" fn(device: Option<Device>, p_import_fence_fd_info: *const ImportFenceFdInfoKHR) -> Result;
pub type FnReleaseDisplayEXT =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, display: Option<DisplayKHR>) -> Result;
pub type FnAcquireXlibDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    dpy: *mut Display,
    display: Option<DisplayKHR>,
) -> Result;
pub type FnGetRandROutputDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    dpy: *mut Display,
    rr_output: RROutput,
    p_display: *mut DisplayKHR,
) -> Result;
pub type FnAcquireWinrtDisplayNV =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, display: Option<DisplayKHR>) -> Result;
pub type FnGetWinrtDisplayNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    device_relative_id: u32,
    p_display: *mut DisplayKHR,
) -> Result;
pub type FnDisplayPowerControlEXT = unsafe extern "system" fn(
    device: Option<Device>,
    display: Option<DisplayKHR>,
    p_display_power_info: *const DisplayPowerInfoEXT,
) -> Result;
pub type FnRegisterDeviceEventEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_device_event_info: *const DeviceEventInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnRegisterDisplayEventEXT = unsafe extern "system" fn(
    device: Option<Device>,
    display: Option<DisplayKHR>,
    p_display_event_info: *const DisplayEventInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnGetSwapchainCounterEXT = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    counter: SurfaceCounterFlagsEXT,
    p_counter_value: *mut u64,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceCapabilities2EXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_capabilities: *mut SurfaceCapabilities2EXT,
) -> Result;
pub type FnEnumeratePhysicalDeviceGroups = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_physical_device_group_count: *mut u32,
    p_physical_device_group_properties: *mut PhysicalDeviceGroupProperties,
) -> Result;
pub type FnGetDeviceGroupPeerMemoryFeatures = unsafe extern "system" fn(
    device: Option<Device>,
    heap_index: u32,
    local_device_index: u32,
    remote_device_index: u32,
    p_peer_memory_features: *mut PeerMemoryFeatureFlags,
);
pub type FnBindBufferMemory2 = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindBufferMemoryInfo,
) -> Result;
pub type FnBindImageMemory2 = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindImageMemoryInfo,
) -> Result;
pub type FnCmdSetDeviceMask = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, device_mask: u32);
pub type FnGetDeviceGroupPresentCapabilitiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_device_group_present_capabilities: *mut DeviceGroupPresentCapabilitiesKHR,
) -> Result;
pub type FnGetDeviceGroupSurfacePresentModesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    surface: Option<SurfaceKHR>,
    p_modes: *mut DeviceGroupPresentModeFlagsKHR,
) -> Result;
pub type FnAcquireNextImage2KHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_acquire_info: *const AcquireNextImageInfoKHR,
    p_image_index: *mut u32,
) -> Result;
pub type FnCmdDispatchBase = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    base_group_x: u32,
    base_group_y: u32,
    base_group_z: u32,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
);
pub type FnGetPhysicalDevicePresentRectanglesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_rect_count: *mut u32,
    p_rects: *mut Rect2D,
) -> Result;
pub type FnCreateDescriptorUpdateTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorUpdateTemplateCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_descriptor_update_template: *mut DescriptorUpdateTemplate,
) -> Result;
pub type FnDestroyDescriptorUpdateTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnUpdateDescriptorSetWithTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_set: Option<DescriptorSet>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    p_data: *const c_void,
);
pub type FnCmdPushDescriptorSetWithTemplateKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    layout: Option<PipelineLayout>,
    set: u32,
    p_data: *const c_void,
);
pub type FnSetHdrMetadataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain_count: u32,
    p_swapchains: *const SwapchainKHR,
    p_metadata: *const HdrMetadataEXT,
);
pub type FnGetSwapchainStatusKHR =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnGetRefreshCycleDurationGOOGLE = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_display_timing_properties: *mut RefreshCycleDurationGOOGLE,
) -> Result;
pub type FnGetPastPresentationTimingGOOGLE = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_presentation_timing_count: *mut u32,
    p_presentation_timings: *mut PastPresentationTimingGOOGLE,
) -> Result;
pub type FnCreateIOSSurfaceMVK = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const IOSSurfaceCreateInfoMVK,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateMacOSSurfaceMVK = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const MacOSSurfaceCreateInfoMVK,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateMetalSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const MetalSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCmdSetViewportWScalingNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_w_scalings: *const ViewportWScalingNV,
);
pub type FnCmdSetDiscardRectangleEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_discard_rectangle: u32,
    discard_rectangle_count: u32,
    p_discard_rectangles: *const Rect2D,
);
pub type FnCmdSetSampleLocationsEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_sample_locations_info: *const SampleLocationsInfoEXT,
);
pub type FnGetPhysicalDeviceMultisamplePropertiesEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    samples: SampleCountFlags,
    p_multisample_properties: *mut MultisamplePropertiesEXT,
);
pub type FnGetPhysicalDeviceSurfaceCapabilities2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_capabilities: *mut SurfaceCapabilities2KHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceFormats2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_format_count: *mut u32,
    p_surface_formats: *mut SurfaceFormat2KHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayProperties2KHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPlaneProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPlaneProperties2KHR,
) -> Result;
pub type FnGetDisplayModeProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayModeProperties2KHR,
) -> Result;
pub type FnGetDisplayPlaneCapabilities2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_display_plane_info: *const DisplayPlaneInfo2KHR,
    p_capabilities: *mut DisplayPlaneCapabilities2KHR,
) -> Result;
pub type FnGetBufferMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const BufferMemoryRequirementsInfo2,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetImageMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const ImageMemoryRequirementsInfo2,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetImageSparseMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
);
pub type FnGetDeviceBufferMemoryRequirementsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceBufferMemoryRequirementsKHR,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetDeviceImageMemoryRequirementsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceImageMemoryRequirementsKHR,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetDeviceImageSparseMemoryRequirementsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceImageMemoryRequirementsKHR,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
);
pub type FnCreateSamplerYcbcrConversion = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SamplerYcbcrConversionCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_ycbcr_conversion: *mut SamplerYcbcrConversion,
) -> Result;
pub type FnDestroySamplerYcbcrConversion = unsafe extern "system" fn(
    device: Option<Device>,
    ycbcr_conversion: Option<SamplerYcbcrConversion>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetDeviceQueue2 =
    unsafe extern "system" fn(device: Option<Device>, p_queue_info: *const DeviceQueueInfo2, p_queue: *mut Queue);
pub type FnCreateValidationCacheEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ValidationCacheCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_validation_cache: *mut ValidationCacheEXT,
) -> Result;
pub type FnDestroyValidationCacheEXT = unsafe extern "system" fn(
    device: Option<Device>,
    validation_cache: Option<ValidationCacheEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetValidationCacheDataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    validation_cache: Option<ValidationCacheEXT>,
    p_data_size: *mut usize,
    p_data: *mut c_void,
) -> Result;
pub type FnMergeValidationCachesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    dst_cache: Option<ValidationCacheEXT>,
    src_cache_count: u32,
    p_src_caches: *const ValidationCacheEXT,
) -> Result;
pub type FnGetDescriptorSetLayoutSupport = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_support: *mut DescriptorSetLayoutSupport,
);
pub type FnGetShaderInfoAMD = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    shader_stage: ShaderStageFlags,
    info_type: ShaderInfoTypeAMD,
    p_info_size: *mut usize,
    p_info: *mut c_void,
) -> Result;
pub type FnSetLocalDimmingAMD =
    unsafe extern "system" fn(device: Option<Device>, swap_chain: Option<SwapchainKHR>, local_dimming_enable: Bool32);
pub type FnGetPhysicalDeviceCalibrateableTimeDomainsEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_time_domain_count: *mut u32,
    p_time_domains: *mut TimeDomainEXT,
) -> Result;
pub type FnGetCalibratedTimestampsEXT = unsafe extern "system" fn(
    device: Option<Device>,
    timestamp_count: u32,
    p_timestamp_infos: *const CalibratedTimestampInfoEXT,
    p_timestamps: *mut u64,
    p_max_deviation: *mut u64,
) -> Result;
pub type FnSetDebugUtilsObjectNameEXT =
    unsafe extern "system" fn(device: Option<Device>, p_name_info: *const DebugUtilsObjectNameInfoEXT) -> Result;
pub type FnSetDebugUtilsObjectTagEXT =
    unsafe extern "system" fn(device: Option<Device>, p_tag_info: *const DebugUtilsObjectTagInfoEXT) -> Result;
pub type FnQueueBeginDebugUtilsLabelEXT =
    unsafe extern "system" fn(queue: Option<Queue>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnQueueEndDebugUtilsLabelEXT = unsafe extern "system" fn(queue: Option<Queue>);
pub type FnQueueInsertDebugUtilsLabelEXT =
    unsafe extern "system" fn(queue: Option<Queue>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCmdBeginDebugUtilsLabelEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCmdEndDebugUtilsLabelEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdInsertDebugUtilsLabelEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCreateDebugUtilsMessengerEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DebugUtilsMessengerCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_messenger: *mut DebugUtilsMessengerEXT,
) -> Result;
pub type FnDestroyDebugUtilsMessengerEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    messenger: Option<DebugUtilsMessengerEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnSubmitDebugUtilsMessageEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
);
pub type FnGetMemoryHostPointerPropertiesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_host_pointer: *const c_void,
    p_memory_host_pointer_properties: *mut MemoryHostPointerPropertiesEXT,
) -> Result;
pub type FnCmdWriteBufferMarkerAMD = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_stage: PipelineStageFlags,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    marker: u32,
);
pub type FnCreateRenderPass2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const RenderPassCreateInfo2,
    p_allocator: *const AllocationCallbacks,
    p_render_pass: *mut RenderPass,
) -> Result;
pub type FnCmdBeginRenderPass2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_render_pass_begin: *const RenderPassBeginInfo,
    p_subpass_begin_info: *const SubpassBeginInfo,
);
pub type FnCmdNextSubpass2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_subpass_begin_info: *const SubpassBeginInfo,
    p_subpass_end_info: *const SubpassEndInfo,
);
pub type FnCmdEndRenderPass2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_subpass_end_info: *const SubpassEndInfo);
pub type FnGetSemaphoreCounterValue =
    unsafe extern "system" fn(device: Option<Device>, semaphore: Option<Semaphore>, p_value: *mut u64) -> Result;
pub type FnWaitSemaphores =
    unsafe extern "system" fn(device: Option<Device>, p_wait_info: *const SemaphoreWaitInfo, timeout: u64) -> Result;
pub type FnSignalSemaphore =
    unsafe extern "system" fn(device: Option<Device>, p_signal_info: *const SemaphoreSignalInfo) -> Result;
pub type FnGetAndroidHardwareBufferPropertiesANDROID = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: *const AHardwareBuffer,
    p_properties: *mut AndroidHardwareBufferPropertiesANDROID,
) -> Result;
pub type FnGetMemoryAndroidHardwareBufferANDROID = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
    p_buffer: *mut *mut AHardwareBuffer,
) -> Result;
pub type FnCmdDrawIndirectCount = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawIndexedIndirectCount = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCmdSetCheckpointNV =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_checkpoint_marker: *const c_void);
pub type FnGetQueueCheckpointDataNV = unsafe extern "system" fn(
    queue: Option<Queue>,
    p_checkpoint_data_count: *mut u32,
    p_checkpoint_data: *mut CheckpointDataNV,
);
pub type FnCmdBindTransformFeedbackBuffersEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
    p_sizes: *const DeviceSize,
);
pub type FnCmdBeginTransformFeedbackEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: *const Buffer,
    p_counter_buffer_offsets: *const DeviceSize,
);
pub type FnCmdEndTransformFeedbackEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: *const Buffer,
    p_counter_buffer_offsets: *const DeviceSize,
);
pub type FnCmdBeginQueryIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    flags: QueryControlFlags,
    index: u32,
);
pub type FnCmdEndQueryIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    index: u32,
);
pub type FnCmdDrawIndirectByteCountEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    instance_count: u32,
    first_instance: u32,
    counter_buffer: Option<Buffer>,
    counter_buffer_offset: DeviceSize,
    counter_offset: u32,
    vertex_stride: u32,
);
pub type FnCmdSetExclusiveScissorNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissors: *const Rect2D,
);
pub type FnCmdBindShadingRateImageNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image_view: Option<ImageView>,
    image_layout: ImageLayout,
);
pub type FnCmdSetViewportShadingRatePaletteNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_shading_rate_palettes: *const ShadingRatePaletteNV,
);
pub type FnCmdSetCoarseSampleOrderNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    sample_order_type: CoarseSampleOrderTypeNV,
    custom_sample_order_count: u32,
    p_custom_sample_orders: *const CoarseSampleOrderCustomNV,
);
pub type FnCmdDrawMeshTasksNV =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, task_count: u32, first_task: u32);
pub type FnCmdDrawMeshTasksIndirectNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawMeshTasksIndirectCountNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCompileDeferredNV =
    unsafe extern "system" fn(device: Option<Device>, pipeline: Option<Pipeline>, shader: u32) -> Result;
pub type FnCreateAccelerationStructureNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const AccelerationStructureCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_acceleration_structure: *mut AccelerationStructureNV,
) -> Result;
pub type FnCmdBindInvocationMaskHUAWEI = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image_view: Option<ImageView>,
    image_layout: ImageLayout,
);
pub type FnDestroyAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDestroyAccelerationStructureNV = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureNV>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetAccelerationStructureMemoryRequirementsNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const AccelerationStructureMemoryRequirementsInfoNV,
    p_memory_requirements: *mut MemoryRequirements2KHR,
);
pub type FnBindAccelerationStructureMemoryNV = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindAccelerationStructureMemoryInfoNV,
) -> Result;
pub type FnCmdCopyAccelerationStructureNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst: Option<AccelerationStructureNV>,
    src: Option<AccelerationStructureNV>,
    mode: CopyAccelerationStructureModeKHR,
);
pub type FnCmdCopyAccelerationStructureKHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_info: *const CopyAccelerationStructureInfoKHR);
pub type FnCopyAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyAccelerationStructureInfoKHR,
) -> Result;
pub type FnCmdCopyAccelerationStructureToMemoryKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
);
pub type FnCopyAccelerationStructureToMemoryKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) -> Result;
pub type FnCmdCopyMemoryToAccelerationStructureKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
);
pub type FnCopyMemoryToAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) -> Result;
pub type FnCmdWriteAccelerationStructuresPropertiesKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureKHR,
    query_type: QueryType,
    query_pool: Option<QueryPool>,
    first_query: u32,
);
pub type FnCmdWriteAccelerationStructuresPropertiesNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureNV,
    query_type: QueryType,
    query_pool: Option<QueryPool>,
    first_query: u32,
);
pub type FnCmdBuildAccelerationStructureNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const AccelerationStructureInfoNV,
    instance_data: Option<Buffer>,
    instance_offset: DeviceSize,
    update: Bool32,
    dst: Option<AccelerationStructureNV>,
    src: Option<AccelerationStructureNV>,
    scratch: Option<Buffer>,
    scratch_offset: DeviceSize,
);
pub type FnWriteAccelerationStructuresPropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureKHR,
    query_type: QueryType,
    data_size: usize,
    p_data: *mut c_void,
    stride: usize,
) -> Result;
pub type FnCmdTraceRaysKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
);
pub type FnCmdTraceRaysNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    raygen_shader_binding_table_buffer: Option<Buffer>,
    raygen_shader_binding_offset: DeviceSize,
    miss_shader_binding_table_buffer: Option<Buffer>,
    miss_shader_binding_offset: DeviceSize,
    miss_shader_binding_stride: DeviceSize,
    hit_shader_binding_table_buffer: Option<Buffer>,
    hit_shader_binding_offset: DeviceSize,
    hit_shader_binding_stride: DeviceSize,
    callable_shader_binding_table_buffer: Option<Buffer>,
    callable_shader_binding_offset: DeviceSize,
    callable_shader_binding_stride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
);
pub type FnGetRayTracingShaderGroupHandlesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnGetRayTracingCaptureReplayShaderGroupHandlesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnGetAccelerationStructureHandleNV = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureNV>,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnCreateRayTracingPipelinesNV = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const RayTracingPipelineCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnCreateRayTracingPipelinesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const RayTracingPipelineCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnGetPhysicalDeviceCooperativeMatrixPropertiesNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut CooperativeMatrixPropertiesNV,
) -> Result;
pub type FnCmdTraceRaysIndirectKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    indirect_device_address: DeviceAddress,
);
pub type FnGetDeviceAccelerationStructureCompatibilityKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_version_info: *const AccelerationStructureVersionInfoKHR,
    p_compatibility: *mut AccelerationStructureCompatibilityKHR,
);
pub type FnGetRayTracingShaderGroupStackSizeKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    group: u32,
    group_shader: ShaderGroupShaderKHR,
) -> DeviceSize;
pub type FnCmdSetRayTracingPipelineStackSizeKHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, pipeline_stack_size: u32);
pub type FnGetImageViewHandleNVX =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const ImageViewHandleInfoNVX) -> u32;
pub type FnGetImageViewAddressNVX = unsafe extern "system" fn(
    device: Option<Device>,
    image_view: Option<ImageView>,
    p_properties: *mut ImageViewAddressPropertiesNVX,
) -> Result;
pub type FnGetPhysicalDeviceSurfacePresentModes2EXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_present_mode_count: *mut u32,
    p_present_modes: *mut PresentModeKHR,
) -> Result;
pub type FnGetDeviceGroupSurfacePresentModes2EXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_modes: *mut DeviceGroupPresentModeFlagsKHR,
) -> Result;
pub type FnAcquireFullScreenExclusiveModeEXT =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnReleaseFullScreenExclusiveModeEXT =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    p_counter_count: *mut u32,
    p_counters: *mut PerformanceCounterKHR,
    p_counter_descriptions: *mut PerformanceCounterDescriptionKHR,
) -> Result;
pub type FnGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
    p_num_passes: *mut u32,
);
pub type FnAcquireProfilingLockKHR =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const AcquireProfilingLockInfoKHR) -> Result;
pub type FnReleaseProfilingLockKHR = unsafe extern "system" fn(device: Option<Device>);
pub type FnGetImageDrmFormatModifierPropertiesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_properties: *mut ImageDrmFormatModifierPropertiesEXT,
) -> Result;
pub type FnGetBufferOpaqueCaptureAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const BufferDeviceAddressInfo) -> u64;
pub type FnGetBufferDeviceAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const BufferDeviceAddressInfo) -> DeviceAddress;
pub type FnCreateHeadlessSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const HeadlessSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_combination_count: *mut u32,
    p_combinations: *mut FramebufferMixedSamplesCombinationNV,
) -> Result;
pub type FnInitializePerformanceApiINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    p_initialize_info: *const InitializePerformanceApiInfoINTEL,
) -> Result;
pub type FnUninitializePerformanceApiINTEL = unsafe extern "system" fn(device: Option<Device>);
pub type FnCmdSetPerformanceMarkerINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_marker_info: *const PerformanceMarkerInfoINTEL,
) -> Result;
pub type FnCmdSetPerformanceStreamMarkerINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_marker_info: *const PerformanceStreamMarkerInfoINTEL,
) -> Result;
pub type FnCmdSetPerformanceOverrideINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_override_info: *const PerformanceOverrideInfoINTEL,
) -> Result;
pub type FnAcquirePerformanceConfigurationINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    p_acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
    p_configuration: *mut PerformanceConfigurationINTEL,
) -> Result;
pub type FnReleasePerformanceConfigurationINTEL =
    unsafe extern "system" fn(device: Option<Device>, configuration: Option<PerformanceConfigurationINTEL>) -> Result;
pub type FnQueueSetPerformanceConfigurationINTEL =
    unsafe extern "system" fn(queue: Option<Queue>, configuration: Option<PerformanceConfigurationINTEL>) -> Result;
pub type FnGetPerformanceParameterINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    parameter: PerformanceParameterTypeINTEL,
    p_value: *mut PerformanceValueINTEL,
) -> Result;
pub type FnGetDeviceMemoryOpaqueCaptureAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const DeviceMemoryOpaqueCaptureAddressInfo) -> u64;
pub type FnGetPipelineExecutablePropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_pipeline_info: *const PipelineInfoKHR,
    p_executable_count: *mut u32,
    p_properties: *mut PipelineExecutablePropertiesKHR,
) -> Result;
pub type FnGetPipelineExecutableStatisticsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_statistic_count: *mut u32,
    p_statistics: *mut PipelineExecutableStatisticKHR,
) -> Result;
pub type FnGetPipelineExecutableInternalRepresentationsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_internal_representation_count: *mut u32,
    p_internal_representations: *mut PipelineExecutableInternalRepresentationKHR,
) -> Result;
pub type FnCmdSetLineStippleEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
);
pub type FnGetPhysicalDeviceToolPropertiesEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_tool_count: *mut u32,
    p_tool_properties: *mut PhysicalDeviceToolPropertiesEXT,
) -> Result;
pub type FnCreateAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const AccelerationStructureCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_acceleration_structure: *mut AccelerationStructureKHR,
) -> Result;
pub type FnCmdBuildAccelerationStructuresKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
);
pub type FnCmdBuildAccelerationStructuresIndirectKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    p_indirect_device_addresses: *const DeviceAddress,
    p_indirect_strides: *const u32,
    pp_max_primitive_counts: *const *const u32,
);
pub type FnBuildAccelerationStructuresKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
) -> Result;
pub type FnGetAccelerationStructureDeviceAddressKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const AccelerationStructureDeviceAddressInfoKHR,
) -> DeviceAddress;
pub type FnCreateDeferredOperationKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocator: *const AllocationCallbacks,
    p_deferred_operation: *mut DeferredOperationKHR,
) -> Result;
pub type FnDestroyDeferredOperationKHR = unsafe extern "system" fn(
    device: Option<Device>,
    operation: Option<DeferredOperationKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetDeferredOperationMaxConcurrencyKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> u32;
pub type FnGetDeferredOperationResultKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> Result;
pub type FnDeferredOperationJoinKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> Result;
pub type FnCmdSetCullModeEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, cull_mode: CullModeFlags);
pub type FnCmdSetFrontFaceEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, front_face: FrontFace);
pub type FnCmdSetPrimitiveTopologyEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, primitive_topology: PrimitiveTopology);
pub type FnCmdSetViewportWithCountEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, viewport_count: u32, p_viewports: *const Viewport);
pub type FnCmdSetScissorWithCountEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, scissor_count: u32, p_scissors: *const Rect2D);
pub type FnCmdBindVertexBuffers2EXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
    p_sizes: *const DeviceSize,
    p_strides: *const DeviceSize,
);
pub type FnCmdSetDepthTestEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_test_enable: Bool32);
pub type FnCmdSetDepthWriteEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_write_enable: Bool32);
pub type FnCmdSetDepthCompareOpEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_compare_op: CompareOp);
pub type FnCmdSetDepthBoundsTestEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_bounds_test_enable: Bool32);
pub type FnCmdSetStencilTestEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, stencil_test_enable: Bool32);
pub type FnCmdSetStencilOpEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    face_mask: StencilFaceFlags,
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
);
pub type FnCmdSetPatchControlPointsEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, patch_control_points: u32);
pub type FnCmdSetRasterizerDiscardEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, rasterizer_discard_enable: Bool32);
pub type FnCmdSetDepthBiasEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_bias_enable: Bool32);
pub type FnCmdSetLogicOpEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, logic_op: LogicOp);
pub type FnCmdSetPrimitiveRestartEnableEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, primitive_restart_enable: Bool32);
pub type FnCreatePrivateDataSlotEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PrivateDataSlotCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_private_data_slot: *mut PrivateDataSlotEXT,
) -> Result;
pub type FnDestroyPrivateDataSlotEXT = unsafe extern "system" fn(
    device: Option<Device>,
    private_data_slot: Option<PrivateDataSlotEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnSetPrivateDataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: Option<PrivateDataSlotEXT>,
    data: u64,
) -> Result;
pub type FnGetPrivateDataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: Option<PrivateDataSlotEXT>,
    p_data: *mut u64,
);
pub type FnCmdCopyBuffer2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_copy_buffer_info: *const CopyBufferInfo2KHR);
pub type FnCmdCopyImage2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_copy_image_info: *const CopyImageInfo2KHR);
pub type FnCmdBlitImage2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_blit_image_info: *const BlitImageInfo2KHR);
pub type FnCmdCopyBufferToImage2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2KHR,
);
pub type FnCmdCopyImageToBuffer2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2KHR,
);
pub type FnCmdResolveImage2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_resolve_image_info: *const ResolveImageInfo2KHR);
pub type FnCmdSetFragmentShadingRateKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_fragment_size: *const Extent2D,
    combiner_ops: *const FragmentShadingRateCombinerOpKHR,
);
pub type FnGetPhysicalDeviceFragmentShadingRatesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_fragment_shading_rate_count: *mut u32,
    p_fragment_shading_rates: *mut PhysicalDeviceFragmentShadingRateKHR,
) -> Result;
pub type FnCmdSetFragmentShadingRateEnumNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    shading_rate: FragmentShadingRateNV,
    combiner_ops: *const FragmentShadingRateCombinerOpKHR,
);
pub type FnGetAccelerationStructureBuildSizesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const AccelerationStructureBuildGeometryInfoKHR,
    p_max_primitive_counts: *const u32,
    p_size_info: *mut AccelerationStructureBuildSizesInfoKHR,
);
pub type FnCmdSetVertexInputEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    vertex_binding_description_count: u32,
    p_vertex_binding_descriptions: *const VertexInputBindingDescription2EXT,
    vertex_attribute_description_count: u32,
    p_vertex_attribute_descriptions: *const VertexInputAttributeDescription2EXT,
);
pub type FnCmdSetColorWriteEnableEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    attachment_count: u32,
    p_color_write_enables: *const Bool32,
);
pub type FnCmdSetEvent2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    p_dependency_info: *const DependencyInfoKHR,
);
pub type FnCmdResetEvent2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags2KHR,
);
pub type FnCmdWaitEvents2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event_count: u32,
    p_events: *const Event,
    p_dependency_infos: *const DependencyInfoKHR,
);
pub type FnCmdPipelineBarrier2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_dependency_info: *const DependencyInfoKHR);
pub type FnQueueSubmit2KHR = unsafe extern "system" fn(
    queue: Option<Queue>,
    submit_count: u32,
    p_submits: *const SubmitInfo2KHR,
    fence: Option<Fence>,
) -> Result;
pub type FnCmdWriteTimestamp2KHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    stage: PipelineStageFlags2KHR,
    query_pool: Option<QueryPool>,
    query: u32,
);
pub type FnCmdWriteBufferMarker2AMD = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    stage: PipelineStageFlags2KHR,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    marker: u32,
);
pub type FnGetQueueCheckpointData2NV = unsafe extern "system" fn(
    queue: Option<Queue>,
    p_checkpoint_data_count: *mut u32,
    p_checkpoint_data: *mut CheckpointData2NV,
);
pub type FnCreateCuModuleNVX = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CuModuleCreateInfoNVX,
    p_allocator: *const AllocationCallbacks,
    p_module: *mut CuModuleNVX,
) -> Result;
pub type FnCreateCuFunctionNVX = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CuFunctionCreateInfoNVX,
    p_allocator: *const AllocationCallbacks,
    p_function: *mut CuFunctionNVX,
) -> Result;
pub type FnDestroyCuModuleNVX = unsafe extern "system" fn(
    device: Option<Device>,
    module: Option<CuModuleNVX>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDestroyCuFunctionNVX = unsafe extern "system" fn(
    device: Option<Device>,
    function: Option<CuFunctionNVX>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCmdCuLaunchKernelNVX =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_launch_info: *const CuLaunchInfoNVX);
pub type FnSetDeviceMemoryPriorityEXT =
    unsafe extern "system" fn(device: Option<Device>, memory: Option<DeviceMemory>, priority: f32);
pub type FnAcquireDrmDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    drm_fd: i32,
    display: Option<DisplayKHR>,
) -> Result;
pub type FnGetDrmDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    drm_fd: i32,
    connector_id: u32,
    display: *mut DisplayKHR,
) -> Result;
pub type FnWaitForPresentKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    present_id: u64,
    timeout: u64,
) -> Result;
pub type FnCreateBufferCollectionFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferCollectionCreateInfoFUCHSIA,
    p_allocator: *const AllocationCallbacks,
    p_collection: *mut BufferCollectionFUCHSIA,
) -> Result;
pub type FnSetBufferCollectionBufferConstraintsFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
) -> Result;
pub type FnSetBufferCollectionImageConstraintsFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
) -> Result;
pub type FnDestroyBufferCollectionFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetBufferCollectionPropertiesFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_properties: *mut BufferCollectionPropertiesFUCHSIA,
) -> Result;
pub type FnCmdBeginRenderingKHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_rendering_info: *const RenderingInfoKHR);
pub type FnCmdEndRenderingKHR = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
